WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:57.036 --> 00:30:00.326 A:middle
如今 现代 CPU

00:30:00.326 --> 00:30:02.156 A:middle
如果一次又一次地看到

00:30:02.156 --> 00:30:05.346 A:middle
相同路径 就会学习吸收

00:30:05.346 --> 00:30:06.696 A:middle
X 总是处于界内状态

00:30:07.356 --> 00:30:09.496 A:middle
加载这个数组 是可以的

00:30:10.406 --> 00:30:11.586 A:middle
为什么我不在

00:30:11.586 --> 00:30:14.516 A:middle
知晓其准确与否之前

00:30:14.516 --> 00:30:15.986 A:middle
先走一步 去推测一下呢

00:30:16.686 --> 00:30:17.816 A:middle
这就是它的工作原理

00:30:18.356 --> 00:30:20.496 A:middle
它执行此代码 以推测方式

00:30:20.496 --> 00:30:22.946 A:middle
获取代码路径

00:30:22.946 --> 00:30:25.066 A:middle
加载数据

00:30:25.066 --> 00:30:26.676 A:middle
在最终答案出现时

00:30:26.676 --> 00:30:28.896 A:middle
在该种情况下 不 这是一种

00:30:28.896 --> 00:30:30.536 A:middle
x 不正常的罕见情况

00:30:30.536 --> 00:30:31.606 A:middle
你不能一直加载

00:30:31.606 --> 00:30:33.886 A:middle
该数据 它会将其备份

00:30:33.886 --> 00:30:37.896 A:middle
并采用正确的代码路径

00:30:38.066 --> 00:30:39.116 A:middle
这怎么办

00:30:39.466 --> 00:30:43.056 A:middle
没关系 因为推测路径没有提交

00:30:43.056 --> 00:30:45.566 A:middle
它只是提前完成

00:30:45.566 --> 00:30:46.806 A:middle
以便我们可以利用

00:30:46.806 --> 00:30:48.896 A:middle
当原始问题

00:30:48.896 --> 00:30:50.786 A:middle
得出最终答案时

00:30:50.786 --> 00:30:52.226 A:middle
我已经完成了

00:30:52.796 --> 00:30:54.546 A:middle
这就是预测执行

00:30:55.626 --> 00:30:57.666 A:middle
那么这是怎样变成攻击的呢

00:30:58.056 --> 00:31:00.876 A:middle
事实证明

