WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:57.986 --> 00:37:01.126 A:middle
就不能在你的 iframe 中插入内容

00:37:01.446 --> 00:37:03.026 A:middle
当然 我们也可以

00:37:03.126 --> 00:37:05.386 A:middle
在网络进程中进行封锁

00:37:05.816 --> 00:37:07.236 A:middle
这很重要 对 因为

00:37:07.426 --> 00:37:08.886 A:middle
预测执行攻击

00:37:08.886 --> 00:37:10.116 A:middle
只能发生在同一进程空间

00:37:10.116 --> 00:37:12.056 A:middle
所以 我们要在

00:37:12.056 --> 00:37:13.336 A:middle
evil.example 可以执行

00:37:13.336 --> 00:37:15.716 A:middle
JavaScript 的位置之前将其切断

00:37:17.336 --> 00:37:19.756 A:middle
HttpOnly Cookie

00:37:19.756 --> 00:37:21.266 A:middle
真的能通过映射

00:37:21.266 --> 00:37:22.226 A:middle
预测执行攻击吗

00:37:22.666 --> 00:37:23.616 A:middle
是的 它们能

00:37:23.886 --> 00:37:25.606 A:middle
它们在这里

00:37:25.606 --> 00:37:27.776 A:middle
比尝试攻击跨站点脚本更重要

00:37:28.456 --> 00:37:31.426 A:middle
为什么 还记得那个旧的 API

00:37:31.426 --> 00:37:33.616 A:middle
document.cookie 是从 JavaScript

00:37:33.616 --> 00:37:35.236 A:middle
中查看 Cookie 的方式吗

00:37:36.076 --> 00:37:37.376 A:middle
既然我们不能 也不可以

00:37:37.376 --> 00:37:38.906 A:middle
再依赖同源策略

00:37:38.906 --> 00:37:41.646 A:middle
evil.example 可以

00:37:41.646 --> 00:37:43.636 A:middle
从你的内容到达 iframe

00:37:43.636 --> 00:37:44.956 A:middle
并实际读取 Cookie

00:37:45.816 --> 00:37:46.676 A:middle
非常糟糕

00:37:47.196 --> 00:37:49.016 A:middle
但是如果你将它们标记为 HttpOnly

00:37:49.516 --> 00:37:51.446 A:middle
WebKit 将确保

00:37:51.546 --> 00:37:52.896 A:middle
将它们保留在网络进程中

00:37:53.256 --> 00:37:54.456 A:middle
我们不需要将它们

00:37:54.456 --> 00:37:55.706 A:middle
移动到网页内容进程中

00:37:55.706 --> 00:37:57.216 A:middle
因为它们不需要在 document.cookie

00:37:57.216 --> 00:37:58.476 A:middle
API 中公开

00:37:59.506 --> 00:38:00.836 A:middle
因此 这会自动保护

