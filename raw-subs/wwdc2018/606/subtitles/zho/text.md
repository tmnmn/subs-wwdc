# Metal for Ray Tracing Acceleration

## Summary
Metal Performance Shaders (MPS) harnesses the massive parallelism of the GPU to dramatically accelerate calculations at the heart of modern ray tracing and ray casting techniques. See how ray tracing can provide greater realism in 3D scenes through improved shading, soft shadows, and global illumination. Understand how MPS accelerates ray-triangle intersections while enabling dynamic scene updates, and learn how to extend your app across multiple GPUs for even greater performance.

## Info
* Graphics and Games
* WWDC 2018 - Session 606 - iOS, macOS
* https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/

## Text
 [（Metal光线追踪加速技术
演讲606）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=17) [嗨 各位](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=23) [我是Sean James
是GPU软件工程师](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=25) [今天 我们将会讨论光线追踪技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=28) [你们可能已经在“国情咨文”中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=31) [看过我们的光线追踪演示
而且想要了解更多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=33) [也许你们想要在自己的app中
使用光线追踪技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=36) [今天 我将会介绍
如何在app中使用光线追踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=40) [以及如何使用Metal
在GPU上进行加速](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=44) [特别会介绍如何
使用Metal性能着色器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=48) [Metal性能着色器
是一个GPU计算基元](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=52) [已经针对所有iOS
和macOS设备进行优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=56) [MPS内置图像处理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=60) [线性代数和机器学习支持功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=63) [在前面的演讲里
我们大量讨论了这些主题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=66) [今年 我们还增加了训练支持功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=71) [关于这个主题 明天会有一个演讲](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=74) [今天…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=78) [我将会介绍今年我们
为光线追踪添加的新支持功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=79) [那么我们首先要问
什么是光线追踪？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=83) [光线追踪app的基本原理是
在光线与场景互动时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=87) [追踪光线的路径](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=90) [光线可以建模光照、声音
和其他形式的能量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=94) [光线追踪在渲染、音频](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=98) [和物理仿真方面均有应用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=102) [但是光线也可以表示更抽象的概念](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=104) [比如是否可以从一个点
看到另一个点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=107) [因此光线追踪还可以应用于冲撞检测](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=111) [人工智能和路径寻找](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=114) [但是今天我将会以渲染为例](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=117) [但是今天我将会以渲染为例](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=117) [讲述如何在app中使用光线追踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=120) [你们可以已经熟悉光栅化管道程序](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=125) [光栅化工作原理是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=128) [一次将一个三角形投影到屏幕上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=129) [并且投射相应像素点的阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=133) [在GPU硬件中
可以很快地实现此效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=135) [因此很多游戏和其他实时app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=138) [都选择使用此方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=140) [但是光栅化模型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=144) [难以模拟光线的特定物理行为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=145) [其中一个例子是反射](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=150) [在光栅化方法中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=153) [反射通常是使用近似方法实现的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=154) [例如立方体贴图
屏幕空间反射](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=157) [但使用光线追踪器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=160) [我们可以直接计算
精确的反射效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=161) [另一个例子是阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=165) [在光栅化方法中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=168) [通常使用阴影贴图
来实现阴影效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=169) [但是在实施会遇到一些问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=172) [比如偏差和分辨率问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=174) [此外](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=177) [软阴影贴图技术
会产生不均匀的软阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=178) [软阴影贴图技术
会产生不均匀的软阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=178) [利用光线追踪技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=183) [我们可以直接计算
确定点是否在阴影之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=184) [因此可以生成清晰的阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=188) [包括在物体之间的距离增大时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=190) [生成从硬到软的真实阴影过渡效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=194) [最后一个例子是球形淡出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=198) [它模拟光线在场景表面上的
淡出效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=202) [使用光栅化方法
很难实现球形淡出效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=205) [但是使用光线追踪器
却可以进行十分自然的建模](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=209) [事实上 许多游戏和实时app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=213) [都包含球形淡出效果组件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=215) [这些组件使用光线追踪器
进行预计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=217) [然后将结果存储到材质之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=220) [在运行时映射到几何形状上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=222) [当然 我们还可以使用
光线追踪器模拟许多其他效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=227) [例如环境光遮蔽
折射和面光源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=230) [以及摄像机效果
例如景深和运动模糊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=235) [因此 光线追踪技术被用于](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=239) [因此 光线追踪技术被用于](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=239) [许多高真实性离线渲染app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=241) [光线追踪技术的不足之处是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=245) [相比于光栅化方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=247) [它需要明显更多的计算资源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=249) [因为需要进行更多的计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=250) [来模拟这些效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=252) [让我们来详细了解](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=255) [光线追踪器的渲染原理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=256) [然后了解如何
使用Metal进行加速](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=258) [我们使用名为路径追踪的算法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=263) [在现实世界中
光源发射光子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=266) [它们在周围反射
直到进入摄像机或你的眼睛](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=269) [但是大多数光子
实际上并没有进入摄像机](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=273) [因此模拟效率非常低](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=277) [幸运的是…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=280) [根据光线的属性
我们可以进行反向推理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=281) [从摄像机开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=284) [我们将光线从摄像机
投射到场景之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=287) [然后计算交叉点的阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=293) [在生成阴影时 需要明白](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=296) [多少光线到达阴影点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=298) [多少光线到达阴影点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=298) [以及哪一部分的光线
反射到摄像机](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=301) [实际上有两个光源
我们将会分别讨论](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=305) [第一个光源是直射光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=310) [此光线从光源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=313) [直接到达阴影点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=315) [我们可以轻松地计算出
多少光线会直接到达](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=318) [以及哪一部分光线
会反射到摄像机](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=321) [我们需要做的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=325) [在将光线添加到图像之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=326) [检查阴影点是否位于阴影之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=329) [为此 我们可以从阴影点位置
朝向光源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=332) [投射更多阴影光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=335) [如果阴影光线不能到达光源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=339) [那么原始阴影点
就位于阴影之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=341) [我们不应该为图像添加光照效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=344) [另一个光源是非直射光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=348) [这是场景中
在到达阴影点之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=352) [从其他表面反射的光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=354) [为了收集非直射光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=357) [我们可以从阴影点
朝向随机方向](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=359) [我们可以从阴影点
朝向随机方向](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=359) [投射二次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=362) [然后我们在第二个交叉点
重复阴影效果流程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=364) [首先计算多少光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=369) [直接到达第二个交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=373) [以及哪一部分光线
会被反射回来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=375) [朝向前一个交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=377) [最终进入摄像机](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=379) [我们需要从二次交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=382) [投射另一束阴影光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=384) [我们可以多次重复这个过程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=388) [以模拟场景中的光线反射](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=391) [现在 为了获得
这些美观的软阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=396) [和反射光线效果…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=399) [对于路径上的每个点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=401) [我们都需要投射许多阴影光线
和二次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=404) [反射光线数量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=406) [将会呈指数增长](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=409) [为了避免这种指数增长](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=411) [我们只会选一条阴影光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=414) [和每次反射时的
一个二次光线方向](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=416) [这时图像中有很多噪讯](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=420) [但是我们可以通过多帧叠加
使图像变得均匀](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=422) [每个帧将会生成
自己的一次光线集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=426) [因此我们能够实施摄像机效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=429) [例如景深和运动模糊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=432) [让我们将这些过程
转换成为一个流程图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=436) [首先 我们生成一次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=440) [然后找到场景中的交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=442) [计算交叉点位置的阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=446) [请记住 这是一个迭代过程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=448) [将会产生更多的阴影和二次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=451) [将会在场景中
再次产生交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=454) [最后 将阴影颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=456) [写入图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=458) [这是渲染app的流程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=460) [但是 大量的时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=463) [实际上被花费在
光线三角形交叉测试上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=465) [这意味着 交叉区的渲染性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=469) [对总体渲染性能有很大的影响](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=471) [即使它与实际光照和阴影无关](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=474) [这个核心交叉问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=478) [这个核心交叉问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=478) [是所有光线追踪app
都会面临的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=480) [因此我们决定
解决这个核心交叉问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=484) [以实现高水平的交叉区性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=488) [并且专注于app的细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=491) [为此 今年](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=494) [我们引入了
MPSRayIntersector API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=495) [这个API加速
所有macOS设备](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=499) [和iOs设备的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=503) [GPU上的光线三角线交叉测试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=504) [我们希望这个API能够
很容易地集成到现有app之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=508) [因此我们通过Metal缓冲区
简单地接收光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=511) [MPS将会沿每条光线
寻找最近的交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=514) [然后在另一个Metal缓冲区中
返回结果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=517) [你只需要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=520) [在app中提供
一个Metal指令缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=522) [在这个缓冲区中
执行交叉测试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=525) [我们会将所有交叉测试工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=527) [编码到指令缓冲区中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=529) [让我们来更深入地分析
我们想要解决的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=532) [好的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=539) [好的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=539) [3D模型通常表示为
三角形阵列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=541) [我们需要做的事情是
搜索这些三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=546) [找出哪些三角形
与每条光线交叉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=549) [此外 我们需要分析](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=552) [哪些交叉点最接近
光线的起点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=554) [最简单的方法是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=559) [循环遍历所有三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=560) [检查光线的交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=562) [但是 即使是最小的场景
这个过程也会非常慢](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=565) [因此 我们创建了一个数据结构
名为“加速结构”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=569) [加速结构的工作原理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=574) [是递归地将场景划分为
多个三角形组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=575) [组中的三角形
在空间中相互邻近](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=579) [当需要将一条光线与场景交叉时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=582) [将光线与树中的边界方框进行交叉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=585) [如果光线未与边界方框交叉
就可以跳过整个子树](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=588) [最后 我们只需要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=593) [检查一小部分的三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=594) [以确定光线交叉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=596) [我们主要使用这方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=599) [我们主要使用这方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=599) [加速光线三角形交叉检查](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=600) [当然 这是一个简单的例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=603) [在实际场景中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=606) [加速结构可能会更加复杂](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=607) [从这个图示中 我们可以看出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=611) [加速结构正在适应
复杂的几何形状](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=614) [这意味着 我们的大多数时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=617) [仅用于搜索高复杂性
几何区域中的交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=619) [这正是我们想要的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=624) [我描述了加速结构是什么
以及它是如何工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=626) [让你们有直观的感受](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=629) [但实际上你们并不需要
过分关心这些内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=632) [因为MPS将会为你们
处理所有的工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=635) [请记住 我们使用三角形
建模我们的场景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=639) [这些三角形本身
可以使用顶点缓冲区中的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=641) [顶点进行表示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=643) [你只需要 调用MPS
顶点缓冲区中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=646) [创建一个加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=650) [当准备搜索交叉时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=653) [只需要将这个加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=655) [提供给交叉区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=657) [让我们来看如何使用此方法
创建一个真实app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=659) [让我们来看如何使用此方法
创建一个真实app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=659) [我们将这个app划分为三个阶段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=663) [首先 我们生成一次光线
找到光线与场景的交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=665) [然后计算阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=670) [这类似于我们使用
光栅化方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=671) [实现的效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=673) [但在接下来的步骤中
我们会更进一步](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=675) [接下来 我们将会添加阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=678) [MPS提供特殊的阴影光线支持](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=680) [可以加快app速度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=682) [最后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=686) [我们使用二次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=687) [模拟场景中的光线反射](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=689) [使用光栅化方法很难
实现这种效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=691) [但是 我们看到
使用光线追踪技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=693) [很容易做到这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=695) [让我们从一次光线开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=698) [我们需要做五件事](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=701) [首先 我们创建一个
光线三角形交叉检查器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=704) [然后 在我们的顶点缓冲区中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=708) [创建一个加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=710) [接下来 我们生成一次光线
将它们写入光线缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=713) [然后 我们使用
Intersector](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=718) [然后 我们使用
Intersector](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=718) [寻找光线与场景间的交叉区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=721) [最后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=724) [最后我们使用交叉区结果
计算阴影效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=725) [我们先来看Intersector](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=729) [MPSRayIntersector类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=732) [协调所有光线三角交叉区测试结果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=734) [我们只需要提供
想要用于交叉测试的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=738) [Metal设备](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=741) [接下来 我们将创建加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=745) [此加速结构用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=748) [MPSTriangle
AccelerationStructure类表示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=749) [同样地 要创建加速结构
我们只需要提供用于创建Intersector的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=753) [相同Metal设备](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=756) [然后 加入我们的vertexBuffer
指定triangleCount](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=760) [最后 我们创建加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=764) [只需要创建一次](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=767) [然后 就可以重复地](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=768) [多次使用这个加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=771) [接下来 将生成一次光线
将它们写入光线缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=776) [为此 将启动
一个双线程计算内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=781) [每个像素一个线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=784) [每个线程将这个光线结构
写入光线缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=786) [可以设想 输出图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=791) [在摄像机正方的平面上飘浮](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=793) [一次光线从摄像机中发出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=797) [因此我以将原点
设置为摄像机位置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=799) [为了计算方向](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=802) [将从摄像机位置寻找方向](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=804) [穿过图像平面上的相应像素点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=807) [现在 已经生成一次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=812) [将用Intersector
寻找场景中的交叉区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=814) [encodeIntersection调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=818) [将我们创建的所有项目
关联在一起](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=820) [首先请记住 我们将会编码到
一个Metal指令缓冲区之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=823) [实际上 我们有多个选项](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=827) [来选择进行哪种类型的交叉区搜索](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=829) [本例中 我们使用最近的交叉区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=831) [将沿每条光线寻找最近的交叉区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=833) [然后 提供光线缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=838) [此缓冲区包含我们刚创建的一次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=839) [此缓冲区包含我们刚创建的一次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=839) [另外还提供交叉区缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=843) [此缓冲区包含交叉区结果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=844) [还需要提供rayCount](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=847) [在本例中 它是图像宽度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=849) [乘以图像高度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=851) [最后 提供我们的加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=853) [MPS将会沿每条光线
寻找最近的交叉区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=857) [并在交叉区缓冲中返回结果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=860) [最后剩下的工作是
使用交叉区数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=863) [计算阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=865) [为此 我们启动
另外一个计算内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=868) [可以像在片段着色器中那样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=871) [app光照和材质](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=873) [在片段着色器中可以使用的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=876) [大多数标准材质和数学函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=878) [都可以在计算内核中使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=880) [但是一般来说
阴影取决于交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=883) [和顶点属性
例如颜色和形态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=886) [在片段着色器中
GPU将为我们完成这些插值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=890) [但我们需要它们在交叉数据的基础上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=893) [自己进行插值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=895) [因此 让我们来看如何计算交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=898) [因此 让我们来看如何计算交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=898) [请记住
光线使用源点和方向进行定义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=903) [这是Intersector
返回的交叉区结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=909) [距离字段告诉我们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=913) [需要在光线方向行进多远的距离](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=915) [才能从光线起点到达交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=917) [如果光线不会与任何物体交叉
此距离将是负值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=921) [primitiveIndex
告诉我们遇到哪个三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=926) [我们使用最后一个字段
进行顶点属性插值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=930) [这个字段包含前两个质心坐标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=935) [即U和V](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=937) [第三个坐标对应于交叉点相对于](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=939) [三角形顶点的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=942) [实际上有三个质心坐标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=945) [组成一个坐标集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=947) [因此我们可以用1减去前两个坐标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=949) [计算出第三个坐标W](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=951) [如果仅定义三角形的
每个顶点的顶点属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=955) [插入的顶点属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=959) [插入的顶点属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=959) [仅仅是每个顶点的属性相加](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=962) [并使用质心坐标加权](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=965) [例如 如果设定每个顶点的颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=968) [那么插值颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=971) [就是每个顶点的颜色加权和](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=972) [到此为止 我们创建了
一个光线Intersector](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=978) [一个加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=980) [然后生成一次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=983) [找到光线与场景的交叉区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=985) [在交叉点计算阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=988) [然后 我们将阴影颜色
写入图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=990) [让我们来看图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=992) [我们可以看到加速结构
表示的几何形状](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=996) [以及插值顶点颜色
和计算出的光照效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=999) [图像已经显示在屏幕上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1003) [我们添加一些其他效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1005) [首先 为图像增加阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1008) [为此 在添加阴影之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1013) [需要检查](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1015) [光线是否可以到达阴影点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1018) [为此 可以添加
更多的阴影光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1020) [从交叉点投射到光源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1023) [如果阴影光线不能到达光源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1027) [那么初始阴影点就不是阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1030) [因此不应该添加其颜色到图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1032) [我们将修改阴影内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1037) [将附加阴影光线
写入另一个Metal缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1039) [然后 我们再次寻找
场景交叉区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1044) [然后启动最后一个内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1048) [此内核根据阴影光线
是否与任何物体交叉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1050) [有条件地
将阴影颜色写入图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1053) [因此 让我们开始修改阴影内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1056) [现在 阴影光线略微
不同于一次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1060) [首先…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1064) [我们需要提供
一个最大交叉距离](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1065) [这样 阴影光线
不会偏离光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1067) [我们不需要知道
将会遇到哪个三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1072) [或质心坐标是多少](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1074) [因此我们可以进行一些优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1076) [最后…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1080) [记住 我们不能
将阴影颜色写入图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1081) [除非我们知道原始阴影点
是否位于阴影之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1084) [因此我们需要一种方法
通过Intersector将颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1087) [从阴影内核
传递到最终内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1091) [这将会更新图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1094) [为此 可以自定义
我们的光线结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1096) [我们有多个选项](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1102) [选择为Intersector
提供哪些数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1103) [本例中
我们将使用一个数据类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1107) [它包含最小和最大距离字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1108) [MPS将会忽略
此范围之外的任何交叉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1112) [从而防止阴影射线
偏离光源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1115) [其次…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1120) [如果应用特定的光线相关数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1121) [可以将这些数据追加到
光线结构的末尾](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1125) [并且提供一个rayStride](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1127) [MPS从你的光线缓冲区读取数据时
将会跳过此数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1129) [在本例中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1133) [我们将阴影颜色添加到
光线结构的末尾](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1134) [这样 可以将它从阴影内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1137) [传递到最后内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1139) [传递到最后内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1139) [我们可以在光线Intersector上
配置这些选项](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1142) [首先…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1145) [设置rayDataType
以匹配我们的结构类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1146) [然后 设置rayStride](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1150) [以跳过结构末尾的颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1151) [接下来 通过Intersector
运行阴影光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1156) [这是Intersector
首次调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1160) [记住 阴影光线仅检查](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1163) [原始阴影点与光源之间的可见性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1166) [我们可以进行两项优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1168) [与自定义
rayDataType一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1171) [我们可以自定义
Intersection数据类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1174) [或Intersector的
返回数据类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1177) [在本例中只需要知道
距离是否为正值或负值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1181) [表示是否存在交叉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1185) [因此可以将intersection数据类型
设置为distance](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1187) [这会节省一些内存带宽](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1190) [加快Intersection
缓冲区读写速度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1192) [其次](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1197) [由于并不需要知道
将会遇到哪个三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1198) [由于并不需要知道
将会遇到哪个三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1198) [因此可以在遇到任意三角形时
结束交叉搜索](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1201) [通常情况下](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1204) [这比搜索最近交叉点的速度更快](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1205) [对此 MPS有一个专用模式
可以启用它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1209) [方法是传递任意intersectionType
而不是传递nearest](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1212) [最后 可以启动最后内核
将颜色添加到图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1218) [每个线程将读入一阴影光线和相应的
intersection数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1224) [如果交叉间距为正值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1230) [那么原始交叉点位于阴影之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1232) [不需要做其他工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1235) [否则 交叉点不在阴影之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1237) [因此 应读入光线颜色
将它写入输出图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1241) [这样就可以将阴影
添加到图像之中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1245) [我们可以看到
在添加光照到图像之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1250) [每个阴影点检查
光源是否可见](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1253) [由于我们使用光线追踪器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1257) [因此可以随机采样
光源的表面](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1259) [因此可以随机采样
光源的表面](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1259) [为我们提供这些美观的软阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1262) [最后 让我们来看二次光源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1267) [记住 二次光线模拟
场景反射光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1271) [为了添加二次光源
只需要把所有内核移入一个循环流程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1275) [在每次迭代中
将选择一个新随机方向](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1280) [以沿续光线路径](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1283) [然后 修改阴影内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1289) [为下次迭代生成光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1291) [完成图像更新之后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1295) [循环回到第一次交叉测试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1297) [可以根据需要的反射次数
重复这个循环流程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1300) [我们来看阴影内核修改](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1307) [在每次迭代中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1311) [我们将光线起点移至交叉点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1313) [然后选择一个随机方向
以继续光线路径](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1317) [然后选择一个随机方向
以继续光线路径](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1317) [最后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1321) [将光线颜色与插值顶点颜色相乘](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1322) [这样光线就会使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1326) [表面反射的颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1329) [在更高级的app中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1331) [计算将会更加复杂](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1333) [但是 通过认真选择随机光线方向](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1336) [可以取消其余的数学计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1338) [即使从摄像机反向投射光线
也同样可行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1342) [只要在每个交叉点
使用光线颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1345) [严格地为直射光线着色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1348) [对于二次光线
这就是我们要做的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1351) [光线可以从墙面反射到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1355) [箱子侧面和天花板上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1358) [这是我们的示例app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1362) [最初 屏幕上显示一幅图像
上面有一次光线和着色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1364) [然后我们添加阴影](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1369) [最后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1371) [使用二次光线模拟
场景中的光线反射](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1372) [让我们切换到演示
看看实时运行效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1376) [这是我们编写的app运行在
12.9英寸iPad Pro上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1383) [我们可以扩展此app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1389) [以支持更高级的光照
阴影、材质和其他效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1391) [让我们切换到更复杂的场景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1396) [这个场景使用了许多这样的特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1398) [这是Amazon Lumberyard Bistro场景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1405) [在“国情咨文”中运行
使用四个GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1408) [这个场景有将近一百万个三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1412) [但是 使用这些先进的
光照和着色技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1415) [我们仍能在iPad Pro上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1418) [实现将近两千万条光线/秒的
处理速度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1419) [这是一个综合指标
包括一次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1422) [阴影和二次光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1425) [我们创建了便于使用的API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1428) [你们现在就可以使用它们
开始实施这些类型的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1431) [这是我们的演示例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1436) [谢谢](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1439) [谢谢](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1439) [如果你们没有完全理解
也不用着急](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1443) [这个app作为例子
将会提供下载](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1445) [这个例子演示了
我今天讲述的所有内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1449) [强烈建议你们下载这个示例](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1452) [添加你们自己的几何
光照、阴影等等](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1455) [关于API 还有很多的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1459) [今天没有时间逐一讲解](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1461) [因此 建议你们查看](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1463) [文件和头文件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1465) [接下来 把舞台交给同事Wayne](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1467) [他将会介绍我们如何
将这项技术扩展到多GPU平台](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1470) [谢谢](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1475) [谢谢Sean](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1482) [大家好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1483) [你们很多人使用Mac计算机](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1487) [它有一个内置GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1490) [但是你们可能添加了
多个高性能eGPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1492) [我们希望能够使用所有这些GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1497) [我们希望能够使用所有这些GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1497) [以尽量提高光线追踪速度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1501) [我们应该怎么做？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1505) [我们需要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1506) [考虑三件事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1507) [首先](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1510) [我们如何在GPU之间
分配处理工作量？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1511) [其次](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1515) [有时候 GPU需要
一种方法来交换数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1517) [我们如何处理这个问题？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1520) [最后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1523) [还需要一个同步方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1524) [对此 我将介绍如何使用
新的Metal Events特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1527) [本周我们进行了相关的介绍](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1530) [让我们开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1532) [对于如何划分处理工作量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1535) [我们将会使用名称为
Split Frame Rendering的方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1536) [其原理是将帧分为多个区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1539) [然后将这些区域
分配给不同的GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1543) [从而可以并行地进行渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1546) [现在 每个GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1549) [都将运行完整渲染管道
前面Sean已经讲过](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1550) [这包括所有的处理
从初始光线生成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1554) [到阴影光线和着色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1556) [所有GPU完成处理之后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1560) [我们选择连接到显示的GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1562) [将会复制所有已经完成的区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1565) [以进行合成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1568) [合成是将各个区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1570) [拼接在一起](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1571) [然后放入帧缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1573) [你可能想要将它们
与先前的渲染组合在一起](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1576) [以增强图像质量和消除噪讯](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1579) [在开始进行渲染之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1583) [需要确保每个GPU
都有完整的场景副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1585) [需要在所有GPU上复制资产](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1590) [例如顶点缓冲区和材质](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1593) [然后 创建Sean前面说过的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1596) [三角形加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1598) [现在… 对于加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1602) [不需要为每个GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1604) [重头进行创建](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1607) [我们添加一个API
让你能够使用现有的加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1609) [为每个想要使用的GPU
生成一个副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1614) [这个副本是非递归性的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1618) [这个副本是非递归性的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1618) [因此 添加到加速结构的任何缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1621) [例如顶点和索引缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1624) [都需要单独复制它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1627) [然后 将它们添加到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1629) [刚才创建的加速结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1631) [现在 已经在所有GPU上
复制数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1636) [准备开始渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1639) [从多GPU角度来的
一件有趣的事情是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1641) [这部分的管道
其实与Sean前面描述的渲染管道](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1644) [没有什么差别](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1648) [唯一的差别在于对于多GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1650) [需要设定各个GPU所负责的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1652) [屏幕区域的光线生成工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1656) [其他部分都是相同的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1658) [因此](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1660) [让我们直接来看
多GPU方案中最复杂的阶段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1661) [也就是合成阶段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1666) [为了在macOS上获得最佳性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1671) [每个GPU都将渲染结果
放入自己的私有缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1674) [渲染完成后
我们将缓冲区复制到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1678) [渲染完成后
我们将缓冲区复制到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1678) [用于进行合成的GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1681) [不能直接在缓冲区之间进行复制](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1684) [因为Metal资源只能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1687) [在创建这些资源的设备上使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1689) [因此 不能在一个GPU上
创建缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1691) [然后尝试将它添加到
不同GPU的Blit编码器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1693) [这样是不行的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1696) [这意味着 我们的副本
将需要经过系统内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1698) [为了提高效率](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1703) [我们使用缓冲区管理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1705) [我们创建两个Metal缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1709) [每台设备一个包装通用CPU分配](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1711) [由于缓冲区包装相同的底层内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1716) [在设备A上写入
Metal缓冲区的任何内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1719) [对于设备B上的Metal缓冲区
来说都是可见的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1722) [如前所述](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1726) [为了确保macOS上的处理性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1728) [所有这些实际渲染工作
都使用私有缓冲区完成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1731) [然后 当需复制区域到不同GPU时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1735) [我们通过系统内存
Blit完成的区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1738) [我们通过系统内存
Blit完成的区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1738) [来看如何进行设置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1742) [首先 使用Metal共享存储模式
在设备A上创建缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1745) [这将会在内部分配系统内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1749) [使用.contents方法
指向此内存区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1752) [然后在设备B上创建缓冲区时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1758) [使用NoCopy API包装
刚才为缓冲区分配的内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1760) [对于此API 需要知道的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1767) [缓冲区必须是多页面大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1769) [因此在创建原始缓冲区时
必须设置合适的内存大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1772) [现在 我们可以在设备之间共享内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1778) [我们需要思考同步化问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1781) [为了描述这个问题
我们使用一个示例时间线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1783) [来描述两个并行运行的GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1786) [黑框表示指令缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1789) [绿框表示我们编码进入](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1791) [这些指令缓冲区中的工作内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1793) [例如 使用计算指令编码器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1796) [因此 上方GPU将进行渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1800) [渲染完成之后
它将完成的区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1803) [Blit进入前面所述的共享缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1806) [在此过程中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1809) [GPU B也在进行渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1811) [我们将使用这个GPU进行合成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1815) [因此在某一时间点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1818) [它将需要GPU A生成的缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1819) [这里可看到 有一个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1823) [这个区域没有同步化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1825) [因此 在GPU完成写入缓冲区之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1828) [不能阻止GPU B读取缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1832) [要处理该问题
可使用Metal Events](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1835) [利用Metal Events](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1839) [我们在指令缓冲区中
插入一个等待指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1841) [当GPU执行时
它会遇到等待指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1843) [然后就会停止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1845) [它等待的是
其他GPU的信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1848) [收到信号之后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1853) [我们就知道GPU A
已经完成缓冲区写入](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1855) [现在GPU B可以访问缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1858) [现在GPU B可以访问缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1858) [这种方法可以巧妙地
解决同步化问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1862) [但是很显然 使性能强劲的GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1866) [保持等待状态并不是一个良策](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1868) [因此需要尽快缩短等待](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1873) [理想的情况下 我们希望GPU
保持工作 而不是等待](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1876) [在这里 我们讨论的是
负载平衡问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1880) [因此 我们在GPU之间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1884) [均等地分配屏幕区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1886) [这有一个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1888) [首先 这没有考虑](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1890) [所使用的GPU性能可能存在差异](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1892) [如果一个GPU速度更快](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1895) [那么它会首先完成任务](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1897) [另一个问题是
一些屏幕区域的渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1901) [比其他区域更加复杂](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1904) [它们需要更长的时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1906) [它们可能有更复杂的几何形状
或更复杂的材质](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1907) [为了解决这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1912) [我们需要自适应地
调整区域大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1913) [这时的目标是确保每个GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1916) [使用大约相等的时间
完成其场景区域渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1919) [使用大约相等的时间
完成其场景区域渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1919) [为此 我们使用的方法是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1924) [从固定分区着手](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1925) [然后我们渲染一个帧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1928) [测量每个GPU需要
多长时间完成渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1930) [然后我们根据此结果确定](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1933) [为每个GPU分配多大的区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1934) [将会在app运行时
完成这些工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1939) [因此 它不断地适应](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1943) [你的GPU的性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1945) [无论使用哪个场景区域
来测量GPU的处理速度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1947) [都会使用指令缓冲区完成处理程序
来获得结果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1952) [完成处理程序是一个CPU代码块](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1958) [可在GPU完成执行
指令缓冲区之后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1961) [运行此代码块](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1963) [现在iOS上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1966) [指令缓冲区有多个有用的属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1969) [可以读取这些属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1970) [以发现在GPU上运行缓冲区的时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1972) [但是它们在macOS上不可用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1975) [我们需要确保处理时间大致相当](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1977) [我们使用的方法是
调用每个指令缓冲区完成处理程序时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1980) [存储主机时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1983) [如果对每个指令缓冲区执行此操作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1986) [就可以根据这些时间差异](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1988) [确定GPU运行时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1990) [举例来说](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1993) [为了估算这里显示的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1995) [三个指令缓冲区的执行时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1997) [我们测量完成处理程序调用的
时间间隔](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=1998) [对于指令缓冲区3
和指令缓冲区0](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2001) [这是理论性的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2006) [让我们来看实际运行情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2008) [这是Sean前面展示过的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2022) [Amazon Lumberyard Bistro场景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2024) [这次它在MacBook Pro上
运行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2027) [在屏幕上方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2030) [有一个每秒光线数量指标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2032) [可以知道运行速度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2034) [这包括一次光线
二次光线和阴影光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2037) [这包括一次光线
二次光线和阴影光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2037) [都包含在这个指标中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2041) [可以看到
每秒处理三千万条光线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2044) [而且](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2047) [如果速度加快 效果会更好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2048) [我想要启用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2050) [我连接的一个eGPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2051) [这里的文字显示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2057) [我们运行RX 580
和内置GPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2058) [性能提高了一倍
达到大约六千万条光线/秒](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2062) [可以看到这里的绿线](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2066) [它更好地显示
如何在GPU之间分配负载](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2068) [一个GPU渲染绿线上方的场景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2072) [一个GPU渲染绿线下方的场景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2075) [因此 通过使用eGPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2078) [能够将速度提高两倍](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2081) [但是我还有更高的期望](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2083) [问题是 eGPU
处于等待状态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2085) [这是因为我们使用固定分区方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2090) [如果我们切换为自适应负载均衡方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2092) [可以看到RX 580
现在承担了大部分的工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2096) [相比以前速度明显更快](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2099) [相比以前速度明显更快](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2099) [这个场景大约有一百万个三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2104) [现在我们切换到室外场景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2107) [这也是Amazon Lumberyard场景
只不过是室外场景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2109) [这个场景大约有三百万个三角形](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2113) [另外一个GPU处于等待状态
我们启用它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2117) [现在](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2120) [这个GPU是Vega 64](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2122) [可以看到Vega
承担了大部分的工作量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2124) [这个配置比较有趣](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2128) [因为有三个不同的GPU
在共同工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2130) [它们的架构不同](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2133) [而且性能差异很大](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2135) [但是它们协同工作
生成这幅高质量的图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2137) [今天 我们介绍了
MPSRayIntersector](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2151) [它是一个新的API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2154) [可用于在GPU上
加速光线三角形交叉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2155) [从前面的演示中可以看出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2159) [从前面的演示中可以看出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2159) [已经可以在所有的iOS
和macOS平台上使用此API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2161) [当你在macOS上添加GPU时
它具有良好的扩展性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2164) [我们希望看到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2169) [你们在app中
使用光线追踪技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2171) [今天 我们在示例中
使用了路径追踪方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2174) [以及混合渲染技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2177) [你们可能希望使用光线追踪技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2178) [生成美观的阴影
或环境光遮蔽 或反射](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2180) [另外还有一些非渲染app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2185) [例如 自动模拟、物理
AI、冲撞检测](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2187) [应用非常广泛](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2191) [为了帮助你们上手](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2194) [可以在developer.apple.com
查找示例代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2198) [因此请务必查阅](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2201) [另外还有头文件大量的文档](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2203) [以及其他特性的相关信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2206) [今天无法逐一讲解](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2208) [最后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2211) [明天12:00还有实验室](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2212) [Sean和我将会
更详细地讨论API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2214) [帮助你们在app中
使用光线追踪技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2217) [帮助你们在app中
使用光线追踪技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2217) [希望你们能参加](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2220) [最后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2222) [感谢你们参加本演讲](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2223) [希望你们在剩下的WWDC中
度过美好时光](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/606/?time=2224)