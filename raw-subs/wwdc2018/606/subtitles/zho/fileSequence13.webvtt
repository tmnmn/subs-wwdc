WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:01.148 --> 00:13:03.951 align:middle line:-2
为此 将启动
一个双线程计算内核

00:13:04.117 --> 00:13:05.652 align:middle line:-1
每个像素一个线程

00:13:06.486 --> 00:13:09.823 align:middle line:-2
每个线程将这个光线结构
写入光线缓冲区

00:13:11.458 --> 00:13:13.126 align:middle line:-1
可以设想 输出图像

00:13:13.193 --> 00:13:15.629 align:middle line:-1
在摄像机正方的平面上飘浮

00:13:17.397 --> 00:13:19.366 align:middle line:-1
一次光线从摄像机中发出

00:13:19.433 --> 00:13:21.768 align:middle line:-2
因此我以将原点
设置为摄像机位置

00:13:22.703 --> 00:13:24.004 align:middle line:-1
为了计算方向

00:13:24.471 --> 00:13:26.840 align:middle line:-1
将从摄像机位置寻找方向

00:13:27.007 --> 00:13:29.343 align:middle line:-1
穿过图像平面上的相应像素点

00:13:32.546 --> 00:13:34.047 align:middle line:-1
现在 已经生成一次光线

00:13:34.114 --> 00:13:36.583 align:middle line:-2
将用Intersector
寻找场景中的交叉区域

00:13:38.285 --> 00:13:40.087 align:middle line:-1
encodeIntersection调用

00:13:40.153 --> 00:13:42.456 align:middle line:-2
将我们创建的所有项目
关联在一起

00:13:43.457 --> 00:13:46.793 align:middle line:-2
首先请记住 我们将会编码到
一个Metal指令缓冲区之中

00:13:47.928 --> 00:13:49.162 align:middle line:-1
实际上 我们有多个选项

00:13:49.229 --> 00:13:51.498 align:middle line:-1
来选择进行哪种类型的交叉区搜索

00:13:51.999 --> 00:13:53.634 align:middle line:-1
本例中 我们使用最近的交叉区

00:13:53.700 --> 00:13:56.336 align:middle line:-1
将沿每条光线寻找最近的交叉区

00:13:58.172 --> 00:13:59.640 align:middle line:-1
然后 提供光线缓冲区

00:13:59.706 --> 00:14:02.776 align:middle line:-1
此缓冲区包含我们刚创建的一次光线

