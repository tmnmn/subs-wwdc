WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:58.125 --> 00:31:00.494 align:middle line:0
现在GPU B可以访问缓冲区

00:31:02.596 --> 00:31:05.699 align:middle line:-2
这种方法可以巧妙地
解决同步化问题

00:31:06.800 --> 00:31:08.802 align:middle line:-1
但是很显然 使性能强劲的GPU

00:31:08.869 --> 00:31:13.106 align:middle line:-1
保持等待状态并不是一个良策

00:31:13.841 --> 00:31:16.210 align:middle line:-1
因此需要尽快缩短等待

00:31:16.276 --> 00:31:19.279 align:middle line:-2
理想的情况下 我们希望GPU
保持工作 而不是等待

00:31:20.848 --> 00:31:23.183 align:middle line:-2
在这里 我们讨论的是
负载平衡问题

00:31:24.585 --> 00:31:26.587 align:middle line:-1
因此 我们在GPU之间

00:31:26.653 --> 00:31:27.988 align:middle line:-1
均等地分配屏幕区域

00:31:28.055 --> 00:31:29.723 align:middle line:-1
这有一个问题

00:31:30.357 --> 00:31:32.159 align:middle line:-1
首先 这没有考虑

00:31:32.226 --> 00:31:34.661 align:middle line:-1
所使用的GPU性能可能存在差异

00:31:35.662 --> 00:31:37.464 align:middle line:-1
如果一个GPU速度更快

00:31:37.531 --> 00:31:40.067 align:middle line:-1
那么它会首先完成任务

00:31:41.535 --> 00:31:44.538 align:middle line:-2
另一个问题是
一些屏幕区域的渲染

00:31:44.605 --> 00:31:46.139 align:middle line:-1
比其他区域更加复杂

00:31:46.206 --> 00:31:47.107 align:middle line:-1
它们需要更长的时间

00:31:47.541 --> 00:31:50.777 align:middle line:-2
它们可能有更复杂的几何形状
或更复杂的材质

00:31:52.246 --> 00:31:53.380 align:middle line:-1
为了解决这个问题

00:31:53.614 --> 00:31:56.049 align:middle line:-2
我们需要自适应地
调整区域大小

00:31:56.850 --> 00:31:59.152 align:middle line:-1
这时的目标是确保每个GPU

00:31:59.219 --> 00:32:02.656 align:middle line:-2
使用大约相等的时间
完成其场景区域渲染

