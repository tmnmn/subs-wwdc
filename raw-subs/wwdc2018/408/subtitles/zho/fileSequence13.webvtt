WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:46.496 --> 00:26:48.186 A:middle
我们已经谈论了
 
00:26:48.186 --> 00:26:50.576 A:middle
当编译器决定
 
00:26:50.576 --> 00:26:51.856 A:middle
重新编译一个文件时
 
00:26:51.856 --> 00:26:53.816 A:middle
我们可以通过一些技术来减少
 
00:26:53.816 --> 00:26:55.136 A:middle
编译器的工作量
 
00:26:56.106 --> 00:26:58.486 A:middle
但是如果完全不重新编译
 
00:26:58.486 --> 00:26:59.556 A:middle
这些文件会怎么样呢
 
00:26:59.956 --> 00:27:01.696 A:middle
是什么让编译器决定
 
00:27:01.926 --> 00:27:03.186 A:middle
一个文件是否需要
 
00:27:03.186 --> 00:27:03.906 A:middle
重新编译呢
 
00:27:04.636 --> 00:27:06.536 A:middle
这就需要我们了解
 
00:27:06.536 --> 00:27:07.836 A:middle
Swift 的依赖性模型
 
00:27:09.496 --> 00:27:12.326 A:middle
Swift 的依赖性模型
 
00:27:12.356 --> 00:27:13.686 A:middle
是基于文件的
 
00:27:14.056 --> 00:27:15.366 A:middle
这有一点棘手因为
 
00:27:15.466 --> 00:27:17.926 A:middle
在 Swift 中没有头文件
 
00:27:18.546 --> 00:27:20.236 A:middle
我们看到的都是
 
00:27:20.796 --> 00:27:22.626 A:middle
在我们的目标中被
 
00:27:22.706 --> 00:27:23.286 A:middle
默认定义的
 
00:27:24.256 --> 00:27:25.486 A:middle
在这个例子中
 
00:27:25.486 --> 00:27:26.936 A:middle
我在文件的左侧声明了
 
00:27:26.936 --> 00:27:27.316 A:middle
一个结构体 名字是 Point
 
00:27:27.866 --> 00:27:29.176 A:middle
如果我这时候从右侧引入一个文件
 
00:27:29.176 --> 00:27:31.106 A:middle
编译器就会知道我是对
 
00:27:31.106 --> 00:27:33.656 A:middle
第一个声明引入的
 
00:27:34.316 --> 00:27:35.766 A:middle
这也同样适用于
 
00:27:35.766 --> 00:27:37.466 A:middle
右侧文件的
 
00:27:37.466 --> 00:27:41.216 A:middle
X 和 Y 属性
 
00:27:41.416 --> 00:27:43.286 A:middle
这个以文件为基础的依赖性
 
00:27:43.286 --> 00:27:44.776 A:middle
意味着如果我改变左边的文件
 
00:27:44.776 --> 00:27:47.846 A:middle
那么两个文件
 
00:27:47.846 --> 00:27:49.086 A:middle
都需要被重新编译
 
00:27:50.306 --> 00:27:51.686 A:middle
这很重要因为
 
00:27:51.686 --> 00:27:52.886 A:middle
我们其实在尝试调用这个
 
00:27:52.886 --> 00:27:53.816 A:middle
初始化程序
 
00:27:54.016 --> 00:27:55.326 A:middle
我们想要确保我们
 
00:27:55.326 --> 00:27:56.486 A:middle
对其正确调用
 
00:27:57.036 --> 00:28:00.306 A:middle
编译器很智能
 
00:28:00.306 --> 00:28:01.976 A:middle
它能知道你什么时候在
 
00:28:01.976 --> 00:28:04.136 A:middle
一个函数主体中做了修改
 
00:28:04.166 --> 00:28:05.586 A:middle
在这个例子中是将 assertion 做得
 
00:28:05.586 --> 00:28:09.056 A:middle
更加合适 所以就只有那个文件
 
00:28:09.056 --> 00:28:10.316 A:middle
需要被重新编译
 
00:28:11.136 --> 00:28:13.446 A:middle
其他文件不需要改变
 
00:28:13.616 --> 00:28:15.556 A:middle
它们是如何使用第一个文件
 
00:28:15.586 --> 00:28:16.196 A:middle
的 API 的
 
00:28:16.646 --> 00:28:20.946 A:middle
不过 它确实需要稳妥一些
 
00:28:21.096 --> 00:28:22.916 A:middle
如果我为这个文件
 
00:28:22.916 --> 00:28:25.326 A:middle
增加了一个单独的类型 人们可以知道
 
00:28:25.326 --> 00:28:26.706 A:middle
这个新的 名为 path segment 的结构体
 
00:28:26.906 --> 00:28:28.636 A:middle
不会影响右侧的文件
 
00:28:29.256 --> 00:28:30.596 A:middle
但是编译器还是需要稳妥一些
 
00:28:30.596 --> 00:28:31.876 A:middle
它会重新编译
 
00:28:31.876 --> 00:28:32.186 A:middle
这两个文件
 
00:28:32.726 --> 00:28:36.116 A:middle
我们来看看这如何
 
00:28:36.116 --> 00:28:37.456 A:middle
应用到前面 David 用到的
 
00:28:37.456 --> 00:28:38.216 A:middle
游戏例子中
 
00:28:39.246 --> 00:28:40.576 A:middle
现在我们有 App 目标
 
00:28:40.576 --> 00:28:41.856 A:middle
和 Utilities 框架
 
00:28:41.856 --> 00:28:42.766 A:middle
我要在每个目标中
 
00:28:42.766 --> 00:28:44.426 A:middle
展示一些 Swift 文件

