WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.506 --> 00:33:01.536 A:middle
这就是我们检查的第一步

00:33:04.256 --> 00:33:07.306 A:middle
那么现在在右手侧

00:33:07.306 --> 00:33:08.716 A:middle
看到的就是

00:33:08.716 --> 00:33:10.446 A:middle
我们在这个函数

00:33:10.446 --> 00:33:11.666 A:middle
内部花的时间百分比

00:33:11.666 --> 00:33:14.196 A:middle
进一步就能看到

00:33:14.196 --> 00:33:16.326 A:middle
我们在每一行

00:33:16.326 --> 00:33:17.846 A:middle
花费的时间比例

00:33:19.186 --> 00:33:20.916 A:middle
注意 着色器性能分析器

00:33:20.916 --> 00:33:23.386 A:middle
适用与优化后的代码

00:33:23.386 --> 00:33:24.786 A:middle
因此编程器可以对指令

00:33:24.786 --> 00:33:26.946 A:middle
重新排序 并且某些行

00:33:26.946 --> 00:33:28.786 A:middle
可能没有定时信息

00:33:29.536 --> 00:33:32.366 A:middle
接下来就到定时信息了

00:33:32.866 --> 00:33:34.386 A:middle
我们有指令类型

00:33:34.526 --> 00:33:37.346 A:middle
让我们来看一看

00:33:37.606 --> 00:33:39.626 A:middle
大家能看到算术逻辑单元 在做数学运算时

00:33:39.626 --> 00:33:41.986 A:middle
花费了时间

00:33:41.986 --> 00:33:43.346 A:middle
我们正在从内存 纹理中读取

00:33:43.346 --> 00:33:45.696 A:middle
但是引起我关注的是

00:33:45.696 --> 00:33:46.986 A:middle
在同步中

00:33:46.986 --> 00:33:48.536 A:middle
花费的时间

00:33:48.936 --> 00:33:50.966 A:middle
尤其是在这儿等待内存的时间

00:33:51.586 --> 00:33:53.316 A:middle
这意味着我们的 GPU 不能

00:33:53.316 --> 00:33:55.336 A:middle
很快地读取数据 并且不能

00:33:55.336 --> 00:33:57.216 A:middle
通过在其他线程中 执行算术逻辑单元工作

00:33:57.216 --> 00:33:58.866 A:middle
来隐藏这个延迟

