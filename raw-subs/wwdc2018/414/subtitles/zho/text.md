# Understanding Crashes and Crash Logs

## Summary
Sudden app crashes are a source of bad user experience and app review rejections. Learn how crash logs can be analyzed, what information they contain and how to diagnose the causes of crashes, including hard-to-reproduce memory corruptions and multithreading issues.

## Info
* Developer Tools
* WWDC 2018 - Session 414 - iOS, macOS, tvOS, watchOS
* https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/

## Text
 [（理解崩溃和崩溃日志
演讲414）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=17) [大家早上好
感谢你们的到来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=19) [稍后一些非常聪明的人会到台上来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=26) [今天我们为你准备了一些很酷的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=29) [首先声明](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=34) [如果你从未编写过会崩溃的代码
则此演讲不适合你](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=37) [这次演讲是为我们中那些
会犯错误的人准备的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=43) [今天我们将讨论
你可以使用的工具和技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=49) [来更好处理你的崩溃代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=53) [若这些崩溃会影响到你的用户](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=56) [具体来说 我将介绍崩溃的基本原理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=58) [具体来说 我将介绍崩溃的基本原理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=58) [它们为什么会发生
它们是什么样的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=62) [然后我将向你展示我们的一些工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=65) [它们可以用来访问崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=68) [然后Greg将上台并介绍](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=72) [关于如何阅读崩溃日志内容的
更多细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=75) [然后他会深入探讨](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=78) [如何使用崩溃日志分析
棘手的内存问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=81) [接下来Kuba将向你展示
如何尽早发现线程竞争](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=84) [这些线程竞争常常导致崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=88) [并且这种崩溃非常难以重现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=90) [首先我们应该给它一个定义
什么是崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=93) [崩溃是当你的app
试图做一些不被允许的事情时的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=98) [突然终止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=102) [那么不允许的是什么？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=106) [有时CPU无法执行某些代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=107) [CPU不会除以零](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=111) [或者有时是操作系统
正在执行某些策略](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=114) [操作系统将通过终止你的app
来保护用户体验](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=119) [操作系统将通过终止你的app
来保护用户体验](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=119) [这种情况会发生在
当你的app启动时间过长](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=121) [或它使用了太多内存时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=124) [有时 你正在使用的编程语言](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=128) [会试图阻止失败并将触发崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=130) [Swift中的Array
和NSArray将终止你的进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=134) [如果你正试图越界访问数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=137) [或者有时是你
作为开发者试图阻止失败](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=140) [你可能有一个API
来断言参数是否为非nil](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=144) [这完全没问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=149) [大家以前应该都见过这个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=152) [这就是Xcode中调试器的样子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=154) [其被绑定到你的app上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=158) [并在你的app终止之前
暂停了该进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=160) [让我们仔细看看左边的这个回溯](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=165) [你可以在此处看到该app
是如何由操作系统启动的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=168) [当我们暂停时
我们可以看到主函数是如何被调用的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=173) [以及函数之间的互相调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=177) [以及函数之间的互相调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=177) [最终我们到达了你的代码中的这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=180) [在该处app除了崩溃别无他法
这里出现了一些问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=184) [最后调试器收到一个信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=189) [即此app即将崩溃并暂停app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=191) [有时候](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=196) [你并不总能很方便地绑定调试器
就像我们这里做的一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=197) [当你没有绑定调试器时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=201) [操作系统将以纯文本格式捕获此回溯](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=204) [并将其保存到磁盘中的
人类可读的崩溃日志中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=208) [实际上如果是你的app的
发布版本崩溃了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=212) [其崩溃日志看来并不这么清晰明了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=216) [其中实际包含的是
二进制名称和地址列表](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=218) [这是一个非符号化崩溃日志的片段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=222) [幸运的是 Xcode负责
对崩溃日志进行符号化处理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=225) [所以你会看到那些你熟悉的函数名](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=228) [文件名和行号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=231) [有很多方法可以访问这些崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=236) [有很多方法可以访问这些崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=236) [我想首先谈谈如何访问这些崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=240) [其可能来自TestFlight中的测试人员
或App Store中的用户](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=243) [你可以使用Xcode中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=248) [被称为Crashes Organizer的功能
来下载这些崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=250) [这就是它的样子
漂亮的暗色模式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=254) [让我们来浏览一下它的界面](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=258) [你可以在左侧看到你在](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=260) [TestFlight和
App Store上的所有app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=263) [它支持我们的所有平台
包括watchOS和app扩展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=266) [在右边 对于给定的崩溃点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=271) [你可以看到受影响的各种设备的数量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=274) [我们按类似问题 即类似崩溃点
来对崩溃日志进行分组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=277) [并按受影响的设备数量在源列表中
对它们进行排名](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=282) [你可以在下方翻阅各个日志的样本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=286) [当你单击此按钮时
你可以在项目的调试导航器中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=291) [打开崩溃日志并与源代码一起查看](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=296) [如果你以前没见过这个
它非常酷 我们稍后会看一下](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=299) [如果你以前没见过这个
它非常酷 我们稍后会看一下](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=299) [在详细视图中 我们会向你展示
一个完全符号化的回溯](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=303) [并突出显示崩溃点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=307) [既然我们已经熟悉了这个界面
那就让我们试试吧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=309) [我在这里打开了Xcode](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=313) [我将打开Organizer窗口](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=316) [你可以看到
我选择了Crashes选项卡](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=320) [即第二个标签](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=322) [我选中了Kuba和我正研发的
这款Chocolate Chip app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=324) [我已将此构建版本
上传到TestFlight](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=328) [你可以看到这是第五个构建版本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=332) [并且许多测试人员报告了崩溃现象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=335) [所以这不太好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=337) [你可以看到我已经处理过几起崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=338) [但我还没有处理过第一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=341) [所以让我们试着解决这问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=343) [这影响了242个设备](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=346) [我可以看到
app崩溃时所捕获的回溯](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=349) [并且崩溃点被突出显示了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=351) [现在我还不太清楚发生了什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=354) [但我确信如果我在源代码中
打开此崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=356) [但我确信如果我在源代码中
打开此崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=356) [我就能知道发生了什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=360) [所以我要点击
“Open in Project”按钮](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=362) [选择与app的第五次构建版本
相匹配的项目](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=364) [你能看到的是这个崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=368) [已在调试导航器中打开
就好像此app刚刚崩溃一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=372) [而且我们现在暂停在
这个发生严重错误的地方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=376) [这时该问自己这里该使用
fatalError函数吗？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=380) [我只想在绝对必要的情况下崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=384) [这是一个Int类型枚举的
初始化函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=388) [并且枚举值只能是0或1
否则我会触发这个严重错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=395) [我认为这是合理的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=400) [这个崩溃只有在程序员误用时
才会发生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=401) [如果我在这里向上查看调用堆栈](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=405) [我可以看到这个初始化函数的调用者](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=409) [即这个tableView委托方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=412) [此方法要获取给定块编号中的
头部对应的标题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=414) [因此该块编号不能是0或1](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=419) [因此该块编号不能是0或1](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=419) [现在我想我知道发生了什么事了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=422) [但让我们尝试在app中重现此问题
看看我们是否可以了解更多信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=425) [我点击开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=429) [Chocolate Chip是食谱app
我存储了所有我最喜欢的食谱](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=431) [我一直在测试这种生奶油食谱](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=435) [你可以看到一切正常](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=439) [我可以看到我的食材列表
以及步骤列表](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=440) [这是食谱的两个部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=442) [食材是第0部分 步骤是第1部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=444) [如果我点击另一个食谱](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=448) [我们崩溃了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=451) [我能看到的是
我们因同样的严重错误而停止了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=452) [并且回溯看起来与们一直在关注的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=456) [崩溃日志非常相似](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=458) [这个信号表明
我们正在处理同样的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=460) [我通过点击删除来清除此崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=463) [我们来看看这个调试会话](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=466) [在这个严重错误中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=470) [我可以看到提示消息被打印出来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=471) [即块编号为8](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=474) [这就是我们崩溃的原因
它不是0或1](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=476) [现在看起来这都是我的错](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=479) [现在看起来这都是我的错](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=479) [当我实现这个类时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=482) [我实现了另一个
名为numberOfSections的委托方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=484) [numberOfSections
的作用是返回头部的数量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=488) [然而我在这里返回的却是食材的数量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=492) [而ingredients.count的值为8](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=495) [信不信由你 我有个好方法
可以解决这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=498) [我知道我想要返回的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=501) [此RecipeSection
枚举中的实例数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=503) [并且在Swift 4.2中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=505) [Swift开源社区
添加了一些新功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=508) [非常感谢 这是一个名为
CaseIterable的协议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=511) [若我的RecipeSection
遵守CaseIterable](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=515) [我可以重新实现
numberOfSections函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=520) [返回该RecipeSection
枚举中所有实例的计数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=522) [这样我返回的值就为2](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=527) [我将返回块的准确数量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=531) [这样就对了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=533) [现在如果我查看这个
Chocolate Chip Cookies配方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=537) [现在如果我查看这个
Chocolate Chip Cookies配方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=537) [app没有崩溃
我可以看到所有的食材和步骤](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=540) [我做得很好 我对自己很满意](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=544) [我可以回到Organizer
并将此问题标记为已解决](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=548) [离开电脑并回去继续烘焙](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=552) [你刚看到的是如何使用
Crashes Organizer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=563) [从TestFlight
下载崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=566) [在源代码中打开日志
并解决问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=569) [那你怎样才能开始呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=574) [很简单](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=576) [对于你的用户
如果他们选择与第三方开发者共享](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=579) [这就可以了
他们的崩溃日志会自动上传](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=582) [你需要做的就是使用
Apple ID登录Xcode](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=586) [在上传app时 你应该包含符号表](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=591) [以便你能够得到崩溃日志的
服务器端符号化处理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=593) [打开Organizer窗口中
Crashes选项卡](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=598) [打开Organizer窗口中
Crashes选项卡](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=598) [来查看这些崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=600) [我们已经讲完了如何在
Organizer中查看崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=605) [但若你没通过TestFlight
或App Store分发app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=609) [你还有其它几种选择](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=612) [比如Devices窗口](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=615) [当你连接了设备时
你可以点击这个查看日志按钮](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=618) [这将显示该设备上保存的所有日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=622) [并且这些日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=625) [是使用Mac上的本地符号信息
符号化的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=626) [当你使用Xcode、Xcode Server
或Xcode Build运行-xe测试时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=631) [测试结果包将包含
来自你的app的任何崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=636) [它们是在该测试运行期间写出的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=641) [这非常方便
并且这些崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=643) [也是符号化的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=646) [你可以使用Mac控制台app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=649) [在Mac或模拟器中
查看任何崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=650) [在设备上选择Settings-&gt;Privacy-&gt;
Analytics-&gt;Analytics Data](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=655) [在设备上选择Settings-&gt;Privacy-&gt;
Analytics-&gt;Analytics Data](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=655) [你可以看到保存到磁盘的所有日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=661) [你的用户可以直接
在此屏幕上共享日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=663) [好的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=668) [为了确保符号化能够正常工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=669) [我想谈三个重要的最佳实践](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=672) [第一](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=676) [若你用Crashes Organizer
请与你的app一起上传符号表](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=678) [这是默认行为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=682) [这将确保服务器端符号化
能够正常工作 非常简单](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=683) [第二 请务必保存你的app档案](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=688) [你的档案包含调试符号的副本
即你的dSYM](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=693) [Xcode用Spotlight
查找dSYM](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=697) [并在必要时自动执行本地符号化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=700) [如果你上传包含位码的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=705) [你应该使用“Archives Organizer
Download Debug Symbols”按钮](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=709) [来下载位码编译生成的任何dSYM](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=713) [我们已经涵盖了我们提供的所有工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=718) [我们已经涵盖了我们提供的所有工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=718) [用于在发生崩溃时通过日志访问它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=722) [现在为了向你提供
有关阅读崩溃日志内容的深入指南](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=725) [请热烈欢迎Greg Parker](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=729) [（分析崩溃日志）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=733) [谢谢你 Chris](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=737) [我们刚刚看到了
如何使用Xcode查找崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=739) [以及如何在调试器的
Xcode工具中检查它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=743) [但崩溃日志文件包含更多信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=748) [它包含的信息远不止堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=751) [在调试你的问题的过程中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=755) [查看这些额外信息通常很有用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=758) [那么你如何得到崩溃日志的全文呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=761) [这是我们的
Xcode Organizer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=764) [如果我们调出上下文菜单
就会出现“Show in Finder”按钮](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=766) [“Show In Finder”
按钮将打开一个文本文件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=771) [我们可以在控制台app
或你喜欢的文本编辑器中打开它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=774) [它看起来像这样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=778) [它看起来像这样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=778) [那么这个文件里有什么呢？
让我们来看看](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=780) [文件顶部以一些摘要信息开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=783) [这包含你的app名称、版本号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=787) [运行它的操作系统版本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=790) [以及崩溃的日期和时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=793) [在它下面是崩溃的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=796) [这是操作系统发送的
用来杀死该进程的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=799) [具体错误或特定信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=803) [我们还可以看到一些日志信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=807) [它位于“Application Specific
Information”这部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=810) [在某些情况下
此部分将包含控制台日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=814) [如果你有未处理的异常
则它可能包含异常回溯](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=817) [此部分并非始终可用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=822) [在iOS设备上 出于个人隐私原因
它通常会被隐藏](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=825) [但是在macOS的模拟器中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=831) [此部分可以包含有用的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=833) [在它下面 我们可以看到线程堆栈](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=837) [这些是在崩溃时运行的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=839) [这些是在崩溃时运行的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=839) [所有线程的回溯](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=842) [其中一个被标记为崩溃线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=844) [其它的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=847) [在进程终止时正在运行的所有线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=849) [在它下面是一些低级信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=853) [我们有崩溃线程的寄存器状态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=856) [还有加载到进程中的二进制数据镜像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=861) [这是app可执行文件
和所有其它的库](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=865) [Xcode使用它进行符号化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=870) [以查找符号 文件和行号信息
并显示在堆栈跟踪中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=876) [以上就是崩溃日志文件的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=881) [那么我们如何调试它
我们如何阅读 我们该看什么？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=883) [我们从崩溃原因开始
即异常类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=888) [在这个例子中
异常类型为EXC_BAD_INSTRUCTION异常](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=893) [SIGILL信号指的是
非法指令信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=898) [SIGILL信号指的是
非法指令信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=898) [这意味着CPU正在尝试执行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=903) [由于某种原因不存在或无效的指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=905) [这就是这个进程终止的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=910) [我们还可以查看崩溃的线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=914) [崩溃时正在运行的代码是什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=917) [这里我们在Swift运行时中
看到fatalErrorMessage函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=920) [我们并不清楚
fatalErrorMessage函数的作用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=925) [此案例中的错误消息被包含在 “Application
Specific Information”项中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=930) [所以我们可以看到当进程退出时
Swift运行时打印的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=936) [让我们仔细看看这个堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=945) [我们看到了
fatalErrorMessage函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=948) [并且是我们代码中的
一个函数调用了它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=951) [我们有一个Recipe类
其image函数被调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=955) [我们有一个Recipe类
其image函数被调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=955) [并且该函数由于某些错误又调用了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=960) [fatalErrorMessage函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=963) [因为这是带有完整调试信息的
符号化堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=966) [我们可以看到一个文件和代码行号
其指明崩溃发生的地方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=971) [所以我们可以看看那段代码
我们打开该项目](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=976) [这是RecipeImage.swift](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=980) [第26行是在崩溃中标记的那一行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=982) [你们中那些经验丰富的
Swift程序员](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=986) [应该容易猜出
为什么这行代码可能会崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=989) [这是一个强制解包运算符](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=993) [我们有一个函数
即UIImage构造函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=997) [它返回一个可选值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1000) [如果可选值为nil](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1003) [强制解包运算符将停止进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1005) [生成崩溃日志并退出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1009) [若我们还记得刚才的app特定信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1013) [它包含当这个错误检查失败时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1017) [它包含当这个错误检查失败时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1017) [Swift运行时所打印的错误消息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1020) [即“在解包可选值时
意外发现nil”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1023) [这很好 因为它与代码一致](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1028) [我们在第26行有一个
强制解包运算符](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1032) [我们在崩溃日志中有一条错误消息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1036) [该消息说我们正在解包一个可选值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1039) [造成这次崩溃的原因
就变得很合理并且一致了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1041) [强制解包失败](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1049) [是代码中的前提条件或断言的
一个例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1051) [前提条件和断言是一种错误检查](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1056) [它在发现错误时主动停止进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1058) [它们的一些例子包括
我们刚刚看到的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1063) [强制解包可选值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1067) [Swift运行时将断言](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1068) [可选值不是nil](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1070) [否则就会崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1073) [另一个例子是
Swift.Array访问越界](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1075) [如果你访问一个数组且索引超出范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1079) [如果你访问一个数组且索引超出范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1079) [Swift运行时将失败](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1083) [检查到它不满足该前提条件
并终止该进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1085) [Swift算术溢出也包含断言](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1090) [如果将两个数字加在一起](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1093) [并且其结果对于整数变量来说太大了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1095) [这将无法满足一个前提条件
该进程将被终止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1098) [未捕获的异常通常是由
代码中的前提条件引起的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1102) [系统中存在许多错误检查
如果其前提条件无法满足](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1108) [它会抛出异常 如果没有捕获该异常](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1112) [未捕获的异常将写入崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1116) [当然你也可以在自己的代码中
编写断言和前提条件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1120) [如果你有一些错误
需要使进程崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1125) [并生成崩溃日志作为响应](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1128) [崩溃日志的另一个例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1132) [是操作系统从外部杀死进程的情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1134) [是操作系统从外部杀死进程的情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1134) [这方面的一个例子是监视程序事件
例如超时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1141) [如果你的app
花费过多时间执行某个任务](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1146) [操作系统可能会检测到它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1149) [并会终止进程并生成特定的崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1151) [环境条件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1157) [也可能导致操作系统终止进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1158) [如果设备过热](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1162) [操作系统将终止
使用过多CPU的进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1164) [如果设备内存不足](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1168) [操作系统将终止使用大量内存的进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1170) [另一种情况是无效的代码签名](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1174) [操作系统强制要求代码需要被签名](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1177) [如果签名无效或代码未签名](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1181) [操作系统将终止进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1184) [并生成特定类型的崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1186) [操作系统的这些终止行为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1190) [可以在Xcode的
Devices窗口中找到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1193) [你也可以在macOS控制台中
找到它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1195) [但它们并不总是出现在
Xcode Organizer中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1198) [但它们并不总是出现在
Xcode Organizer中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1198) [所以要小心这点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1201) [在Apple开发者文档中
我们有一个技术说明](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1205) [它描述了崩溃日志的
许多不同签名和结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1209) [就像这个例子一样
它们长什么样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1213) [你如何识别它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1216) [它比我们在这里讲的更详细](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1219) [但是让我们看一个例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1223) [这是另一个崩溃日志文件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1225) [同样 为了解崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1227) [我们从崩溃原因开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1230) [在这个例子中 崩溃的原因
是EXC_CRASH异常](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1232) [其带有SIGKILL信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1236) [通常SIGKILL信号被用在](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1239) [当操作系统想要终止你的进程时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1242) [它会发送SIGKILL信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1245) [SIGKILL信号无法被处理
你的进程也无法捕获它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1247) [作为对该信号的响应
该进程会终止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1252) [我们也可以在崩溃日志中看到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1256) [操作系统发送该信号的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1258) [操作系统发送该信号的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1258) [在这个例子中
终止原因的代码为8badf00d](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1261) [如果你查看我之前提到的
开发者技术说明](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1266) [它将描述8badf00d的含义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1269) [我们有一个文本描述说](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1273) [“耗尽实际时钟时间19.95秒”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1275) [所以如果我们将这些信息
与技术说明中的信息结合起来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1281) [它会告诉我们
我们的app启动时间太长](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1284) [我们有20秒钟启动
然而app没能在该时限内完成启动](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1289) [操作系统终止了该进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1293) [在下方我们可以看到
进程终止时的崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1296) [这些崩溃日志可能是说
代码花了太长时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1301) [它可能陷入死循环](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1305) [可能卡在等待网络I/O
这就是为什么我们花了太长时间启动](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1307) [或者 另一方面
也许这段代码是无辜的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1312) [并且在启动过程之前
有一些东西运行太慢了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1315) [这也可能是这个进程终止的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1317) [这也可能是这个进程终止的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1317) [启动超时 你如何能避免呢](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1324) [我们希望你能避免它们
启动超时是无法通过](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1327) [Apple app审核流程的
一个常见原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1330) [那你该怎么避免它呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1336) [首先当然是请测试你的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1337) [但是有一个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1339) [即模拟器中禁用了启动超时监视程序](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1342) [并且它在调试器中也被禁用了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1346) [所以如果你在模拟器和调试器中
进行所有测试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1349) [你永远不会看到超时警报](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1351) [因此在测试app时
请确保在没有调试器的情况下进行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1355) [如果是macOS app
请在Finder中启动你的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1360) [如果是iOS app
请在TestFlight中运行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1363) [或使用iOS app启动器来启动](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1367) [所有这些方法都将在调试器外
运行你的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1371) [并会启用且强制执行
对启动超时的监控](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1374) [当你测试时 请在真实设备上进行
即在模拟器之外进行测试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1378) [当你测试时 请在真实设备上进行
即在模拟器之外进行测试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1378) [并尝试使用较旧的硬件
测试你的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1382) [即你希望app所支持的最旧的硬件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1386) [如果你只在较新的硬件上测试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1390) [你可能会发现你的app
在更快的设备上启动得足够快](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1393) [但较慢的设备可能会花费太多时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1397) [让我们谈谈另一类错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1404) [让我们来谈谈内存错误
以及它们在崩溃日志中的样子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1406) [当我说内存错误时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1412) [我指的是像过早释放对象的引用计数
这样的情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1413) [或使用已经被释放的对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1419) [或缓冲区溢出
即有一个字节数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1423) [或一个C数组
而你尝试访问数组之外的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1427) [让我们看看另一个崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1433) [剧透一下 这是一个内存错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1435) [我们再次从异常类型开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1439) [我们再次从异常类型开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1439) [这是EXC_BAD_ACCESS
即段冲突信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1443) [这通常是由内存错误引起的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1450) [错误访问异常意味着两件事之一](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1453) [我们要么写入只读的内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1456) [要么我们尝试从内存中读取
根本不存在的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1460) [其中任何一个都会导致错误访问异常](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1464) [并且该进程将终止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1467) [我们在这里可以看到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1469) [我们在崩溃时试图访问的地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1471) [我们可以查看这些堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1476) [这就是执行错误访问的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1478) [这是objc_release函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1481) [它是Objective-C和
Swift对象中引用计数实现的一部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1485) [再者](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1490) [这听起来很可能是
导致该漏洞的内存错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1492) [那么是什么代码调用了
objc_release函数呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1497) [那么是什么代码调用了
objc_release函数呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1497) [我们可以查看堆栈跟踪的其余部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1500) [我们看到
object_dispose函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1503) [这是Objective-C
运行时中的一个函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1506) [它用于释放对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1509) [object_dispose函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1512) [在我们的一个类上调用了
名为__ivar_destroyer的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1514) [我们的LoginViewController类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1518) [__ivar_destroyer
函数是Swift代码的一部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1521) [这个函数用来清理属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1525) [即在一个对象被释放时
清除对象的ivar存储](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1528) [所以这告诉我们
造成崩溃的一部分原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1534) [我们当时正在释放
LoginViewController类的对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1537) [这个类在其初始化代码中
试图清理其属性及ivar](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1543) [并且在释放其中一个属性时
程序崩溃了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1549) [所以这给了我们
所发生问题的一些细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1554) [我们可以做得更好吗
崩溃日志中是否包含更多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1557) [我们可以做得更好吗
崩溃日志中是否包含更多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1557) [可以告诉我们发生了什么的信息？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1560) [我们可以看一下无效地址本身](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1563) [有时实际的错误地址值
将包含有用的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1567) [这个发生错误的地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1573) [我可以告诉你
它看起来像是使用了被释放的空间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1575) [我是怎么知道的呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1580) [部分是因为长期的经验
当你查看足够多的崩溃日志时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1581) [你就能够开始找出错误值的一些模式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1585) [这个错误值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1589) [看起来非常像malloc
内存分配器的地址范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1592) [我们碰巧在此崩溃日志中可以看到它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1598) [我们有了内存分配器使用的地址范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1601) [我们的无效地址看起来
就在malloc范围内](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1605) [但它被偏移了4位
它被旋转了4位](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1611) [所以看起来它是一个经过旋转的
有效malloc地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1615) [这是内存分配器本身提供的线索](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1621) [让我告诉你为什么是这样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1625) [这是我们的对象
在它仍然有效时的样子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1627) [一个对象以isa字段开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1631) [isa字段指向对象的类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1634) [这就是
Objective-C对象的结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1637) [这也是一些Swift对象的结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1639) [objc_release函数
是做什么的呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1643) [它读取isa字段
然后解引用该isa字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1646) [从而可以到该类对象中查找其方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1650) [通常这当然是有效的
这是正常情况下所发生的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1655) [但若我们的对象已被释放会怎样呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1659) [当释放函数删除一个对象时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1664) [它将其插入到一个
由其它无效对象构成的释放列表中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1668) [它会将一个释放列表指针
写入列表中的下一个对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1673) [写入位置
即以前isa字段所在位置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1678) [写入位置
即以前isa字段所在位置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1678) [但是以一种稍微扭曲的方式
它不会在该字段中直接写入指针](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1681) [而是将旋转后的指针写入该字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1685) [它想确保写在那里的值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1689) [不是有效的内存地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1692) [这正是错误使用该对象
造成崩溃的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1695) [所以当objc_release
读取isa字段时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1700) [它得到的是一个
旋转后的释放列表指针](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1703) [当它解引用旋转后的释放列表指针时
它就会崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1707) [内存分配器为我们做了这件事
它故意旋转了指针](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1711) [以确保如果我们再次尝试使用它
就会发生崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1715) [这就是我们在此崩溃日志中
看到的签名](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1720) [我们的无效地址字段看起来
像是malloc区域中的指针](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1723) [但旋转的方式与malloc
旋转其释放列表指针的方式相同](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1729) [这是一个明显的信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1734) [即我们在代码中尝试释放的对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1735) [即我们在代码中尝试释放的对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1735) [已被释放了 这就是发生的内存错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1740) [这就是该漏洞的更多细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1746) [我们的对象正被释放
我们正在清理它的ivar](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1749) [其中一个ivar已经是一个
被释放过的对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1753) [这就是造成我们崩溃的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1757) [我们可以做得更好吗？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1759) [我们可以找出是哪个对象
被objc_release释放了吗？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1761) [通常 调用
objc_release的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1767) [会给我们一个关于那是什么的线索](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1770) [但__ivar_destroyer函数的问题是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1773) [它是由编译器生成的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1776) [我们没有写过一个叫做
__ivar_destroyer的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1779) [这表示将没有文件名或行号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1782) [会被关联到崩溃中的这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1785) [我们不知道那时
我们的哪些属性正在被释放](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1787) [这是我们的类
我们在这个类中有三个属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1793) [它们分别是username
database和views数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1796) [这个时候](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1800) [我们不知道哪个对象
是正在被释放的对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1802) [它可能是其中任何一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1806) [我们可以做得更好吗？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1808) [我们能够从崩溃日志中
确定哪些对象是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1809) [正在被释放的对象吗？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1814) [因为如果我们无法在调试器中重现它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1816) [我们将只能从崩溃日志着手](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1819) [在这种情况下
我们的确可以做得更好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1822) [我们可以看到文件和行号
所在的行有一个“+42”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1825) [这个“+42”就是我们的线索](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1831) [因为“+42”是函数的
汇编代码中的偏移量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1834) [我们可以反汇编
__ivar_destroyer函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1840) [查看其代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1843) [确定在偏移量为42处所访问的属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1844) [该怎么做呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1850) [我们进入调试器控制台](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1851) [我们可以在终端上运行lldb](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1855) [我们可以在Xcode
调试终端中运行lldb](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1858) [我们可以在Xcode
调试终端中运行lldb](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1858) [调试器具有导入崩溃日志的命令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1864) [就像它在调试器内崩溃了一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1869) [我们运行此命令
来加载崩溃日志解释命令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1874) [然后我们运行另一个命令
将我们的崩溃日志导入调试器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1880) [我们需要三件东西来完成这项工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1885) [我们需要在Mac上获得
崩溃日志的副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1887) [我们还需要一份我们的app的副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1891) [以及该app对应的
dSYM文件的副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1894) [所有这些都与此崩溃日志相匹配
也要与app的版本相同](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1899) [这就是我们希望你
保留app档案的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1903) [如果我们在Mac上有了这些文件
我们会运行crashlog命令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1908) [lldb使用Spotlight
来查找匹配的可执行文件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1913) [找到匹配的符号表
并将其加载到调试器中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1916) [我们在这里可以看到
崩溃线程的堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1920) [我们可以看到文件和行号信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1923) [现在我们可以开始工作了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1927) [现在我们可以找到
__ivar_destroyer函数的地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1929) [并对其进行反汇编](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1932) [这向我们展示了该函数的汇编代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1935) [我没有时间教你如何阅读汇编代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1940) [但幸运的是 对于崩溃日志
你实际上并不需要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1943) [能够完全流利地阅读汇编代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1946) [通常只需要简单浏览汇编代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1950) [并大致了解发生了什么就足够了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1953) [你不必理解每一条指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1956) [来从崩溃日志中获取有用的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1959) [如果我们浏览这个函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1964) [并且我们知道调用指令和跳转指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1965) [它们是你调用函数的方式
我们可以将这段代码分成三个部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1970) [这是顶部](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1977) [这是顶部](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1977) [它正在执行一个
对引用计数释放函数的调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1980) [这部分代码正在释放
我们的username属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1985) [下一部分正在释放
database属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1990) [再下一个部分正在释放
views属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1994) [我们不明白所有这些指令的含义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=1998) [但我们大概知道每一部分代码的功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2002) [这有点像有一个与代码相关联的行号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2006) [现在我们回到崩溃日志中的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2012) [即__ivar_destroyer函数加42
其调用了objc_release函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2015) [在+42处有一个指令
但还有一个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2023) [那就是在堆栈跟踪中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2029) [大多数堆栈帧的汇编级别偏移量
都是返回地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2032) [它是函数调用之后的指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2037) [它是函数调用之后的指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2037) [所以调用objc_release
的指令是前面一条指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2040) [即这条指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2044) [如果我们读到这个 就说明它是对
objc_release的调用 这很好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2047) [这与我们在崩溃日志的堆栈跟踪中
看到的一致](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2051) [即在此偏移量的
对objc_release的调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2055) [这个释放函数正在释放
database属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2060) [现在我们有了关于崩溃时
正在做什么的更多细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2065) [我们释放了username属性
并且成功了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2069) [我们尚未运行到views属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2073) [它可能有效 可能无效
我们并不知道](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2076) [我们知道的是我们试图
释放database属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2079) [并且根据malloc释放列表指针
的签名 该对象看起来像一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2084) [已经被释放过的对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2088) [所以这告诉了我们
导致这次崩溃的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2092) [我们正在释放一个
LoginViewController对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2096) [而其中的database属性
是无效的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2099) [而其中的database属性
是无效的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2099) [我们目前为止还没有发现漏洞
这些代码都没错](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2104) [__ivar_destroyer函数没有错
我们的代码中应该有些别的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2108) [但是从崩溃日志中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2114) [我们已经能够缩小测试的范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2115) [以及我们应该在何处
尝试重现该漏洞的范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2119) [我们应该检验这个类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2122) [我们应该检验database字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2125) [我们应该阅读
使用该database对象的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2127) [并尝试找到错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2131) [那我们刚刚做了什么？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2135) [我们从头开始阅读崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2137) [从崩溃原因开始
我们读取了异常类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2138) [我们了解了异常类型的含义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2142) [我们检查了崩溃线程的堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2145) [了解它正在做什么
以及导致失败的实际错误是什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2150) [并且我们在崩溃日志的其它地方
寻找线索](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2155) [在这个例子中
我们使用了内存错误的错误地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2159) [在这个例子中
我们使用了内存错误的错误地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2159) [我们使用了崩溃函数的反汇编代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2162) [内存错误能导致类型广泛的崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2168) [崩溃日志中有许多不同的签名](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2174) [都可能是由内存错误引起的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2177) [以下是一些例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2180) [在Objective-C的objc_msgSend函数中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2182) [或在引用计数机制中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2186) [或Swift和
Objective-C的释放机制](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2188) [它们所发生的崩溃
通常是由内存错误引起的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2192) [另一种常见的内存错误症状是
无法识别的选择器异常](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2197) [这通常发生在
当你有某种类型的对象时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2203) [一段代码正在使用该对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2207) [然后对象被释放并再次被使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2210) [但与我们在前一个崩溃日志中看到的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2214) [malloc释放列表签名不同](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2217) [这次是在同一地址分配了一个新对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2219) [这次是在同一地址分配了一个新对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2219) [取代了以前旧对象所在的位置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2224) [所以当代码尝试使用旧对象时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2226) [调用旧对象上的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2230) [我们在该地址处却有一个
不同类型的不同对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2232) [并且它根本无法识别该函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2236) [因此我们得到一个
无法识别的选择器异常](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2239) [内存错误的另一个常见症状](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2244) [是内存分配器本身的终止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2247) [即在malloc和free函数内
调用abort()](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2251) [这是我们之前看到的
前提条件的一个例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2254) [这是内存分配器内部的前提条件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2258) [它可能识别到这样的情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2261) [即malloc内存
本身的堆数据结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2264) [已被内存错误破坏
这会终止进程并进行响应](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2269) [或者它可能检测到
malloc API的错误使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2273) [例如 如果你在一行代码中
连续两次释放一个对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2279) [例如 如果你在一行代码中
连续两次释放一个对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2279) [malloc分配器有时可以识别出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2283) [这是一个双重释放
并立即终止该进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2285) [让我给你一些最后的提示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2291) [以用于分析崩溃日志
特别是分析内存错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2293) [在刚才看到的崩溃中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2300) [我们大部分时间在
查看崩溃的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2302) [即崩溃的特定代码行和崩溃的线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2305) [查看进程中其它
与崩溃代码相关的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2309) [非常重要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2313) [例如 在这次崩溃中
__ivar_destroyer函数并没有错](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2316) [漏洞不在这里](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2321) [该漏洞位于其它地方
其它一些代码不正确](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2322) [除了崩溃线程之外
你还应该查看](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2329) [崩溃日志中的堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2332) [崩溃日志包含进程中的所有堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2336) [并且可能包含有用的信息和线索](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2339) [并且可能包含有用的信息和线索](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2339) [可以用来帮助你弄清楚
进程当时正在做什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2342) [也许其它线程会显示更多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2345) [关于当时app运行到何处的细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2349) [也许它当时正在执行网络代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2351) [这在其它某个堆栈跟踪上可以看到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2353) [或者可能存在多线程错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2357) [并且其它线程可能可以提供
有关线程竞争的线索](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2359) [你还应该查看多个崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2367) [以找出特定的崩溃原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2370) [Xcode Organizer
可根据代码中崩溃的位置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2373) [来帮助你对崩溃进行分组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2377) [有时候](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2380) [在同一个崩溃点会发生多次崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2383) [但有些日志可能会包含
比其他日志更多的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2386) [例如 我们刚看到的
malloc释放列表签名](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2390) [它可能出现在某些崩溃日志中
但在其它日志中就未必会出现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2394) [因此在同一个崩溃集中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2398) [因此在同一个崩溃集中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2398) [浏览多个崩溃
来查看其中一些信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2402) [是否比其它的信息更有用
是一种非常有效的方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2404) [此外 能够将
崩溃原因分组的Organizer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2408) [有时会将不同原因的崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2413) [分到同一组中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2417) [可能是其它线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2419) [或崩溃线程的回溯
让你识别出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2421) [对人眼来说
你会识别出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2425) [这组崩溃有多种原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2428) [尽管Xcode Organizer
将它们放在了一起](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2431) [如果你只查看一个崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2434) [你甚至可能不知道
第二次崩溃正在发生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2437) [直到你修复第一个崩溃并发布它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2440) [而你的用户开始
再次向你发送崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2443) [一旦你对崩溃做了一些分析](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2448) [一旦你缩小了
进程中可能发生崩溃的位置范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2450) [或者它可能正在使用的对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2454) [你可以使用
如Address Sanitizer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2457) [你可以使用
如Address Sanitizer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2457) [和Zombies等工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2460) [来尝试重现崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2461) [因为尽管我们在
malloc释放列表崩溃日志中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2464) [缩小问题范围时做得很好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2468) [但调试在调试器中发生的崩溃
要容易得多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2470) [你可以在测试中使用Sanitization
错误消息来告诉你发生了什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2474) [刚才我提到
应该查看多个堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2481) [多个线程堆栈](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2485) [以诊断多线程错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2486) [为了详细讨论调试多线程错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2489) [有请Kuba](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2493) [（多线程问题）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2495) [谢谢](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2501) [谢谢！](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2503) [正如Greg所说](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2505) [多线程问题可能导致一些内存损坏](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2506) [多线程错误通常是最难诊断和重现的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2511) [错误类型之一](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2514) [它们特别难以重现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2517) [因为它们只是偶尔会导致崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2518) [因为它们只是偶尔会导致崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2518) [因此你的代码似乎在99%的情况下
都能正常工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2521) [并且这些漏洞在很长一段时间内
都不会被发现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2525) [通常多线程错误会导致内存损坏](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2531) [并且你在崩溃日志中看到的内容
看起来也就像内存损坏一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2534) [我们已经看到了上一节中的例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2537) [当你处理malloc内部的崩溃时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2541) [或在释放或保留计数操作时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2543) [这些都是内存损坏的典型症状](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2546) [多线程错误也有一些特有的症状](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2550) [崩溃的线程通常包含 抱歉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2553) [崩溃日志通常包含](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2557) [多个正在执行彼此相关的代码的线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2559) [所以如果某个特定的类或方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2562) [出现在多个线程的崩溃日志中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2564) [这表示可能存在多线程错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2567) [多线程问题导致的内存损坏](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2571) [通常非常随机](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2575) [因此你可能会发现崩溃发生在
稍微不同的代码行上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2576) [因此你可能会发现崩溃发生在
稍微不同的代码行上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2576) [或稍微不同的地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2581) [正如Greg所说](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2582) [你可以看到它们在Xcode中
显示为不同的崩溃点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2584) [尽管它们属于同一个漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2589) [并且崩溃的线程可能并不是
该漏洞的罪魁祸首](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2591) [所以查看崩溃日志中其它线程的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2595) [堆栈跟踪很重要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2598) [现在让我们看一下
多线程漏洞的例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2600) [并且我会向你展示
如何诊断这样的漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2604) [通过使用名为Thread Sanitizer的工具
它是Xcode的一部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2606) [让我们再看看Chris和我写的
饼干配方app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2618) [这里有从用户那里收到的
更多崩溃日志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2622) [我们关注一下排名第二的崩溃
就是这个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2626) [此崩溃日志显示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2631) [当我们使用一个名为LazyImageView的类时
发生了错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2634) [这是我写的一个类 我们稍后再看它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2637) [这是我写的一个类 我们稍后再看它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2637) [但我们先看看能否从崩溃日志中
了解更多信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2641) [我们看一下这个线程的整个堆栈](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2645) [我可以通过点击这个按钮来做到这点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2647) [它也会显示所有其他线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2649) [如果我们注意最顶层的帧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2652) [我们会看到真正发生的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2655) [是free函数
正在调用abort函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2657) [这表示堆损坏 它是一种内存错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2660) [如果我们查看其它线程的堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2665) [比如这里的第5个线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2667) [我们会看到它还在LazyImageView中
执行了一些代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2669) [我们来看看这组崩溃中的另一次崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2675) [我们会发现所有这些崩溃日志
都有一个共同的主题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2679) [当free函数调用abort时
一个线程报告堆损坏](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2682) [而另一个线程正在处理
一段非常相关的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2687) [实际上是在同一个类中
即LazyImageView中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2692) [这很可能不是巧合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2695) [我非常怀疑这是一个多线程问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2698) [我非常怀疑这是一个多线程问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2698) [所以我们来看看
LazyImageView类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2702) [我点击此按钮](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2705) [来在我们的项目中打开它
并直接跳到这行代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2707) [你可以在这里看到
LazyImageView的源代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2711) [它是UIImageView的子类
但它有一个额外的功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2715) [即它可以惰性地并且异步地加载图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2719) [我们可以看下初始化函数的逻辑](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2722) [我们所做的是将作业分配到后台队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2725) [我们将在后台线程上创建图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2729) [一旦完成 我们将调度回主队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2732) [来在屏幕上实际显示图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2736) [崩溃日志指向这行代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2739) [我们这里正在访问
imageCache](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2742) [我们使用它来确保
我们不会不必要地多次创建](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2745) [相同的图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2749) [所以我的缓存实现方式可能存在漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2751) [让我们试着避免猜测
我将在模拟器中运行app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2754) [并尝试重现此崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2758) [并尝试重现此崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2758) [让我先关闭崩溃日志会话](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2760) [好的 这是我们的饼干配方app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2764) [你会注意到 如果我尝试
点击此处的“+”按钮](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2767) [来添加新食谱](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2770) [我们将需要为我们的新食谱
选择一张图片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2773) [现在屏幕上的这个控制器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2777) [使用LazyImageView
来显示所有这些图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2780) [因此只是在屏幕上显示它们
并滚动查看内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2783) [就已经运行了
LazyImageView中的所有代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2787) [但我没有看到任何崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2791) [不幸的是
这是多线程漏洞的常见问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2793) [众所周知 它们难以重现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2796) [所以即使你反复测试
有这样的漏洞的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2798) [你可能也无法看到一次崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2802) [让我们试着这样做](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2805) [我们多次尝试关闭并打开此控制器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2806) [并看看我们最终是否会](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2810) [幸运的触发此崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2813) [果然如此](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2820) [调试器已终止app
因为它已经崩溃了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2821) [但即使你的确在调试器中
捕获了这个崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2825) [这也并没有什么用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2828) [调试器所提供的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2830) [只是说存在某种
EXC_BAD_ACCESS](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2831) [但它没有解释导致崩溃的原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2834) [或者这为什么会发生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2837) [幸运的是 Xcode中有一个
非常适合这种情况的工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2839) [它被称为Thread Sanitizer
我现在就会使用它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2843) [让我们打开项目的方案编辑器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2846) [我点击此处的app名称
并选择Edit Scheme](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2848) [来做到这点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2851) [然后我切换到
Diagnostics标签页](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2853) [你会看到我们这里有
几个运行时诊断工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2857) [比如Address Sanitizer
它非常适合寻找缓冲区溢出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2861) [让我选中Thread Sanitizer
并且选中Pause on issues](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2865) [这意味着每次Sanitizer
检测到错误时 调试器都会中断](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2869) [让我们在启用了Thread Sanitizer的
模拟器中运行app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2874) [我们看看如果我尝试
添加新食谱时会发生什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2877) [我们看看如果我尝试
添加新食谱时会发生什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2877) [如果我现在点击“+”按钮
你会看到该app立即停止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2883) [因为Thread Sanitizer
发现了这个漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2887) [请注意 我没有进行多次尝试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2889) [Thread Sanitizer
非常可靠地重现了多线程问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2892) [让我们看一下这个漏洞的一些细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2897) [我们看到它是一个
Swift访问竞争](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2899) [如果我们查看左侧的调试导航器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2903) [我们甚至可以得到
有关此漏洞的更多详细信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2906) [我们看到两个不同的线程
执行了两次访问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2909) [这里是线程2和线程4
它们都试图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2913) [同时访问同一个内存位置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2917) [这是不允许的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2920) [如果我们查看正在构成竞争的
这两行代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2922) [我们发现它们都在访问
imageCache](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2927) [由于这是一个在多个线程之间
共享的数据结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2931) [就像我们在此看到的一样
它需要变为一个线程数据结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2935) [我们来看看它是如何实现的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2938) [我们来看看它是如何实现的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2938) [让我们跳到这里的storage
即我们正使用的变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2940) [让我们看看它是否真的是线程安全的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2943) [这是ImageCache的源码
就在这个文件顶部](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2946) [我们可以立即发现错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2950) [这只是一个普通的Swift字典
所以这并不好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2952) [Swift字典默认不是线程安全的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2956) [所以如果我们想在多个线程之间
共享一个可变的Swift字典](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2959) [我们必须使用同步来保护它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2964) [这意味着我们必须确保](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2967) [一次只能有一个线程访问它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2968) [现在让我们真正解决这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2971) [从而使该类成为线程安全的类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2974) [我将分两步完成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2976) [首先我将稍微重构一下这段代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2978) [以便我们可以更好地
控制storage变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2982) [然后在第二步中
我将使用调度队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2984) [来使这个类线程安全](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2987) [首先我不喜欢的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2990) [storage被声明为公有变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2992) [这意味着我的app中的任何代码
都可以访问它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2995) [而且很难确保](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2999) [而且很难确保](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=2999) [app中的所有代码
都能以正确的方式访问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3001) [所以让我们将其改为私有](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3004) [我还要引入另一种
访问imageCache的方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3007) [我将通过引入subscript
来做到这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3011) [这意味着
imageCache的用户](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3015) [可以使用括号
从缓存中加载和存储数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3017) [创建下标需一个这样的getter
以及一个setter](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3021) [现在暂时让我们通过](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3028) [直接访问底层存储来实现它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3030) [为了让这个文件的其它部分
能够成功构建](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3034) [我还需要更新其用户](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3037) [这里不能再直接访问
storage属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3038) [我们该在imageCache上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3042) [直接使用括号和索引
就像这样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3043) [如果我点击“Build Now”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3047) [你会看到代码现在能够正常编译](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3049) [但我目前还没有修复任何漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3052) [但我确实取得了一些成就](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3054) [我现在可以直接控制
所有访问storage的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3056) [我现在可以直接控制
所有访问storage的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3056) [即要么通过getter中的代码
要么通过setter](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3061) [我的app中没其他代码可以访问它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3064) [因此这对我实际修复
这个Swift访问竞争很有利](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3066) [让我通过使用调度队列来做到这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3071) [我们创建一个名为queue的
新私有变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3074) [并让我们为其分配一个新的调度队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3077) [调度队列默认是串行的
所以它也是串行的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3081) [这意味着在该队列中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3084) [一次只允许一段代码执行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3087) [这很完美
这正是我们在这里所需要的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3091) [我们如何在调度队列中执行代码呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3094) [我们可以使用queue.sync
被移动到queue.sync的任何代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3097) [都将在该串行队列中执行
并且一次只执行一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3104) [我可以在这里返回一个值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3108) [因为我需要从getter中
返回一些东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3110) [我也可以在setter中
做同样的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3113) [如果我将这行代码移到
这个queue.sync中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3117) [如果我将这行代码移到
这个queue.sync中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3117) [它将作为该调度队列的一部分执行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3120) [通过这种方式
这段代码现在是线程安全的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3124) [因为访问storage的
每一行代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3126) [都将在串行调度队列中执行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3130) [这意味着它一次只能执行一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3133) [而这对线程安全来说是正确的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3136) [现在你可能很想](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3138) [仅在更改storage变量的
setter中使用同步](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3142) [并在getter中避免使用它
就像这样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3145) [但这并不正确](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3148) [这仍然可能导致内存损坏
并再次导致崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3149) [我通过在模拟器中运行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3152) [此版本的代码来向你证明这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3154) [让我们看看Sanitizer
现在能否发现这个更微妙的错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3157) [如我所料 它的确发现了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3163) [我们必须使用同步](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3165) [同时保护
getter和setter](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3168) [让我最后一次
在模拟器中运行该app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3169) [你会看到如果我这次尝试添加新配方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3173) [控制器加载正常
并且我们不再收到任何警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3176) [控制器加载正常
并且我们不再收到任何警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3176) [因为该类现在是线程安全的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3180) [现在我可以回到
我们的Organizer窗口](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3182) [并将此崩溃标记为已解决](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3185) [因为我们已经找到和
识别并修复了这个漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3188) [我们刚看到的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3201) [我从一组具有多线程错误症状的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3203) [崩溃日志开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3206) [然后我使用这个
名为Thread Sanitizer的工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3209) [来识别并最终修复此漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3211) [Thread Sanitizer
不仅能检测多线程问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3215) [还可以使它们更可靠地重现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3218) [请注意 在演示中
我不必多次调用控制器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3222) [该工具适用于macOS和模拟器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3227) [但就像所有其他运行时诊断工具一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3230) [它只能通过实际运行代码
来查找其中的错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3233) [因此你应该牢记这一点并确保](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3238) [因此你应该牢记这一点并确保](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3238) [你的自动或手动测试程序使用了
Thread Sanitizer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3240) [特别是在使用线程或GCD的代码上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3244) [如果你想了解更多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3249) [我建议你观看我在2016年
WWDC中的演讲视频](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3250) [其标题为
“Thread Sanitizer和静态分析”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3255) [我们在其中介绍了这个工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3257) [并谈到了它的工作原理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3259) [提醒一下 Thread Sanitizer
可以在方案编辑器中找到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3263) [你可以点击Product-&gt;
Scheme-&gt;Edit Scheme](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3267) [来调出方案编辑器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3271) [然后你可以切换到
“Diagnostics”标签页](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3272) [你可以从中找到Thread Sanitizer
和一些其它运行时诊断工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3275) [我还想与你分享一个调试技巧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3281) [它在处理多线程时很有用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3284) [在创建调度队列时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3287) [你可以在初始化函数中
提供自定义标签](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3290) [你可以为操作队列指定自定义名称](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3294) [并且如果你正在使用线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3298) [你也可以在线程中使用自定义名称](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3299) [你也可以在线程中使用自定义名称](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3299) [这些名称和标签将显示在调试器中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3303) [但它们也出现在
某些类型的崩溃日志中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3305) [这可以帮助你缩小
多线程漏洞的可能原因的范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3308) [对于崩溃 我这里准备了三个要点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3315) [第一 在将你的app
提交到App Store之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3320) [总是在真实设备上对其进行测试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3324) [这可以帮助你避免
在app审核过程中被拒绝](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3327) [第二 当你的用户崩溃时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3331) [你应该总是尝试重现它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3335) [查看崩溃日志和堆栈跟踪](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3337) [并尝试找出你需要执行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3339) [app中的哪些部分
才能触发崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3342) [或尝试重现崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3344) [最后 对于难以重现的崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3346) [我建议使用漏洞查找工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3350) [比如Address Sanitizer
或Thread Sanitizer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3352) [它们分别可用于处理
内存损坏错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3355) [和多线程问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3358) [现在让我们回顾一下
今天所学到的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3362) [Chris向我们展示了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3365) [如何使用Xcode中的
Organizer窗口](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3366) [来获取统计信息
以及崩溃日志的详细信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3370) [Greg向我们展示了
如何阅读和分析崩溃日志文本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3374) [在许多情况下 它们可以被重现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3378) [比如当你处理
app启动超时问题的时候](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3380) [然后我们提到了难以重现的崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3384) [因为它们是随机发生的
比如内存损坏](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3387) [我们还提到了它们
在崩溃日志中留下的迹象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3390) [最后 我展示了漏洞寻找工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3394) [比如Sanitizer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3397) [如何帮助你重现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3398) [内存损坏和线程问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3400) [我建议你也使用这些工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3402) [如需了解更多信息
请访问我们演讲的网页](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3406) [其中还将包含我们提到的
技术说明的链接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3409) [以及提供调试技巧的其他文档](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3412) [它们在处理崩溃时很有帮助](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3415) [我还想提醒你
稍后有一个崩溃日志实验室](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3417) [我还想提醒你
稍后有一个崩溃日志实验室](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3417) [就在本场演讲结束后
中午12点开始 在8号技术实验室](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3420) [所以如果你有任何
关于崩溃和崩溃日志的疑问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3424) [请到实验室与我们讨论](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3426) [请享受WWDC的其余部分
非常感谢](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/414/?time=3427)