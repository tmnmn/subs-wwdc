WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:59.733 --> 00:50:01.568 align:middle line:-1
因为你将以不同方式进行压缩

00:50:01.635 --> 00:50:04.438 align:middle line:-1
你将会尝试提高连接的效率

00:50:05.138 --> 00:50:07.975 align:middle line:-2
但如果你有一个
生成实时数据的app

00:50:08.041 --> 00:50:11.545 align:middle line:-2
尤其是如果你使用UDP
来发送和接收大量数据包

00:50:11.879 --> 00:50:15.449 align:middle line:-2
我邀请你尝试在你的app中
使用Network.framework

00:50:15.816 --> 00:50:17.084 align:middle line:-1
并在工具软件中运行它

00:50:17.651 --> 00:50:20.621 align:middle line:-2
测量当你使用Network.framework
与套接字时

00:50:20.687 --> 00:50:22.823 align:middle line:-1
它们各自的CPU使用量的差异

00:50:23.056 --> 00:50:24.992 align:middle line:-1
我认为你会对所看到的结果感到满意

00:50:30.531 --> 00:50:32.766 align:middle line:-1
我们今天要讨论的最后一个话题

00:50:33.000 --> 00:50:36.436 align:middle line:-1
是解决网络移动性问题的方法

00:50:36.904 --> 00:50:39.273 align:middle line:-2
这是我们使用
Network.framework

00:50:40.274 --> 00:50:41.875 align:middle line:-1
尝试解决的关键领域

00:50:42.643 --> 00:50:44.711 align:middle line:-1
它的第一步

00:50:45.345 --> 00:50:47.915 align:middle line:-1
只是确保我们能够优雅地开始连接

00:50:48.715 --> 00:50:51.118 align:middle line:-2
我们已经提到了这一点
但我想稍微回顾一下

00:50:51.752 --> 00:50:52.953 align:middle line:-1
等待状态

00:50:53.487 --> 00:50:56.523 align:middle line:-1
是在你的连接刚建立时

00:50:57.191 --> 00:50:59.226 align:middle line:-1
处理网络切换的关键

00:50:59.593 --> 00:51:01.862 align:middle line:-1
当你正在做DNS或TCP时

