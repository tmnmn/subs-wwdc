WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:03:58.672 --> 00:04:00.707 align:middle line:-2
你可能告诉内核
我想要100个字节

00:04:00.841 --> 00:04:03.577 align:middle line:-2
而内核可能会回答说
我现在只有10个字节

00:04:03.644 --> 00:04:04.778 align:middle line:-1
你为何不稍后再回来呢

00:04:04.945 --> 00:04:06.113 align:middle line:-1
你必须建立一个状态机

00:04:06.180 --> 00:04:07.548 align:middle line:-1
以跟踪你读取的字节数

00:04:07.614 --> 00:04:09.016 align:middle line:-1
与你想要读取的字节数

00:04:09.216 --> 00:04:11.885 align:middle line:-2
这个工作量可能会很大
而且要想使其表现良好

00:04:11.952 --> 00:04:13.153 align:middle line:-1
可能是一个真正的挑战

00:04:14.555 --> 00:04:15.689 align:middle line:-1
最重要的是

00:04:15.756 --> 00:04:17.991 align:middle line:-1
你真的不应该直接读写套接字

00:04:18.058 --> 00:04:20.627 align:middle line:-1
因为你应该使用安全传输层协议

00:04:20.694 --> 00:04:21.728 align:middle line:-1
即TLS之类的东西

00:04:24.097 --> 00:04:25.766 align:middle line:-1
套接字不支持TLS

00:04:25.832 --> 00:04:28.001 align:middle line:-1
所以你可能正在使用其它一些库

00:04:28.402 --> 00:04:30.971 align:middle line:-1
它们会为你处理TLS

00:04:31.038 --> 00:04:33.040 align:middle line:-1
并替你读取和写入套接字

00:04:33.106 --> 00:04:35.943 align:middle line:-2
或者你也可以编写
该库和套接字之间的胶水代码

00:04:36.109 --> 00:04:37.744 align:middle line:-1
而且你必须弄清楚如何预先放入

00:04:37.811 --> 00:04:40.113 align:middle line:-2
那些复杂的连接逻辑
并让所有这些正常工作

00:04:41.515 --> 00:04:43.283 align:middle line:-1
这里有很多东西可能非常困难

00:04:45.285 --> 00:04:48.088 align:middle line:-2
最后 使用套接字对移动性
带来极大的挑战

00:04:48.388 --> 00:04:49.690 align:middle line:-1
这有多种原因

00:04:51.225 --> 00:04:55.262 align:middle line:-2
我认为这很大程度上归结于
当套接字刚出现时

00:04:56.029 --> 00:04:58.632 align:middle line:-1
许多设备需要不止一个人来移动它们

00:04:58.699 --> 00:05:00.434 align:middle line:-1
而且它们只用一根网线连接

