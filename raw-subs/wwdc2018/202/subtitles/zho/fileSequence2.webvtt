WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:56.286 --> 00:02:00.476 A:middle
当然一旦第一帧生成

00:02:00.526 --> 00:02:02.246 A:middle
我们再滑动内容

00:02:02.246 --> 00:02:03.696 A:middle
这时 CPU 的工作量
 
00:02:03.696 --> 00:02:05.236 A:middle
又变小了

00:02:05.236 --> 00:02:06.806 A:middle
和一般滑动差不多

00:02:07.386 --> 00:02:11.676 A:middle
为什么那个第一帧

00:02:11.676 --> 00:02:14.116 A:middle
会比别的帧更高耗

00:02:14.776 --> 00:02:18.096 A:middle
让我们从 UITableView 的角度看一下

00:02:18.096 --> 00:02:22.066 A:middle
但其实这个和 UICollectionView   

00:02:22.066 --> 00:02:23.226 A:middle
或者其他相似的

00:02:23.226 --> 00:02:24.786 A:middle
自定义视图

00:02:24.786 --> 00:02:25.156 A:middle
都是一样的

00:02:25.866 --> 00:02:28.706 A:middle
这一帧的工作

00:02:28.756 --> 00:02:30.386 A:middle
开始于当你

00:02:30.386 --> 00:02:32.296 A:middle
在 TableView 执行

00:02:32.396 --> 00:02:33.616 A:middle
cellForRowAt IndexPath

00:02:33.676 --> 00:02:34.306 A:middle
的委托方法时

00:02:34.906 --> 00:02:39.316 A:middle
首先选择想显示的 Cell

00:02:39.746 --> 00:02:40.786 A:middle
我们要试着让它

00:02:40.856 --> 00:02:44.666 A:middle
从重复使用序列中脱离出来

00:02:44.666 --> 00:02:45.966 A:middle
如果它本身不在序列中

00:02:45.966 --> 00:02:46.936 A:middle
我们需要

00:02:46.936 --> 00:02:48.326 A:middle
做一些内存分配

00:02:48.326 --> 00:02:50.176 A:middle
来做好准备

00:02:51.036 --> 00:02:52.196 A:middle
有了 Cell 之后 我们

00:02:52.196 --> 00:02:53.446 A:middle
会用你的模型数据

00:02:53.446 --> 00:02:54.316 A:middle
来填充这个 Cell

00:02:54.916 --> 00:02:56.496 A:middle
这一步有多高耗

00:02:56.496 --> 00:02:59.496 A:middle
取决于你的 App

00:02:59.496 --> 00:03:01.476 A:middle
但可能包含很多

