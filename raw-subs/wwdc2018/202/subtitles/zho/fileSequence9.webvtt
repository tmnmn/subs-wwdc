WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.976 --> 00:09:01.556 A:middle
我们希望尽量

00:09:01.606 --> 00:09:05.186 A:middle
让 CPU 保持在低水平来节省电量

00:09:05.526 --> 00:09:08.566 A:middle
这很好 但不太好的是

00:09:08.646 --> 00:09:11.226 A:middle
在性能提升前需要一点时间

00:09:11.426 --> 00:09:12.716 A:middle
昨天的演讲中

00:09:12.816 --> 00:09:14.566 A:middle
也提到过这个

00:09:14.726 --> 00:09:17.396 A:middle
等性能提升后

00:09:17.396 --> 00:09:18.876 A:middle
再加载我们

00:09:18.876 --> 00:09:20.126 A:middle
想显示的 Cell

00:09:20.126 --> 00:09:21.606 A:middle
已经太晚了

00:09:21.676 --> 00:09:24.016 A:middle
所以还是丢失了这一帧

00:09:24.806 --> 00:09:26.446 A:middle
现在 因为我们拥有

00:09:26.446 --> 00:09:27.616 A:middle
整个软件栈

00:09:27.616 --> 00:09:29.976 A:middle
在 iOS 12 里

00:09:29.976 --> 00:09:33.606 A:middle
我们把在高级别 UIKit 框架里

00:09:33.676 --> 00:09:36.446 A:middle
滚动时或当临界区域发生时

00:09:36.446 --> 00:09:38.016 A:middle
的所有信息

00:09:38.016 --> 00:09:41.296 A:middle
传递到低级别 CPU 性能控制器

00:09:41.326 --> 00:09:42.996 A:middle
这样就可以

00:09:43.116 --> 00:09:45.116 A:middle
更智能地分析

00:09:45.336 --> 00:09:46.546 A:middle
现有任务

00:09:46.756 --> 00:09:50.346 A:middle
并预测这些高峰何时出现

00:09:50.346 --> 00:09:51.926 A:middle
以及需要多少 CPU 性能

00:09:52.006 --> 00:09:53.626 A:middle
来赶上你 App

00:09:53.626 --> 00:09:55.596 A:middle
历史需求的截止时间

00:09:56.486 --> 00:09:58.136 A:middle
经过这个改变

00:09:58.716 --> 00:10:00.346 A:middle
当加载开始

