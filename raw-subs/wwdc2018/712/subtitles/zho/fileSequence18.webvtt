WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:01.096 --> 00:18:02.866 A:middle
接下来 让我们测试一下

00:18:02.866 --> 00:18:05.000 A:middle
这个模型的预测效果

00:18:11.046 --> 00:18:13.096 A:middle
所以我会开始一个新节

00:18:13.166 --> 00:18:13.676 A:middle
叫做 Inspect predictions

00:18:14.056 --> 00:18:15.506 A:middle
然后加载一个

00:18:15.716 --> 00:18:17.436 A:middle
测试数据集

00:18:18.026 --> 00:18:19.496 A:middle
在这里我已经准备好了

00:18:19.496 --> 00:18:20.676 A:middle
一个 SFrame 格式的数据

00:18:20.676 --> 00:18:21.716 A:middle
所以我只是要加载它 

00:18:22.436 --> 00:18:23.266 A:middle
文件名为

00:18:23.266 --> 00:18:25.046 A:middle
test-breakfast-data.sframe

00:18:25.666 --> 00:18:26.606 A:middle
这个测试 SFrame

00:18:26.606 --> 00:18:28.756 A:middle
有两个重要的属性

00:18:29.146 --> 00:18:31.126 A:middle
一个是它包含的图像类型

00:18:31.126 --> 00:18:33.256 A:middle
该模型受训的图像类型

00:18:33.366 --> 00:18:34.316 A:middle
完全一样

00:18:34.656 --> 00:18:36.216 A:middle
但第二个属性是

00:18:36.216 --> 00:18:37.756 A:middle
该模型从未见过

00:18:37.756 --> 00:18:39.266 A:middle
这些测试图片

00:18:39.556 --> 00:18:41.136 A:middle
所以这是一个很好的测试

00:18:41.136 --> 00:18:42.126 A:middle
可以检测该模型能否

00:18:42.126 --> 00:18:44.176 A:middle
推广到用户的真实数据

00:18:44.756 --> 00:18:48.466 A:middle
我会调用 model.predict

00:18:48.566 --> 00:18:50.176 A:middle
并传入测试 SFrame

00:18:50.176 --> 00:18:52.016 A:middle
从而对整个测试集

00:18:52.016 --> 00:18:54.196 A:middle
做预测

00:18:54.396 --> 00:18:56.546 A:middle
我们会得到整个

00:18:57.096 --> 00:19:00.656 A:middle
SFframe 的批量预测结果

