WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.766 --> 00:15:01.126 A:middle
有一个循环

00:15:01.616 --> 00:15:04.906 A:middle
然后这个循环指数 j 在每次迭代中

00:15:05.046 --> 00:15:06.646 A:middle
会从前向后移动一位

00:15:07.696 --> 00:15:09.196 A:middle
所以 可以肯定的是

00:15:09.196 --> 00:15:10.716 A:middle
j 只对元素进行了一次传递

00:15:11.116 --> 00:15:14.086 A:middle
你几乎可以从这里看到

00:15:14.086 --> 00:15:20.306 A:middle
量级和复杂度

00:15:20.516 --> 00:15:22.106 A:middle
最后 由于该方法

00:15:22.106 --> 00:15:23.526 A:middle
需要重新排列元素

00:15:23.526 --> 00:15:24.726 A:middle
但不更改

00:15:24.726 --> 00:15:26.396 A:middle
集合的长度或结构 

00:15:26.396 --> 00:15:27.506 A:middle
因此它只依赖于对

00:15:27.506 --> 00:15:28.606 A:middle
MutableCollection 的遵循

00:15:29.146 --> 00:15:32.676 A:middle
所以 这就是我学到的第一堂课

00:15:33.686 --> 00:15:34.966 A:middle
熟悉 Swift

00:15:34.966 --> 00:15:36.166 A:middle
标准库中的内容

00:15:37.176 --> 00:15:38.606 A:middle
它包含一组

00:15:38.606 --> 00:15:40.416 A:middle
提供文档描述

00:15:40.416 --> 00:15:42.316 A:middle
和性能特征的算法

00:15:43.406 --> 00:15:45.526 A:middle
虽然我们看了一点执行过程

00:15:45.526 --> 00:15:47.416 A:middle
你也可以从中学到很多东西

00:15:47.416 --> 00:15:49.126 A:middle
但由于它是设计好的

00:15:49.156 --> 00:15:50.946 A:middle
所以你不必用我之前的笨方法

00:15:52.426 --> 00:15:53.756 A:middle
官方文档会告诉你

00:15:53.756 --> 00:15:55.046 A:middle
需要知道的一切

00:15:55.046 --> 00:15:58.006 A:middle
以便有效地使用该库

00:15:58.996 --> 00:16:00.126 A:middle
你甚至可以在那找到

