WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:59.396 --> 00:12:00.826 A:middle
然后 这个橙色线是

00:12:00.826 --> 00:12:02.076 A:middle
n 的二次方的形状

00:12:03.356 --> 00:12:04.846 A:middle
正如你所见

00:12:04.846 --> 00:12:06.406 A:middle
线性算法也许在小型问题中

00:12:06.406 --> 00:12:07.956 A:middle
表现稍差

00:12:07.956 --> 00:12:09.596 A:middle
但他最终比

00:12:09.596 --> 00:12:10.606 A:middle
二次方算法运行更快

00:12:11.926 --> 00:12:13.716 A:middle
很棒的是

00:12:13.716 --> 00:12:15.546 A:middle
不管你用线性算法

00:12:15.546 --> 00:12:16.856 A:middle
的成本有多高

00:12:16.856 --> 00:12:19.226 A:middle
如果你继续放更大的问题尺寸

00:12:19.226 --> 00:12:22.456 A:middle
你总是会找到

00:12:22.566 --> 00:12:24.736 A:middle
一个线性算法会赢

00:12:24.736 --> 00:12:27.206 A:middle
并且在后面

00:12:27.206 --> 00:12:28.206 A:middle
一直赢的点

00:12:29.346 --> 00:12:30.506 A:middle
所以 我们正在讨论的是

00:12:30.506 --> 00:12:33.000 A:middle
延展性 而不是绝对的性能

00:12:36.436 --> 00:12:40.346 A:middle
好了 我的延展性问题终于解决了

00:12:40.346 --> 00:12:42.316 A:middle
但我真的很想看看

00:12:42.316 --> 00:12:44.196 A:middle
标准程序库如何改进

00:12:44.196 --> 00:12:46.616 A:middle
我倒着来的删除方法

00:12:47.886 --> 00:12:49.586 A:middle
Crusty 提醒我说

00:12:49.586 --> 00:12:50.986 A:middle
Swift 是开放源码 所以我可以把它

00:12:50.986 --> 00:12:53.426 A:middle
放在他口中的“嬉皮士网”上

00:12:53.816 --> 00:12:55.500 A:middle
也就是我们其他人所知的 GitHub

00:12:59.266 --> 00:13:00.776 A:middle
现在 我注意到的第一件事

