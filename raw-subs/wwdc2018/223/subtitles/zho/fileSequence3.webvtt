WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:58.656 --> 00:03:02.316 A:middle
我们从 0 开始循环计数

00:03:02.316 --> 00:03:03.326 A:middle
当我们发现要删除的东西

00:03:03.326 --> 00:03:05.126 A:middle
我们就调用 remove(at: )方法

00:03:05.126 --> 00:03:07.546 A:middle
然后我们就可以继续循环

00:03:07.546 --> 00:03:11.846 A:middle
直到 哦 溢出了

00:03:13.366 --> 00:03:14.906 A:middle
数组会变短

00:03:14.906 --> 00:03:16.256 A:middle
但是当循环开始时

00:03:16.256 --> 00:03:17.166 A:middle
我们选择了固定的迭代次数

00:03:17.876 --> 00:03:19.196 A:middle
幸运的是 如果你使用 Swift 

00:03:19.246 --> 00:03:20.796 A:middle
并测试你的代码 你不可能遗漏这个 Bug

00:03:20.826 --> 00:03:23.436 A:middle
因为程序会产生内中断

00:03:23.946 --> 00:03:25.226 A:middle
但如果你像我一样

00:03:25.266 --> 00:03:26.996 A:middle
是 C 语言出身的程序员

00:03:26.996 --> 00:03:28.966 A:middle
面对这种问题 你可能没那么幸运

00:03:29.926 --> 00:03:30.256 A:middle
好的

00:03:30.626 --> 00:03:32.796 A:middle
我们可以通过将 for 循环替换为

00:03:32.796 --> 00:03:34.096 A:middle
更难看的 while 循环

00:03:34.096 --> 00:03:36.346 A:middle
来修复它 

00:03:36.346 --> 00:03:37.516 A:middle
这可以使我们在每一次迭代中

00:03:37.516 --> 00:03:38.096 A:middle
检查计数

00:03:38.646 --> 00:03:42.736 A:middle
但这里也有一个细微的 Bug

00:03:43.956 --> 00:03:46.056 A:middle
如果两个连续的元素被选中

00:03:46.056 --> 00:03:48.706 A:middle
它将会删除第一个

00:03:48.706 --> 00:03:51.916 A:middle
并且立即

00:03:51.916 --> 00:03:54.256 A:middle
跳过下一个

00:03:54.466 --> 00:03:56.956 A:middle
这个 Bug 更加的阴险

00:03:56.956 --> 00:03:58.496 A:middle
因为它隐藏了起来

00:03:58.496 --> 00:04:00.286 A:middle
除非你的测试碰巧

