WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:58.646 --> 00:36:00.026 A:middle
这也是它存在的原因

00:36:00.026 --> 00:36:01.156 A:middle
这样的情况

00:36:01.156 --> 00:36:02.586 A:middle
以及一些其他的例子

00:36:02.586 --> 00:36:03.776 A:middle
都在 UIView 子集中

00:36:04.346 --> 00:36:05.786 A:middle
但是大部分情况下它被

00:36:05.786 --> 00:36:07.026 A:middle
覆写的原因是

00:36:07.026 --> 00:36:07.986 A:middle
人们认为这样会

00:36:07.986 --> 00:36:10.136 A:middle
更快或者更准确

00:36:10.136 --> 00:36:10.946 A:middle
但事实上都不会

00:36:12.076 --> 00:36:14.546 A:middle
但是 有一种情况下

00:36:14.546 --> 00:36:16.506 A:middle
覆写它会提高你的性能

00:36:18.206 --> 00:36:19.926 A:middle
因为文本测量可能消耗较高

00:36:21.186 --> 00:36:24.106 A:middle
在我们的这个 App 中 UILabel 尺寸计算

00:36:24.106 --> 00:36:25.626 A:middle
并没有花费很久

00:36:25.716 --> 00:36:27.386 A:middle
它的时间是很短的

00:36:27.826 --> 00:36:28.986 A:middle
因此 纠结这个问题

00:36:28.986 --> 00:36:29.766 A:middle
并不会提升

00:36:29.766 --> 00:36:31.096 A:middle
太多的性能

00:36:31.666 --> 00:36:32.956 A:middle
但如果你有一个文本密集型的

00:36:32.956 --> 00:36:34.586 A:middle
App 而你多次看到

00:36:34.586 --> 00:36:36.106 A:middle
在 UILabel 中发生

00:36:36.106 --> 00:36:37.886 A:middle
文本测量 或者你

00:36:37.886 --> 00:36:38.936 A:middle
在文本视图中有文本测量过程

00:36:39.066 --> 00:36:39.956 A:middle
或者其他功能中有文本测量

00:36:40.386 --> 00:36:42.136 A:middle
你或许能够通过这种方式

00:36:42.136 --> 00:36:43.566 A:middle
借助其他信息 提高性能

00:36:45.116 --> 00:36:46.296 A:middle
如果你知道

00:36:46.296 --> 00:36:47.886 A:middle
该文本所需要的尺寸

00:36:47.886 --> 00:36:49.696 A:middle
而无需完成文本测量

00:36:49.696 --> 00:36:50.746 A:middle
你可以返回该尺寸

00:36:50.746 --> 00:36:53.916 A:middle
和固有内容尺寸 或者是

00:36:53.916 --> 00:36:55.286 A:middle
在准备将

00:36:55.286 --> 00:36:56.726 A:middle
视图显示在屏幕时

00:36:56.726 --> 00:36:57.546 A:middle
完全使用约束

00:36:57.546 --> 00:36:58.706 A:middle
定义该尺寸

00:36:58.776 --> 00:36:59.976 A:middle
无论其中的文本

