WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:59.236 --> 00:06:00.296 A:middle
最后我们调用

00:06:00.296 --> 00:06:02.356 A:middle
super.updateConstraints 

00:06:02.356 --> 00:06:04.256 A:middle
这很重要 因为这个方法

00:06:04.586 --> 00:06:08.976 A:middle
对 UIView 层面的执行很有用

00:06:09.166 --> 00:06:10.966 A:middle
好的 这就是基本的结构 

00:06:11.436 --> 00:06:15.306 A:middle
表明了它的目的 并且确实可用有效果

00:06:15.906 --> 00:06:18.676 A:middle
但是我们接下来

00:06:18.676 --> 00:06:20.136 A:middle
进一步探讨它的运行过程 

00:06:20.136 --> 00:06:21.276 A:middle
让我们更好地了解其性能

00:06:22.016 --> 00:06:23.116 A:middle
那么首先要了解的

00:06:23.116 --> 00:06:24.736 A:middle
就是到底什么是

00:06:24.856 --> 00:06:26.906 A:middle
updateConstraints 即我们正在覆写的方法

00:06:28.316 --> 00:06:30.646 A:middle
它属于渲染循环

00:06:31.636 --> 00:06:33.266 A:middle
渲染循环是一个过程

00:06:33.506 --> 00:06:36.476 A:middle
它每秒钟可用运行高达 120 次

00:06:37.216 --> 00:06:38.976 A:middle
从而确保所有内容

00:06:38.976 --> 00:06:40.656 A:middle
出现在每一帧上

00:06:41.656 --> 00:06:43.786 A:middle
好的 它包含 3 个阶段

00:06:43.786 --> 00:06:45.066 A:middle
分别是更新约束

00:06:45.066 --> 00:06:46.386 A:middle
布局与显示

00:06:47.096 --> 00:06:49.246 A:middle
首先所有需要的视图都会

00:06:49.246 --> 00:06:50.916 A:middle
收到 updateConstraints

00:06:51.306 --> 00:06:53.306 A:middle
然后从最末端的

00:06:53.306 --> 00:06:55.096 A:middle
视图开始 沿着视图层级向上运行

00:06:55.096 --> 00:06:55.786 A:middle
最终到达窗口

00:06:56.656 --> 00:06:59.086 A:middle
接着 每个视图会收到 layoutSubView

00:06:59.366 --> 00:07:00.616 A:middle
它沿着相反方向运行

