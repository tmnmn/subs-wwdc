WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:58.051 --> 00:27:02.589 align:middle line:-2
总之 我们对每个对象
减少了半数以上的位数

00:27:04.658 --> 00:27:06.793 align:middle line:-1
现在即使我们压缩了位数

00:27:07.761 --> 00:27:10.330 align:middle line:-1
属性列表仍然有大量的超额负载

00:27:10.397 --> 00:27:11.865 align:middle line:-1
对于它的元数据而言

00:27:12.633 --> 00:27:13.834 align:middle line:-1
按名称发送每一个字段

00:27:14.801 --> 00:27:18.238 align:middle line:-2
我们说过那是无缘无故的
我们都知道这些对象是什么

00:27:18.572 --> 00:27:19.940 align:middle line:-1
这不是我们需要的信息

00:27:20.707 --> 00:27:25.746 align:middle line:-1
为此我们实施了一个新的序列化策略

00:27:26.146 --> 00:27:27.181 align:middle line:-1
称之为BitStream

00:27:28.382 --> 00:27:30.417 align:middle line:-2
BitStream
用于把信息打包到

00:27:30.484 --> 00:27:31.952 align:middle line:-1
尽可能少的字节中

00:27:32.319 --> 00:27:35.022 align:middle line:-1
同时提供快速的序列化和反序列化

00:27:35.856 --> 00:27:37.925 align:middle line:-1
现在我们的实施是为特定目的创建的

00:27:37.991 --> 00:27:39.560 align:middle line:-1
用于传递二进制数据

00:27:40.093 --> 00:27:42.162 align:middle line:-1
以低延迟 在一个类似这样的app中

00:27:42.896 --> 00:27:47.568 align:middle line:-2
这样的策略对于需要持久的数据来说
效果不会太好

00:27:48.001 --> 00:27:50.270 align:middle line:-1
或者是你需要追踪架构

00:27:50.337 --> 00:27:51.772 align:middle line:-1
并随时间观察它的变化的数据

00:27:52.439 --> 00:27:55.676 align:middle line:-2
但对于类似这样的短暂的app来说
用它正合适

00:27:58.178 --> 00:28:01.114 align:middle line:-1
要实施它 我们创建了两个协议

