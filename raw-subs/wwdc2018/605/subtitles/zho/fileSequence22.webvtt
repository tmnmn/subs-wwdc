WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:58.919 --> 00:22:01.822 align:middle line:-2
你所要做的就是把那个结构
标记为可编码

00:22:01.889 --> 00:22:03.624 align:middle line:-2
然后Swift编译器
会替你做剩下的事

00:22:04.057 --> 00:22:06.426 align:middle line:-1
创建全部基础结构用于序列化

00:22:07.995 --> 00:22:09.863 align:middle line:0
Swift并不会针对枚举这样做

00:22:09.930 --> 00:22:12.132 align:middle line:0
因此我们得自己来实施

00:22:12.466 --> 00:22:16.436 align:middle line:0
实施初始化和编码方法

00:22:16.503 --> 00:22:18.805 align:middle line:0
从可编码协议中

00:22:20.908 --> 00:22:22.709 align:middle line:-1
然后序列化就非常简单了

00:22:22.776 --> 00:22:26.280 align:middle line:-2
只需要创建一个属性列表编码器
并让它编码对象

00:22:27.314 --> 00:22:30.984 align:middle line:-2
然后我们可以在多点连通性会话内
发送一个数据包

00:22:32.486 --> 00:22:34.188 align:middle line:-1
现在这里有一个合乎情理的提问

00:22:34.254 --> 00:22:37.224 align:middle line:-1
它对尺寸和性能会有什么影响？

00:22:38.592 --> 00:22:42.663 align:middle line:-2
二进制属性列表非常紧凑
并且编码器的速度也非常快

00:22:43.664 --> 00:22:44.998 align:middle line:-1
但有时候 你知道的

00:22:45.332 --> 00:22:49.269 align:middle line:-2
温和的实施在许多方面
都针对开发者时间进行了优化

00:22:49.336 --> 00:22:51.805 align:middle line:-1
有时候是你在对象上的最宝贵的资源

00:22:54.074 --> 00:22:55.776 align:middle line:-1
现在我们遇到了一些限制

00:22:55.843 --> 00:22:59.179 align:middle line:-2
当我们开始创建下一个功能时
我们要谈谈该如何克服这个问题

