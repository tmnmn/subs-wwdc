WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:58.166 --> 00:37:00.256 A:middle
让我们以一个

00:37:00.406 --> 00:37:01.766 A:middle
非常有趣的例子

00:37:01.766 --> 00:37:03.336 A:middle
来介绍如何使用建模器

00:37:03.606 --> 00:37:05.966 A:middle
假设你定义了一个 Schema

00:37:06.106 --> 00:37:07.906 A:middle
叫做 playing-with-matches

00:37:08.006 --> 00:37:10.166 A:middle
它是一个

00:37:10.166 --> 00:37:12.666 A:middle
os-signpost-interval-schema

00:37:12.876 --> 00:37:14.156 A:middle
可以使已经定义的 os_signpost

00:37:14.156 --> 00:37:15.036 A:middle
在你的代码中

00:37:15.036 --> 00:37:17.226 A:middle
做一些危险的操作

00:37:17.726 --> 00:37:19.996 A:middle
我们又定义了另一个 Schema

00:37:20.156 --> 00:37:21.766 A:middle
叫做 app-on-fire

00:37:22.186 --> 00:37:23.916 A:middle
它也是一个 signpost Schema

00:37:24.066 --> 00:37:25.206 A:middle
但是这些 signpost 意味着

00:37:25.206 --> 00:37:27.386 A:middle
App 进入了一个糟糕的状态

00:37:27.386 --> 00:37:29.396 A:middle
我们真的很想知道原因

00:37:30.406 --> 00:37:31.816 A:middle
还要创建一个输出 Schema

00:37:31.816 --> 00:37:33.306 A:middle
它是一个 point-schema

00:37:33.306 --> 00:37:35.836 A:middle
它会保存 playing-with-matches 的对象

00:37:35.836 --> 00:37:37.476 A:middle
以及对象“起火”的时间

00:37:37.956 --> 00:37:38.676 A:middle
我们打算将它

00:37:38.676 --> 00:37:39.796 A:middle
命名为 started-a-fire

00:37:39.796 --> 00:37:44.066 A:middle
建模器看起来是这样的

00:37:44.226 --> 00:37:46.686 A:middle
所有的输入

00:37:46.686 --> 00:37:48.486 A:middle
都按时间顺序设置好了

00:37:48.486 --> 00:37:51.096 A:middle
左边的虚线就是

00:37:51.096 --> 00:37:53.126 A:middle
所谓的建模器时钟

00:37:54.136 --> 00:37:55.976 A:middle
当我们获取第一个输入

00:37:55.976 --> 00:37:57.206 A:middle
将其置入到工作内存中时

00:37:57.206 --> 00:37:58.636 A:middle
建模器时钟

00:37:58.686 --> 00:37:59.686 A:middle
将移动到区间的起始处

00:37:59.686 --> 00:38:03.076 A:middle
然后我们获取下一个输入

