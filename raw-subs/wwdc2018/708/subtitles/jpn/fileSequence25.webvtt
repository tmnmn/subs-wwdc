WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:57.431 --> 00:25:01.201 align:start position:23% line:-2
CPU上では有能な計算ができる
Accelerateを使います

00:25:01.301 --> 00:25:05.806 align:start position:21% line:-2
モデル デバイスの状態などを考え
異なる計算を―

00:25:05.906 --> 00:25:09.510 align:start position:25% line:-1
異なるハードウェアに送ります

00:25:11.178 --> 00:25:14.281 align:start position:30% line:-2
さらにネットワーク内の
レイヤを融合し

00:25:14.381 --> 00:25:17.451 align:start position:27% line:-1
必要な計算を少なく抑えます

00:25:18.786 --> 00:25:22.089 align:start position:21% line:-1
状況を理解して最適化をするのです

00:25:22.189 --> 00:25:26.693 align:start position:16% line:-2
モデルの詳細は
MLModelのファイルに入っています

00:25:27.060 --> 00:25:31.432 align:start position:23% line:-2
推論エンジンとデバイスの詳細も
分かっています

00:25:32.299 --> 00:25:35.302 align:start position:27% line:-1
我々が必ず最適化をするので

00:25:35.402 --> 00:25:38.972 align:start position:32% line:-2
皆さんはユーザだけに
集中してください

00:25:40.340 --> 00:25:42.376 align:start position:29% line:-1
作業負荷はどうでしょう？

00:25:42.476 --> 00:25:46.513 align:start position:30% line:-2
複数の予測を
行う必要がある場合は？

00:25:47.214 --> 00:25:50.851 align:start position:23% line:-2
情報がないと
Core MLは最適化しません

00:25:51.452 --> 00:25:57.157 align:start position:27% line:-2
同じ作業量をこなすには
次のようなことが必要でした

00:25:57.257 --> 00:26:01.662 align:start position:21% line:-2
既存のCore ML予測APIに
“for”でループを配置

