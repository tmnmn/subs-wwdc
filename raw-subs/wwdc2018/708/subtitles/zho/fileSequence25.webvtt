WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:57.431 --> 00:25:00.767 align:middle line:-2
在CPU上 我们可以使用
Accelerate进行有效计算

00:25:01.301 --> 00:25:03.637 align:middle line:-2
并且我们可以进行调度
以将计算的不同部分

00:25:03.704 --> 00:25:07.074 align:middle line:-1
根据模型 设备状态和其它因素

00:25:07.140 --> 00:25:09.176 align:middle line:-1
动态地分配给不同的硬件

00:25:11.144 --> 00:25:14.281 align:middle line:-2
我们也可以找到
融合网络中的层的机会

00:25:14.348 --> 00:25:17.284 align:middle line:-1
这会减少所需的整体计算

00:25:18.785 --> 00:25:22.122 align:middle line:-2
我们能够在这里进行优化
因为我们知道发生了什么

00:25:22.189 --> 00:25:23.824 align:middle line:-1
我们知道模型的细节

00:25:23.891 --> 00:25:26.760 align:middle line:-2
它们包含在你提供给我们的
MLModel文件中

00:25:26.827 --> 00:25:30.063 align:middle line:-1
我们知道推理引擎和设备的细节

00:25:30.130 --> 00:25:31.231 align:middle line:-1
因为我们设计了它们

00:25:32.299 --> 00:25:35.369 align:middle line:-1
我们可以为你处理所有这些优化

00:25:35.435 --> 00:25:38.872 align:middle line:-2
以使你可以专注于
在你的app中提供最佳的用户体验

00:25:40.274 --> 00:25:41.708 align:middle line:-1
但是你的工作载荷呢？

00:25:42.409 --> 00:25:46.313 align:middle line:-2
特别是 如果你需要进行多重预测
那该怎么办呢？

00:25:47.147 --> 00:25:50.684 align:middle line:-2
如果Core ML不知道它
Core ML就无法对其进行优化

00:25:51.485 --> 00:25:54.288 align:middle line:-2
因此在过去
如果你有这样的工作载荷

00:25:55.455 --> 00:25:57.157 align:middle line:-1
你需要做这样的事情：

00:25:57.224 --> 00:26:01.562 align:middle line:-2
一个简单的for循环 环绕着
对现有Core ML的prediction API的调用

