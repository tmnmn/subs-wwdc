WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.586 --> 00:22:01.722 align:middle line:-1
你可以定义一个最小的宽度和高度

00:22:01.788 --> 00:22:03.156 align:middle line:-1
以及一个最大的宽度和高度

00:22:03.590 --> 00:22:06.193 align:middle line:-2
然后在推理过程中
使用两者之间的任何值

00:22:07.094 --> 00:22:08.295 align:middle line:-1
但也有另一种方法

00:22:08.562 --> 00:22:11.365 align:middle line:-1
你可以枚举你要使用的所有形状

00:22:11.732 --> 00:22:13.934 align:middle line:-1
例如 所有不同的宽高比

00:22:14.001 --> 00:22:17.304 align:middle line:-2
所有不同的分辨率
这样做的性能会更好

00:22:17.704 --> 00:22:20.174 align:middle line:-1
Core ML更早地了解你的用例

00:22:20.541 --> 00:22:24.111 align:middle line:-1
因此它有机会进行更多的优化

00:22:24.978 --> 00:22:27.814 align:middle line:-1
这也为你的app提供了更小的测试面

00:22:29.249 --> 00:22:30.884 align:middle line:-1
那哪些模型是弹性的呢？

00:22:30.951 --> 00:22:34.655 align:middle line:-2
哪些模型能被训练
以支持多种分辨率呢？

00:22:36.223 --> 00:22:40.827 align:middle line:-2
完全卷积神经网络
通常用于图像处理任务

00:22:40.894 --> 00:22:45.499 align:middle line:-2
如风格转换 图像增强
超分辨率等等

00:22:45.999 --> 00:22:47.935 align:middle line:-1
它还被用来实现一些对象检测架构

00:22:48.402 --> 00:22:52.806 align:middle line:-2
Core ML工具可以替
你检查模型是否具备此功能

00:22:54.208 --> 00:22:57.778 align:middle line:-2
我们看到了如何使用弹性大小
来减少模型的数量

00:22:57.845 --> 00:23:00.380 align:middle line:-1
以及权重的大小可以通过量化来缩小

