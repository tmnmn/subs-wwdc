WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.976 --> 00:29:01.566 A:middle
SQLite 不能用它

00:29:01.566 --> 00:29:02.006 A:middle
来进行排序

00:29:02.556 --> 00:29:04.776 A:middle
我们在这里选择的优化

00:29:04.776 --> 00:29:07.216 A:middle
是使用复合索引

00:29:07.216 --> 00:29:08.636 A:middle
首先过滤掉更小的对象组

00:29:08.636 --> 00:29:11.676 A:middle
然后用内存中的 B 树

00:29:11.676 --> 00:29:13.736 A:middle
来进行排序

00:29:14.336 --> 00:29:18.536 A:middle
就像各位看到的

00:29:18.536 --> 00:29:20.186 A:middle
这个索引将我们的读取性能

00:29:20.186 --> 00:29:22.286 A:middle
提高了 25%

00:29:23.986 --> 00:29:25.256 A:middle
这种情况下

00:29:25.256 --> 00:29:27.066 A:middle
性能测试是运行大概 100,000 行

00:29:27.066 --> 00:29:29.726 A:middle
我们看到

00:29:29.726 --> 00:29:31.616 A:middle
仅对于读取函数而言

00:29:31.616 --> 00:29:33.036 A:middle
就有了 130 毫秒的提高

00:29:34.476 --> 00:29:35.876 A:middle
这就引出了我的下一个话题

00:29:36.196 --> 00:29:37.466 A:middle
核心数据的测试

00:29:38.646 --> 00:29:40.716 A:middle
正如各位所知

00:29:40.716 --> 00:29:41.086 A:middle
我们非常喜欢测试

00:29:41.656 --> 00:29:42.476 A:middle
测试很棒

00:29:43.026 --> 00:29:45.156 A:middle
在核心数据里

00:29:45.156 --> 00:29:46.686 A:middle
我们在内部既使用它们检测正确性

00:29:46.686 --> 00:29:48.476 A:middle
又使用它们学习

00:29:48.906 --> 00:29:49.826 A:middle
核心数据的功能

00:29:49.826 --> 00:29:51.026 A:middle
以及 API 

00:29:51.026 --> 00:29:54.406 A:middle
在给定的条件下的行为

00:29:55.316 --> 00:29:56.326 A:middle
同时也能很好地

00:29:56.326 --> 00:29:58.876 A:middle
验证你关于核心数据的工作

00:29:58.986 --> 00:30:00.806 A:middle
以及它将如何在你的 App 中

