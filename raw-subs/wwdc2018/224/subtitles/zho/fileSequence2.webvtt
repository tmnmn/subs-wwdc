WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.216 --> 00:02:01.006 A:middle
存储器

00:02:01.006 --> 00:02:02.606 A:middle
能够理解的托管项目模型

00:02:03.616 --> 00:02:04.276 A:middle
所有东西都需要字段

00:02:04.276 --> 00:02:05.816 A:middle
比如图片的属性 

00:02:05.816 --> 00:02:07.406 A:middle
比如图像数据

00:02:07.406 --> 00:02:08.606 A:middle
和发布时间

00:02:09.076 --> 00:02:11.266 A:middle
此外我们还需要

00:02:11.266 --> 00:02:12.236 A:middle
贴文和评论间的关系

00:02:12.596 --> 00:02:14.066 A:middle
我们已经定义了

00:02:14.066 --> 00:02:15.446 A:middle
存储器的需求

00:02:15.446 --> 00:02:17.366 A:middle
但是随着时间的推移

00:02:17.366 --> 00:02:18.156 A:middle
数据的维护涉及到很多工作

00:02:19.056 --> 00:02:20.386 A:middle
幸运的是核心数据提供了一个

00:02:20.386 --> 00:02:21.956 A:middle
持久化存储协调器

00:02:21.956 --> 00:02:22.546 A:middle
来进行管理

00:02:22.986 --> 00:02:24.836 A:middle
这个协调器可以处理例如

00:02:24.836 --> 00:02:26.246 A:middle
与存储器的模型版本

00:02:26.246 --> 00:02:27.806 A:middle
对比 App 模型

00:02:27.806 --> 00:02:29.276 A:middle
并随着 App 的优化

00:02:29.276 --> 00:02:30.306 A:middle
进行自动迁移

00:02:30.786 --> 00:02:32.916 A:middle
最终托管对象上下文 会对我们的数据

00:02:32.916 --> 00:02:34.436 A:middle
提供安全快捷

00:02:34.436 --> 00:02:35.936 A:middle
且可预测的访问权限

00:02:36.616 --> 00:02:37.826 A:middle
即便我们

00:02:37.826 --> 00:02:39.426 A:middle
同时使用很多功能

00:02:39.426 --> 00:02:40.636 A:middle
例如查询生成

00:02:40.716 --> 00:02:41.896 A:middle
连接池以及

00:02:41.896 --> 00:02:42.376 A:middle
历史跟踪

00:02:44.236 --> 00:02:46.486 A:middle
设置这些要求

00:02:46.566 --> 00:02:47.736 A:middle
找到模型 进行加载

00:02:47.736 --> 00:02:49.236 A:middle
然后决定如何保存存储器

00:02:49.236 --> 00:02:51.186 A:middle
但是很多错误路径

00:02:51.186 --> 00:02:53.026 A:middle
在你迁移 App 之后

00:02:53.026 --> 00:02:54.816 A:middle
并不会失败

00:02:54.816 --> 00:02:56.246 A:middle
因此核心数据提供了一个容器类型

00:02:56.576 --> 00:02:57.716 A:middle
能极大的降低

00:02:57.716 --> 00:02:58.946 A:middle
你在设置堆栈时所需的样板文件

00:02:58.946 --> 00:03:00.736 A:middle
只需要按名称引用模型

