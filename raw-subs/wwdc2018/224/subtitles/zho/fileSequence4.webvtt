WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:00.206 --> 00:04:01.506 A:middle
如何修复呢

00:04:02.666 --> 00:04:03.926 A:middle
我们可以自己

00:04:03.926 --> 00:04:05.206 A:middle
在框架束外恢复这个模型

00:04:05.206 --> 00:04:06.766 A:middle
然后使用

00:04:06.766 --> 00:04:07.456 A:middle
容器的其他初始化 App

00:04:07.456 --> 00:04:08.666 A:middle
比如那个使用

00:04:08.736 --> 00:04:10.606 A:middle
显式托管对象模型的 App

00:04:10.606 --> 00:04:12.986 A:middle
但是事实上 NSPersistentContainer

00:04:12.986 --> 00:04:14.486 A:middle
提供了一种更改

00:04:14.486 --> 00:04:16.036 A:middle
检索对象的方法

00:04:17.856 --> 00:04:19.856 A:middle
看 NSPersistentContainer 知道

00:04:19.856 --> 00:04:21.086 A:middle
它什么时候子类化

00:04:21.086 --> 00:04:24.106 A:middle
然后在搜索模型时 将子类类型

00:04:24.106 --> 00:04:24.666 A:middle
作为提示

00:04:25.156 --> 00:04:26.256 A:middle
我们所要做的就是

00:04:26.256 --> 00:04:27.566 A:middle
利用这个功能

00:04:27.566 --> 00:04:28.236 A:middle
创建一个子类

00:04:28.756 --> 00:04:29.826 A:middle
里面甚至可以

00:04:29.826 --> 00:04:30.466 A:middle
什么都没有

00:04:31.916 --> 00:04:33.976 A:middle
然后 任何通过容器设置

00:04:33.976 --> 00:04:35.816 A:middle
并希望使用我们的模型的代码 

00:04:35.816 --> 00:04:37.466 A:middle
可以采用那个子类

00:04:37.466 --> 00:04:38.646 A:middle
然后持久化容器将

00:04:38.646 --> 00:04:40.586 A:middle
替代它在框架束中检索模型

00:04:41.196 --> 00:04:45.856 A:middle
这很有趣 但是因为我们需要努力

00:04:45.856 --> 00:04:47.286 A:middle
分解我们 App 的资源

00:04:47.436 --> 00:04:48.486 A:middle
如果我们能提升

00:04:48.486 --> 00:04:49.696 A:middle
我们磁盘上数据的组织

00:04:49.696 --> 00:04:50.426 A:middle
不是更好吗

00:04:51.146 --> 00:04:53.306 A:middle
在默认情况下 

00:04:53.306 --> 00:04:54.276 A:middle
新的持久化容器 

00:04:54.276 --> 00:04:55.986 A:middle
带有一个 SQLite 存储的存储描述

00:04:56.116 --> 00:04:58.136 A:middle
它的自动迁移功能在

00:04:58.136 --> 00:04:59.926 A:middle
iOS 系统中存在我们的 App 的

00:04:59.926 --> 00:05:00.366 A:middle
文件目录里

