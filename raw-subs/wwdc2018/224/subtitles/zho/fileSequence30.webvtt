WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:58.986 --> 00:30:00.806 A:middle
以及它将如何在你的 App 中

00:30:00.806 --> 00:30:02.916 A:middle
帮助你的顾客获得

00:30:02.916 --> 00:30:03.716 A:middle
更好的体验

00:30:04.266 --> 00:30:05.316 A:middle
就像各位在前一个例子中看到的

00:30:05.316 --> 00:30:06.916 A:middle
我们能够验证

00:30:06.916 --> 00:30:08.966 A:middle
R 树索引可以

00:30:08.966 --> 00:30:10.456 A:middle
优化性能

00:30:10.456 --> 00:30:11.466 A:middle
虽然它使用的是内存里的

00:30:11.466 --> 00:30:12.186 A:middle
B 树排序

00:30:14.276 --> 00:30:16.136 A:middle
但同样能捕捉到你的产品需求

00:30:16.136 --> 00:30:17.686 A:middle
在核心数据里

00:30:17.686 --> 00:30:19.456 A:middle
这对我们十分重要

00:30:19.456 --> 00:30:20.896 A:middle
因为它能帮助我们

00:30:20.896 --> 00:30:22.296 A:middle
与你的期望沟通

00:30:22.786 --> 00:30:24.026 A:middle
通过测试

00:30:24.026 --> 00:30:25.566 A:middle
我们可以看到你在用代码做什么

00:30:25.566 --> 00:30:27.296 A:middle
以及你希望这些代码

00:30:27.296 --> 00:30:28.546 A:middle
如何服务你的顾客

00:30:29.686 --> 00:30:30.816 A:middle
你可以设置一些重要的东西

00:30:30.816 --> 00:30:31.976 A:middle
使你的工作更容易一些

00:30:31.976 --> 00:30:36.196 A:middle
比如 能够生成持久化容器的

00:30:36.196 --> 00:30:37.236 A:middle
基础类别

00:30:38.406 --> 00:30:39.926 A:middle
屏幕上的基础类别

00:30:39.926 --> 00:30:41.856 A:middle
为持久化存储使用了

00:30:41.856 --> 00:30:43.426 A:middle
/dev/null 的文件 URL

00:30:43.426 --> 00:30:45.316 A:middle
这是一种很好的测试方式

00:30:45.316 --> 00:30:48.506 A:middle
它对一小部分的托管对象起作用

00:30:48.506 --> 00:30:50.446 A:middle
且运行十分迅速

00:30:50.446 --> 00:30:52.076 A:middle
因为它们将在整个内存里运行

00:30:52.776 --> 00:30:54.726 A:middle
当你这样做时

00:30:54.726 --> 00:30:56.306 A:middle
SQLite 实现了一个内存中的存储

00:30:56.306 --> 00:30:57.866 A:middle
非常高效

00:30:57.866 --> 00:30:59.596 A:middle
但是因为是在内存里

00:30:59.596 --> 00:31:00.756 A:middle
如果你有很多数据

