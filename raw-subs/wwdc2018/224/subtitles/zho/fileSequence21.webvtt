WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.436 --> 00:21:02.826 A:middle
标记喜欢或不喜欢

00:21:03.596 --> 00:21:05.376 A:middle
通过一行代码

00:21:05.376 --> 00:21:07.046 A:middle
我们可以使用分批删除

00:21:07.046 --> 00:21:09.706 A:middle
将记录从数据库里清除

00:21:09.976 --> 00:21:12.256 A:middle
这种行为规模

00:21:12.256 --> 00:21:14.716 A:middle
不可能将对象

00:21:14.716 --> 00:21:15.096 A:middle
分解进内存

00:21:15.886 --> 00:21:19.556 A:middle
举个例子 在删除过程中

00:21:19.556 --> 00:21:22.306 A:middle
传统的调用 NSManagedObject.delete 将使

00:21:22.446 --> 00:21:24.836 A:middle
数据库中记录的大小增加

00:21:24.906 --> 00:21:26.116 A:middle
当你删除对象时

00:21:26.116 --> 00:21:27.336 A:middle
你的内存被分解到上下文中

00:21:27.336 --> 00:21:29.436 A:middle
你的数据库越大

00:21:29.436 --> 00:21:32.086 A:middle
它就越贵

00:21:32.716 --> 00:21:34.036 A:middle
但是通过分批操作

00:21:34.036 --> 00:21:36.106 A:middle
我们可以在一小部分内存里

00:21:36.106 --> 00:21:37.706 A:middle
进行同样的变化

00:21:38.276 --> 00:21:39.716 A:middle
它有我们想要的曲线关系

00:21:39.716 --> 00:21:42.756 A:middle
即当数据增加时

00:21:42.756 --> 00:21:44.626 A:middle
数据集越大

00:21:44.626 --> 00:21:46.976 A:middle
我们使用的内存越小

00:21:46.976 --> 00:21:48.696 A:middle
删除 1000 万行

00:21:48.696 --> 00:21:50.606 A:middle
我们只需用到

00:21:50.606 --> 00:21:51.156 A:middle
传统内存的 7%

00:21:52.556 --> 00:21:54.076 A:middle
这是一个

00:21:54.076 --> 00:21:55.296 A:middle
节约你的用户设备内存的

00:21:55.296 --> 00:21:57.066 A:middle
有力方式

00:21:57.956 --> 00:21:59.176 A:middle
但是分批操作的

00:21:59.176 --> 00:22:00.976 A:middle
一个传统问题是

