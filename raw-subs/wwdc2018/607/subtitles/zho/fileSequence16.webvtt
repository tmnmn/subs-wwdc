WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:58.776 --> 00:16:00.496 A:middle
转移到 GPU 上

00:16:01.306 --> 00:16:03.236 A:middle
GPU 在处理最近游戏中出现的

00:16:03.476 --> 00:16:04.906 A:middle
越来越复杂的场景方面

00:16:04.906 --> 00:16:05.796 A:middle
做得更好

00:16:06.936 --> 00:16:09.526 A:middle
不幸的是 这会在你的框架中

00:16:09.526 --> 00:16:10.816 A:middle
创建一个同步点

00:16:12.456 --> 00:16:14.486 A:middle
而且它使得 CPU 不能对

00:16:14.486 --> 00:16:16.266 A:middle
绘制调用进行编码直到

00:16:16.266 --> 00:16:17.996 A:middle
GPU 产生数据

00:16:18.466 --> 00:16:19.826 A:middle
在不浪费宝贵的

00:16:19.826 --> 00:16:21.436 A:middle
CPU 和 GPU 同步时间的情况下

00:16:21.436 --> 00:16:24.636 A:middle
完成该任务是极其困难的

00:16:25.716 --> 00:16:28.216 A:middle
ICB 的好处是巨大的

00:16:28.726 --> 00:16:30.176 A:middle
你不仅可以将最后的处理

00:16:30.176 --> 00:16:32.086 A:middle
转移到 GPU 上 还可以

00:16:32.646 --> 00:16:34.176 A:middle
自然移除任何

00:16:34.176 --> 00:16:35.426 A:middle
交换数据所需的

00:16:35.426 --> 00:16:37.766 A:middle
同步点 并且提高 CPU 和 GPU

00:16:37.806 --> 00:16:39.076 A:middle
的利用率

00:16:39.706 --> 00:16:42.116 A:middle
同时 你可以把

00:16:42.116 --> 00:16:43.886 A:middle
CPU 开销降至一个常量

00:16:44.566 --> 00:16:47.086 A:middle
所以让我们来看一下

00:16:47.086 --> 00:16:48.136 A:middle
编码的细节

00:16:49.166 --> 00:16:51.806 A:middle
我将首先使用前面的

00:16:51.806 --> 00:16:53.566 A:middle
例子来看一看

00:16:53.566 --> 00:16:55.316 A:middle
只有 GPU 可以提供的

00:16:55.316 --> 00:16:57.216 A:middle
大规模并行化

00:16:57.876 --> 00:16:59.736 A:middle
我们从剔除调度中的

00:16:59.736 --> 00:17:03.076 A:middle
可见对象列表和 LOD 开始

