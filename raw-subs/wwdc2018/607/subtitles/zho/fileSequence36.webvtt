WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:55.686 --> 00:36:00.576 A:middle
因此 有了持久线程组

00:36:00.706 --> 00:36:02.116 A:middle
Tile 的着色阶段

00:36:02.116 --> 00:36:03.716 A:middle
可以将深度边界和

00:36:03.716 --> 00:36:05.086 A:middle
剔除光线列表写入

00:36:05.086 --> 00:36:06.416 A:middle
线程组内存中供

00:36:06.416 --> 00:36:07.766 A:middle
以后使用

00:36:08.716 --> 00:36:09.996 A:middle
这意味着现在我们所有的

00:36:09.996 --> 00:36:11.256 A:middle
中间数据都会保留在传输过程上

00:36:11.766 --> 00:36:13.056 A:middle
并且永远不会离开 GPU

00:36:13.056 --> 00:36:14.506 A:middle
只有最终的图像存储

00:36:14.506 --> 00:36:15.186 A:middle
在系统内存中

00:36:16.556 --> 00:36:17.876 A:middle
尽量减少系统内存

00:36:17.876 --> 00:36:19.516 A:middle
的带宽对于游戏的

00:36:19.516 --> 00:36:21.596 A:middle
性能和游戏时间来说是非常重要的

00:36:21.676 --> 00:36:24.546 A:middle
现在 我们来看一看

00:36:24.546 --> 00:36:25.616 A:middle
在着色语言中

00:36:25.616 --> 00:36:27.466 A:middle
使用持久线程组有多容易

00:36:31.336 --> 00:36:33.166 A:middle
好的 所以这里的顶层函数

00:36:33.166 --> 00:36:34.376 A:middle
是我们的 Tile 着色器

00:36:34.376 --> 00:36:35.426 A:middle
它将执行我们的光线剔除过程

00:36:35.726 --> 00:36:37.396 A:middle
它将光线与

00:36:37.396 --> 00:36:39.276 A:middle
Tile 视锥相交以计算

00:36:39.276 --> 00:36:41.026 A:middle
主动的光掩码

00:36:41.876 --> 00:36:43.096 A:middle
底层函数是

00:36:43.096 --> 00:36:44.376 A:middle
我们的片段着色器

00:36:44.376 --> 00:36:45.206 A:middle
它执行我们的正向着色

00:36:45.696 --> 00:36:46.846 A:middle
它只使用该

00:36:46.846 --> 00:36:48.486 A:middle
主动光掩码遮住

00:36:48.486 --> 00:36:49.806 A:middle
与 Tile 相交的灯光

00:36:51.456 --> 00:36:53.256 A:middle
现在 在这两个着色器

00:36:53.256 --> 00:36:54.766 A:middle
通过使用相同类型和

00:36:54.766 --> 00:36:56.116 A:middle
绑定点实现跨函数

00:36:56.406 --> 00:36:59.116 A:middle
的共享线程组内存

