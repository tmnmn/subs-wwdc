WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:55:57.916 --> 00:56:00.186 A:middle
而不必将深度缓冲区解析到主内存

00:56:01.916 --> 00:56:03.006 A:middle
我们也使用它来提高

00:56:03.006 --> 00:56:04.286 A:middle
MSAA 的质量

00:56:04.806 --> 00:56:06.356 A:middle
正如我所提到的

00:56:06.356 --> 00:56:08.316 A:middle
我们进行 HDR 渲染 但是

00:56:08.316 --> 00:56:10.906 A:middle
仅仅是 HDR 的 MSAA 解析仍然会

00:56:10.906 --> 00:56:12.116 A:middle
导致非常参差的边缘

00:56:12.506 --> 00:56:13.556 A:middle
想想你有一个

00:56:13.556 --> 00:56:15.226 A:middle
非常非常明亮的天空和

00:56:15.226 --> 00:56:16.636 A:middle
非常非常黑暗的前视图的情况

00:56:17.126 --> 00:56:19.616 A:middle
这时只需要做一个

00:56:19.616 --> 00:56:22.526 A:middle
盒式过滤器就可以了 基本上

00:56:22.526 --> 00:56:24.396 A:middle
是说如果其中一个子样本

00:56:24.576 --> 00:56:25.876 A:middle
非常明亮 其他样本非常

00:56:25.876 --> 00:56:27.516 A:middle
黑暗 那么结果将是

00:56:27.516 --> 00:56:29.106 A:middle
一个令人难以置信的明亮像素

00:56:29.106 --> 00:56:30.066 A:middle
当色调映射时

00:56:30.066 --> 00:56:31.136 A:middle
它会接近白色

00:56:31.516 --> 00:56:32.656 A:middle
你最终会看到边缘看起来

00:56:32.656 --> 00:56:33.766 A:middle
完全没有反锯齿的样子

00:56:33.766 --> 00:56:36.436 A:middle
因此 我们的解决方案

00:56:36.436 --> 00:56:38.866 A:middle
是对所有 MSAA 样本执行

00:56:38.866 --> 00:56:41.686 A:middle
预先的色调映射 然后

00:56:41.686 --> 00:56:43.606 A:middle
执行正常的 MSAA 分辨率

00:56:43.606 --> 00:56:44.766 A:middle
然后第一个后处理通道

00:56:44.766 --> 00:56:46.576 A:middle
只是反转之前的预映射图

00:56:47.486 --> 00:56:49.026 A:middle
我们使用可编程混合进行

00:56:49.026 --> 00:56:50.116 A:middle
预色调贴图过程

00:56:50.746 --> 00:56:51.946 A:middle
否则 我们必须将

00:56:51.946 --> 00:56:53.576 A:middle
整个 MSAA 颜色缓冲区

00:56:53.576 --> 00:56:55.366 A:middle
解析为内存并将其读回

00:56:55.366 --> 00:56:56.796 A:middle
这是我们负担不起的

00:56:58.676 --> 00:57:00.316 A:middle
接下来我将展望一下

