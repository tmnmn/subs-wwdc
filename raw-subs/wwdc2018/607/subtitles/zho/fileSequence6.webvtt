WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:58.826 --> 00:06:01.036 A:middle
在这种情况下 Metal 技术

00:06:01.036 --> 00:06:02.726 A:middle
使用了一个专用的并行编码器

00:06:02.766 --> 00:06:04.986 A:middle
它允许你在多个线程上

00:06:04.986 --> 00:06:06.586 A:middle
进行编码 并且无需

00:06:06.586 --> 00:06:08.266 A:middle
明确划分

00:06:08.266 --> 00:06:10.026 A:middle
渲染通道或命令缓冲区

00:06:10.686 --> 00:06:12.286 A:middle
所以现在 让我们来看一看它

00:06:12.286 --> 00:06:13.786 A:middle
在你的代码里有多简单

00:06:14.866 --> 00:06:17.106 A:middle
它看起来非常像之前的例子

00:06:17.776 --> 00:06:18.956 A:middle
你要做的第一件事就是

00:06:18.956 --> 00:06:21.066 A:middle
创建一个并行编码器

00:06:21.606 --> 00:06:23.776 A:middle
并且从这个并行编码器中

00:06:23.776 --> 00:06:25.386 A:middle
创建任意数量的从属编码器

00:06:25.436 --> 00:06:27.066 A:middle
很重要的一点是意识到

00:06:27.066 --> 00:06:28.146 A:middle
这实际上就是你

00:06:28.146 --> 00:06:29.976 A:middle
定义图形处理器（GPU）执行顺序的地方

00:06:32.026 --> 00:06:35.356 A:middle
接下来 我们将创建

00:06:35.356 --> 00:06:37.736 A:middle
单独的线程并单独对

00:06:37.776 --> 00:06:40.406 A:middle
我们的每个 G 缓冲（G-buffer）函数进行编码

00:06:40.966 --> 00:06:44.956 A:middle
最后 我们会设置一个

00:06:44.956 --> 00:06:46.286 A:middle
通知 当线程

00:06:46.286 --> 00:06:48.726 A:middle
完成时 我们可以在

00:06:48.726 --> 00:06:50.296 A:middle
并行编码器上调用结束编码

00:06:50.296 --> 00:06:50.926 A:middle
这就是全部了

00:06:51.186 --> 00:06:52.866 A:middle
这就是你并行化渲染通道

00:06:52.866 --> 00:06:54.416 A:middle
所需要做的全部内容

00:06:54.486 --> 00:06:55.606 A:middle
它非常快速

00:06:55.606 --> 00:06:56.206 A:middle
而且非常简单

00:06:56.206 --> 00:06:58.126 A:middle
现在我已经向你展示了两种在

00:06:58.126 --> 00:06:59.886 A:middle
中央处理器（CPU）上并行化的方法

