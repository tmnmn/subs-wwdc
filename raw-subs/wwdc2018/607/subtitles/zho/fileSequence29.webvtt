WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.166 --> 00:29:00.216 A:middle
无记忆渲染目标功能

00:29:00.216 --> 00:29:02.066 A:middle
对于节省内存来说真的非常

00:29:02.066 --> 00:29:03.066 A:middle
非常简单

00:29:03.616 --> 00:29:04.846 A:middle
你只需创建一个

00:29:04.846 --> 00:29:06.776 A:middle
带有无记忆标记的纹理

00:29:06.776 --> 00:29:08.246 A:middle
同时 Metal 技术仅允许

00:29:08.246 --> 00:29:09.416 A:middle
你在没有进行加载或存储操作的情况下

00:29:09.416 --> 00:29:10.176 A:middle
把它作为附件

00:29:10.746 --> 00:29:13.376 A:middle
所以 现在让我们来看一看

00:29:13.376 --> 00:29:14.476 A:middle
在着色器中使用可编程混合

00:29:14.476 --> 00:29:15.606 A:middle
是多么的容易

00:29:16.156 --> 00:29:20.056 A:middle
好的 这里是你的

00:29:20.056 --> 00:29:21.236 A:middle
光通道的

00:29:21.236 --> 00:29:23.366 A:middle
片段着色器在可编程混合中的样子

00:29:24.196 --> 00:29:25.786 A:middle
当你读取和写入

00:29:25.786 --> 00:29:27.606 A:middle
你的附件时 可编程混合将被启用

00:29:27.986 --> 00:29:29.526 A:middle
在这个例子中

00:29:29.526 --> 00:29:30.666 A:middle
我们看到 G 缓冲附件

00:29:30.666 --> 00:29:32.856 A:middle
既是我们函数的输入 又是函数的输出

00:29:32.956 --> 00:29:36.826 A:middle
我们首先使用我们的 G 缓冲的属性

00:29:36.826 --> 00:29:38.146 A:middle
来计算我们的照明

00:29:38.856 --> 00:29:39.886 A:middle
正如你在这里看到的

00:29:39.886 --> 00:29:41.006 A:middle
我们正在读取我们的附件

00:29:41.006 --> 00:29:41.866 A:middle
但我们并没有将它们作为纹理

00:29:41.866 --> 00:29:42.376 A:middle
进行采样

00:29:42.916 --> 00:29:45.676 A:middle
然后 我们将我们的照明的

00:29:45.676 --> 00:29:47.186 A:middle
累积结果返回 G 缓冲

00:29:47.186 --> 00:29:48.126 A:middle
在这一步中

00:29:48.126 --> 00:29:49.306 A:middle
我们都在读取和写入

00:29:49.306 --> 00:29:50.226 A:middle
我们的累积结果

00:29:50.616 --> 00:29:52.156 A:middle
这就是最后了

00:29:52.406 --> 00:29:53.946 A:middle
可编程混合真的非常简单

00:29:53.946 --> 00:29:55.256 A:middle
只要你有多个

00:29:55.256 --> 00:29:56.516 A:middle
读取和写入相同附件

00:29:56.516 --> 00:29:58.176 A:middle
的渲染过程 你就应该在

00:29:58.176 --> 00:29:59.356 A:middle
那里应用它

