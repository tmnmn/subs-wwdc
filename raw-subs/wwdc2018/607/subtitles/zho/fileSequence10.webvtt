WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:09:59.476 --> 00:10:02.006 A:middle
通过使用堆 你可以取消分配和

00:10:02.006 --> 00:10:04.436 A:middle
重新分配资源 而无需任何昂贵的

00:10:04.436 --> 00:10:06.226 A:middle
和系统进行的双向沟通

00:10:08.156 --> 00:10:09.846 A:middle
最后 堆也可以让你

00:10:09.846 --> 00:10:12.406 A:middle
互相分享不同的内存资源

00:10:14.086 --> 00:10:15.376 A:middle
这在当你的

00:10:15.376 --> 00:10:16.916 A:middle
游戏框架有很多

00:10:16.916 --> 00:10:18.166 A:middle
临时渲染目标时非常有用

00:10:18.686 --> 00:10:19.846 A:middle
没有理由让这些目标

00:10:19.846 --> 00:10:21.276 A:middle
不断地占用不同的内存

00:10:21.276 --> 00:10:23.696 A:middle
所以你可以替换入口

00:10:23.696 --> 00:10:25.546 A:middle
并省下数百兆字节

00:10:26.236 --> 00:10:28.376 A:middle
现在 在替换入口的方式中

00:10:28.376 --> 00:10:30.666 A:middle
分配速度更快 但在

00:10:30.666 --> 00:10:31.996 A:middle
涉及相关性跟踪时 它并不是

00:10:31.996 --> 00:10:32.946 A:middle
完全没有影响的

00:10:33.466 --> 00:10:34.536 A:middle
让我们回到

00:10:34.536 --> 00:10:35.546 A:middle
框架示例来进行

00:10:35.546 --> 00:10:36.306 A:middle
更好的解释

00:10:38.356 --> 00:10:40.786 A:middle
当使用了堆时

00:10:40.786 --> 00:10:42.556 A:middle
Metal 技术就看不到单个的资源

00:10:42.556 --> 00:10:43.346 A:middle
因此它不能

00:10:43.586 --> 00:10:44.956 A:middle
自动识别通道之间

00:10:44.956 --> 00:10:46.236 A:middle
的读写相关性

00:10:46.236 --> 00:10:48.366 A:middle
例如示例中的

00:10:48.366 --> 00:10:49.946 A:middle
G 缓冲（G-buffer）和延期着色通道

00:10:51.056 --> 00:10:53.516 A:middle
所以你必须使用栅栏

00:10:53.516 --> 00:10:55.076 A:middle
来明确地标记哪个

00:10:55.136 --> 00:10:57.276 A:middle
通道产生数据 哪个通道

00:10:57.386 --> 00:10:58.286 A:middle
消耗数据

00:10:58.906 --> 00:11:00.856 A:middle
在这个例子中 G 缓冲（G-buffer） 

