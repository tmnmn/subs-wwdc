WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.506 --> 00:28:00.456 A:middle
一种一般使用

00:28:00.456 --> 00:28:02.446 A:middle
2 遍传递实现的多光技术

00:28:03.046 --> 00:28:04.916 A:middle
在第一遍中

00:28:04.916 --> 00:28:05.866 A:middle
多个附件填充了

00:28:05.906 --> 00:28:07.366 A:middle
每个像素可见的

00:28:07.366 --> 00:28:09.426 A:middle
几何属性 例如法线

00:28:09.886 --> 00:28:11.316 A:middle
反照率和粗糙度

00:28:12.136 --> 00:28:13.296 A:middle
在第二遍中 通过对那些

00:28:13.296 --> 00:28:14.776 A:middle
G 缓冲的内容进行采样来对

00:28:14.776 --> 00:28:15.856 A:middle
片段进行着色

00:28:16.456 --> 00:28:20.396 A:middle
现在 G 缓冲先被存储在

00:28:20.396 --> 00:28:21.766 A:middle
系统内存中 然后再次在

00:28:21.766 --> 00:28:23.146 A:middle
光照通道中读取

00:28:23.686 --> 00:28:24.976 A:middle
并且从 Tile 的内存到系统内存的

00:28:24.976 --> 00:28:26.516 A:middle
双向交流和再次回退

00:28:26.516 --> 00:28:28.046 A:middle
可能使你的游戏进入

00:28:28.046 --> 00:28:29.546 A:middle
瓶颈 因为 G 缓冲

00:28:29.546 --> 00:28:30.986 A:middle
轨道消耗了大量的带宽

00:28:31.566 --> 00:28:33.626 A:middle
现在 可编程混合可以

00:28:33.626 --> 00:28:35.206 A:middle
让你直接从 Tile 的内存

00:28:35.206 --> 00:28:36.646 A:middle
中读取到当前像素的

00:28:36.646 --> 00:28:38.636 A:middle
数据 从而跳过内存的

00:28:38.636 --> 00:28:40.916 A:middle
来回沟通

00:28:42.586 --> 00:28:43.506 A:middle
这也意味着我们

00:28:43.506 --> 00:28:44.666 A:middle
不再需要 2 次传递

00:28:44.966 --> 00:28:46.486 A:middle
我们 G 缓冲的填充

00:28:46.486 --> 00:28:48.096 A:middle
和光照步骤现在

00:28:48.096 --> 00:28:50.226 A:middle
被编码和运行在每个渲染通道中

00:28:51.536 --> 00:28:52.896 A:middle
这也意味着

00:28:52.896 --> 00:28:54.206 A:middle
我们不再需要系统内存中的

00:28:54.206 --> 00:28:55.856 A:middle
G 缓冲内容的副本

00:28:56.376 --> 00:28:59.166 A:middle
有了内存 Metal 技术的

00:28:59.166 --> 00:29:00.216 A:middle
无记忆渲染目标功能

