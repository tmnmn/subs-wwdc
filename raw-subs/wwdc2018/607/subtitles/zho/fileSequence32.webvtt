WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.556 --> 00:32:00.136 A:middle
每个传入的片段按

00:32:00.136 --> 00:32:01.326 A:middle
深度排序加到数组中

00:32:02.186 --> 00:32:03.706 A:middle
如果一个片段的深度

00:32:03.706 --> 00:32:04.916 A:middle
超出了数组的最后

00:32:04.916 --> 00:32:06.246 A:middle
一个元素 那么

00:32:06.246 --> 00:32:07.536 A:middle
这些元素就会被合并

00:32:07.536 --> 00:32:09.126 A:middle
所以它实际上是

00:32:09.566 --> 00:32:09.766 A:middle
一个近似的技术

00:32:11.376 --> 00:32:12.976 A:middle
现在 对 MLAB 数组进行

00:32:12.976 --> 00:32:14.136 A:middle
排序速度非常快 因为它存在于

00:32:14.136 --> 00:32:14.746 A:middle
Tile 的内存中

00:32:15.556 --> 00:32:16.796 A:middle
由于额外的带宽

00:32:16.796 --> 00:32:18.186 A:middle
和同步开销 在芯片

00:32:18.186 --> 00:32:19.356 A:middle
上做同样的操作会变得

00:32:19.356 --> 00:32:20.346 A:middle
非常昂贵

00:32:20.856 --> 00:32:25.326 A:middle
A11 实际上是对

00:32:25.326 --> 00:32:26.826 A:middle
上一代支持的最大像素尺寸

00:32:26.826 --> 00:32:28.096 A:middle
进行了加倍

00:32:28.866 --> 00:32:30.466 A:middle
但这还不足以

00:32:30.466 --> 00:32:31.596 A:middle
同时包含

00:32:31.596 --> 00:32:34.606 A:middle
G 缓冲和 MLAB 数据结构

00:32:35.396 --> 00:32:37.366 A:middle
幸运的是 你不需要

00:32:37.366 --> 00:32:38.106 A:middle
同时使用两者

00:32:38.916 --> 00:32:40.076 A:middle
图像块（Imageblocks）允许

00:32:40.076 --> 00:32:41.896 A:middle
你在渲染过程中

00:32:41.896 --> 00:32:43.216 A:middle
更改像素布局以符合

00:32:43.916 --> 00:32:44.036 A:middle
你的当前需求

00:32:44.956 --> 00:32:47.296 A:middle
改变像素布局实际上

00:32:47.296 --> 00:32:48.926 A:middle
需要 Tile 的着色 所以我们接下来

00:32:48.926 --> 00:32:50.846 A:middle
来讨论一下这个

00:32:56.256 --> 00:32:58.036 A:middle
Tile 着色是

00:32:58.036 --> 00:32:59.516 A:middle
新的可编程阶段

00:32:59.516 --> 00:33:01.246 A:middle
它直接在渲染过程中提供了

