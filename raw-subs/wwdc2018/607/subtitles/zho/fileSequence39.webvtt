WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:00.806 --> 00:39:02.176 A:middle
我们可以使用它来执行

00:39:02.216 --> 00:39:04.566 A:middle
自定义解析和快速的

00:39:04.566 --> 00:39:05.406 A:middle
Tile 内存

00:39:06.186 --> 00:39:07.466 A:middle
现在 让我们来看一看

00:39:07.696 --> 00:39:08.516 A:middle
为什么这是有用的

00:39:08.516 --> 00:39:10.316 A:middle
让我们来看一下渲染粒子

00:39:10.316 --> 00:39:11.166 A:middle
的多重采样场景

00:39:14.196 --> 00:39:15.766 A:middle
粒子是透明的

00:39:15.766 --> 00:39:17.356 A:middle
所以我们将在渲染我们的

00:39:17.356 --> 00:39:18.646 A:middle
不透明场景几何体之后将它们混合

00:39:19.306 --> 00:39:20.706 A:middle
但是粒子渲染不能从

00:39:20.706 --> 00:39:21.886 A:middle
多重采样中受益

00:39:21.886 --> 00:39:23.716 A:middle
因为它实际上没有任何可见的边缘

00:39:24.766 --> 00:39:26.236 A:middle
因此 为了避免

00:39:26.236 --> 00:39:27.496 A:middle
无理由地混合

00:39:27.496 --> 00:39:29.256 A:middle
每个样本的额外成本

00:39:29.256 --> 00:39:30.236 A:middle
游戏将使用 2 次传递进行渲染

00:39:30.956 --> 00:39:32.546 A:middle
在第一遍中 你的不透明的

00:39:32.546 --> 00:39:33.956 A:middle
场景几何体

00:39:33.956 --> 00:39:35.756 A:middle
将使用多重采样来渲染以减少混叠

00:39:36.666 --> 00:39:37.536 A:middle
然后 你将解决

00:39:37.536 --> 00:39:38.696 A:middle
关于系统内存的颜色

00:39:38.696 --> 00:39:40.036 A:middle
和深度 并且处理

00:39:40.036 --> 00:39:41.506 A:middle
深度 因为之后它在之后

00:39:41.506 --> 00:39:42.846 A:middle
可以包含粒子

00:39:43.916 --> 00:39:45.696 A:middle
然后在第二遍中

00:39:45.696 --> 00:39:47.496 A:middle
使用解析颜色和

00:39:47.636 --> 00:39:49.576 A:middle
深度来渲染没有多次采样的粒子

00:39:51.256 --> 00:39:52.466 A:middle
现在 正如你现在可能

00:39:52.466 --> 00:39:54.326 A:middle
猜到的那样 我们的目标

00:39:54.326 --> 00:39:55.396 A:middle
是使用 Tile 着色来消除

00:39:55.396 --> 00:39:56.876 A:middle
中间传输的系统内存

00:39:56.876 --> 00:39:58.646 A:middle
以便合并这两个传递

