WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:56:58.676 --> 00:57:00.316 A:middle
接下来我将展望一下

00:57:00.316 --> 00:57:01.546 A:middle
未来我们希望在

00:57:01.546 --> 00:57:04.556 A:middle
Metal 中进行的一些工作并行渲染

00:57:04.556 --> 00:57:06.996 A:middle
所以在 macOS 上 我们

00:57:07.416 --> 00:57:08.626 A:middle
确实支持并行地创建

00:57:08.626 --> 00:57:09.216 A:middle
命令缓冲区

00:57:09.756 --> 00:57:12.186 A:middle
在 iOS 上 我们需要

00:57:12.186 --> 00:57:13.266 A:middle
支持并行命令

00:57:13.266 --> 00:57:14.876 A:middle
的编码器才能使用它

00:57:15.176 --> 00:57:16.476 A:middle
我们的很多绘制

00:57:16.476 --> 00:57:17.646 A:middle
最终都会发生在

00:57:17.646 --> 00:57:19.376 A:middle
主要正向传递中 因此将其

00:57:20.176 --> 00:57:21.546 A:middle
并行化非常重要

00:57:22.206 --> 00:57:23.436 A:middle
我认为 看到

00:57:23.436 --> 00:57:25.076 A:middle
并行渲染对单片快速

00:57:25.076 --> 00:57:27.876 A:middle
内核的影响和

00:57:28.006 --> 00:57:30.786 A:middle
在高端设备高效内核上使用

00:57:30.896 --> 00:57:33.156 A:middle
并行命令编码器

00:57:33.156 --> 00:57:34.616 A:middle
的效果进行比较会

00:57:34.616 --> 00:57:35.626 A:middle
非常有趣

00:57:35.946 --> 00:57:36.616 A:middle
这可能会在

00:57:36.616 --> 00:57:38.416 A:middle
电池使用方面产生

00:57:38.416 --> 00:57:38.896 A:middle
一些有趣的结果

00:57:40.656 --> 00:57:41.696 A:middle
Metal 堆

00:57:41.786 --> 00:57:42.736 A:middle
所以我们希望用 Metal 堆

00:57:42.736 --> 00:57:44.276 A:middle
来代替我们的缓冲区

00:57:44.276 --> 00:57:46.396 A:middle
子分配 首先

00:57:46.396 --> 00:57:47.586 A:middle
因为它只是简单的代码

00:57:47.586 --> 00:57:49.246 A:middle
其次 因为我们也可以

00:57:49.246 --> 00:57:50.056 A:middle
把它用于纹理

00:57:50.366 --> 00:57:51.576 A:middle
我们由于纹理流式传输

00:57:51.576 --> 00:57:52.746 A:middle
仍然偶尔会遇到麻烦

00:57:52.746 --> 00:57:54.546 A:middle
因为我们会在显式地

00:57:54.546 --> 00:57:55.736 A:middle
动态地创建和销毁纹理

00:57:55.736 --> 00:57:57.586 A:middle
就像把纹理不断的在内存里进行读写

00:57:58.146 --> 00:57:59.946 A:middle
使用堆可以摆脱

00:57:59.946 --> 00:58:01.516 A:middle
那些困境

