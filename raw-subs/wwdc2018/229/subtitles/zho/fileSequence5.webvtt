WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:00.200 --> 00:05:02.102 align:middle line:-1
但实际上集合并不孤单

00:05:02.436 --> 00:05:03.971 align:middle line:-1
其实集合不是我们唯一的协议

00:05:04.037 --> 00:05:05.205 align:middle line:-1
在Swift中 我们可以访问

00:05:05.272 --> 00:05:07.674 align:middle line:-1
丰富的集合协议层次结构

00:05:07.741 --> 00:05:09.676 align:middle line:-1
其中每个都对我们提供的类型假设

00:05:09.743 --> 00:05:11.345 align:middle line:-1
做了极大改善

00:05:11.678 --> 00:05:13.247 align:middle line:-1
让我们继续讨论其中一些协议

00:05:13.313 --> 00:05:14.615 align:middle line:-1
（集合协议层次结构）

00:05:14.681 --> 00:05:18.318 align:middle line:-2
我们知道集合可以让你
从给定的索引向前移动

00:05:18.385 --> 00:05:19.586 align:middle line:-1
（集合）

00:05:19.653 --> 00:05:21.455 align:middle line:-1
但也存在双向集合

00:05:21.522 --> 00:05:23.323 align:middle line:-1
它可以让你沿着另一个方向移动

00:05:23.390 --> 00:05:24.791 align:middle line:-1
（双向集合）

00:05:24.858 --> 00:05:27.995 align:middle line:-1
当然 双向集合也是集合

00:05:28.061 --> 00:05:29.997 align:middle line:-1
所以我们仍然可以向前迭代

00:05:31.565 --> 00:05:33.367 align:middle line:-1
下一个最灵活的集合形式

00:05:33.433 --> 00:05:35.302 align:middle line:-1
就是所谓的随机访问集合

00:05:35.369 --> 00:05:39.239 align:middle line:-1
它要求当根据某个索引计算另一个

00:05:39.306 --> 00:05:41.909 align:middle line:-1
或计算两个索引之间的距离的时候

00:05:41.975 --> 00:05:44.111 align:middle line:-1
所需的时间是常量

00:05:44.411 --> 00:05:46.346 align:middle line:-1
编译器无法保证这一点

00:05:46.413 --> 00:05:48.515 align:middle line:-1
所以当你使用随机访问集合时

00:05:48.582 --> 00:05:49.750 align:middle line:-1
你正在作出一项承诺

00:05:50.517 --> 00:05:52.786 align:middle line:-2
但如果你满足这个承诺
如果你能兑现承诺

00:05:52.853 --> 00:05:54.021 align:middle line:-1
这个协议就可以让你

00:05:54.087 --> 00:05:57.090 align:middle line:-1
在常量时间内访问集合中的任何索引

00:05:57.991 --> 00:06:00.327 align:middle line:-1
当然 随机访问集合仍然是集合

