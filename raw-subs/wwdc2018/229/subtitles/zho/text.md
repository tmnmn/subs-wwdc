# Using Collections Effectively

## Summary
Every app uses collections! Go beyond the basics with specific tips on how best to use indices, slices, bridging, laziness, and reference types. Gain better understanding of when to use each collection for best performance.

## Info
* Developer Tools
* WWDC 2018 - Session 229 - macOS
* https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/

## Text
 [（高效使用集合 演讲229）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=17) [早上好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=21) [我叫Michael LeHew](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=23) [我在Apple Foundation团队
从事集合相关工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=25) [今天我想谈一些](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=28) [你应该知道的事
以确保你能够尽可能高效地](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=31) [在Swift中使用集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=34) [今天我会讨论很多领域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=37) [关于Swift中可用集合的
详细信息和各个方面](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=39) [我们将探索一些常见的误区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=43) [以及如何避免它们
包括性能问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=46) [我也将提供非常具体的建议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=48) [关于何时该选择哪些特定集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=50) [让我们开始吧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=53) [我想让你想象一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=54) [没有集合的世界](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=57) [在这个世界中
我们可能没有数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=61) [但它仍然有熊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=64) [但每次当我们需要另一只熊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=67) [我们就需要定义另一个变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=69) [我们想对这些熊做些事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=72) [我们只能够重复自己](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=73) [很可怕 对吧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=76) [但更糟的是
这个世界也没有字典](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=78) [但幸好我们是聪明的开发者](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=82) [我们可以用函数来解决这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=84) [我们煞费苦心地定义了
我们关心的每种情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=86) [使用这个函数与使用字典非常相似](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=90) [除了我们需要的那些动态功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=93) [但谁喜欢可变状态 对吧？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=96) [但幸运的是
我们并不生活在这个世界中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=98) [值得庆幸的是
我们的世界有既有熊也有集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=102) [以及用于定义它们的丰富的原生语法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=105) [还有当我们迭代时
帮助我们不必重复自己](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=109) [或获取集合中的元素的API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=113) [集合非常普遍并且共享如此多的
常见特性和算法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=117) [集合非常普遍并且共享如此多的
常见特性和算法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=117) [因此在Swift中
它们都遵守一个通用协议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=121) [毫不奇怪
它叫Collection](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=125) [在Swift中 集合就是序列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=128) [其中的元素可以以非破坏性的方式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=129) [多次遍历](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=132) [并且其元素可以通过下标访问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=133) [（COLLECTION协议）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=136) [我们看看这是如何做到的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=137) [考虑一下集合的抽象表示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=139) [（集合存储元素）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=141) [这可能是一个在连续内存中
定义的数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=142) [哈希表 红黑树](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=145) [链接、列表或你可以想象的
任何其它东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=148) [重要的是它支持初始索引的概念](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=151) [其被称为起始索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=154) [（起始索引）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=155) [它可以用来访问集合的初始元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=156) [它还有一个结束索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=160) [其标识集合的结束](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=161) [（结束索引）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=163) [集合支持从其起始索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=164) [到结束索引之间遍历元素的能力](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=166) [它们可以多次进行这种遍历](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=169) [它们也支持使用下标来获取](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=171) [集合中的元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=174) [（SUBSCRIPT[INDEX]）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=176) [我们看看它在代码中的样子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=177) [的确 如果我们看一下集合的定义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=179) [的确 如果我们看一下集合的定义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=179) [它被声明为一个元素序列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=181) [它还有一个关联类型称为Index](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=184) [其必须遵守
Comparable协议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=187) [它提供了一个下标来检索元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=190) [或使用该索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=192) [我们定义一个起始和结束索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=194) [以确定集合的范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=196) [最后 这里有一个
index(after)函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=198) [可以让我们从一个索引
到达另一个索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=202) [最后这个函数非常重要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=205) [因为它允许标准库](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=207) [通过强大的协议扩展来定义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=210) [许多有用且强大的默认行为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=212) [让我们看看其中的一些](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=215) [（协议扩展）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=217) [当你遵守
Collection协议时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=218) [你可以访问各种丰富的功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=219) [如能够让你获取首尾元素的属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=222) [或识别集合大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=226) [或检查集合是否为空](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=228) [你还可以通过API
使用forEach语法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=230) [来遍历集合元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=232) [及超有用的函数 如map
filter和reduce](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=235) [我们还可以通过添加自己的扩展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=239) [我们还可以通过添加自己的扩展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=239) [来让集合更加强大](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=241) [（间隔元素）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=243) [集合已经提供了遍历每个元素的方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=243) [但我想要一个函数
能够让我遍历间隔元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=246) [即在遍历过程中跳过一些值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=250) [我们将通过向集合添加扩展
来实现这点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=253) [我们从方法签名开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=256) [我们称该函数为
everyOther](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=258) [并且它将采用一个闭包
来调用我们想要的每个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=259) [我们得到迭代的边界](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=264) [并定义一个初始值为
start的值的变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=266) [该变量值将随运行而改变](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=269) [我们在当前元素上调用闭包](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=272) [并递增我们的索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=274) [此时我们的索引可能已经无效](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=277) [即我们已到集合的最后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=279) [因此我们需要确保检查它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=280) [如果还没越界
那么我们可以再次增加索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=283) [从而跳过间隔元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=286) [如果我们在1到10的封闭范围内
调用这个函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=288) [可以看到我们跳过了偶数元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=292) [我们看到集合可以让我们
描述一些非常强大的行为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=295) [但实际上集合并不孤单](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=300) [其实集合不是我们唯一的协议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=302) [在Swift中 我们可以访问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=304) [丰富的集合协议层次结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=305) [其中每个都对我们提供的类型假设](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=307) [做了极大改善](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=309) [让我们继续讨论其中一些协议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=311) [（集合协议层次结构）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=313) [我们知道集合可以让你
从给定的索引向前移动](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=314) [（集合）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=318) [但也存在双向集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=319) [它可以让你沿着另一个方向移动](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=321) [（双向集合）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=323) [当然 双向集合也是集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=324) [所以我们仍然可以向前迭代](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=328) [下一个最灵活的集合形式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=331) [就是所谓的随机访问集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=333) [它要求当根据某个索引计算另一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=335) [或计算两个索引之间的距离的时候](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=339) [所需的时间是常量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=341) [编译器无法保证这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=344) [所以当你使用随机访问集合时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=346) [你正在作出一项承诺](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=348) [但如果你满足这个承诺
如果你能兑现承诺](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=350) [这个协议就可以让你](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=352) [在常量时间内访问集合中的任何索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=354) [当然 随机访问集合仍然是集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=357) [当然 随机访问集合仍然是集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=357) [所以你仍然可以向前和向后迭代](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=360) [（随机访问集合）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=362) [作为Swift开发人员
我们可以访问遵守这些协议的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=364) [许多有用的集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=367) [这类集合包括Array
Set和Dictionary等](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=370) [（SWIFT中的集合
ARRAY - SET- DICTIONARY）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=372) [但由于这些协议的通用目的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=374) [许多其它类型也遵守这些集合协议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=376) [如Data
Range和String](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=379) [（DATA - RANGE - STRING）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=381) [或是索引集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=382) [它们都可以访问所有这些丰富的功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=384) [只要它们以自己的方式遵守集合协议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=386) [确实 一旦你知道其中任意一种类型
的工作原理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=389) [你就可以将该知识
应用于任何其它类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=392) [并且这些类型还不少](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=394) [我将谈谈类型如何
遵守集合协议的细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=397) [这一切都从描述如何索引开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=400) [（索引）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=404) [每个集合都有自己的索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=406) [该索引必须遵守
Comparable协议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=409) [在某些情况下 索引可能是整数
如数组中的索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=412) [但仅仅因为索引碰巧是一个整数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=416) [并不意味着你只能这样用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=418) [并不意味着你只能这样用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=418) [现在我想问几个问题
其答案可能出乎预料](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=421) [第一个是
我们如何获得数组的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=425) [你可能马上会想“这个简单
我只需调用array[0]”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=428) [数组的索引恰好是整数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=432) [所以你有时可以这样说
并得到你想要的结果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=434) [但这不是最好的办法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=437) [我要继续问同样的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=439) [但这次是关于另一种集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=441) [Set的第一个元素是什么？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=445) [听起来像一个很奇怪的问题 对吧？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=446) [Set是无序的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=449) [然而它们的确是集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=450) [并且作为集合 你可以遍历它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=452) [当遍历一个Set时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=454) [你将首先遍历一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=455) [所以这正是我们刚才问的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=457) [我能用set[0]吗？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=460) [编译器会说不](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=462) [这是因为Set的索引类型不是整数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=465) [类型系统希望我们
使用正确的索引类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=468) [幸运的是 我们已知如何做到这点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=472) [我们知道集合协议告诉我们所有集合
都有一个startIndex](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=474) [让我们继续并使用它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=477) [如果我们这样做](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=478) [这实际上适用于所有集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=479) [这实际上适用于所有集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=479) [startIndex
将始终代表你在遍历时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=481) [看到的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=485) [但在任何集合中使用下标索引时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=486) [有一个细微之处需要注意](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=488) [那就是 它可能会崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=492) [我实际上还没有断言
这些集合中有内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=496) [我直接使用了startIndex
然而这些集合可能是空的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=498) [事实证明 访问集合中的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=503) [是一个很普遍的任务
所以我们有更好的方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=506) [（致命错误：索引超出范围）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=509) [即只需调用first](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=511) [如果你调用first
这会更安全](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=512) [因为其返回类型为可选的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=515) [回忆一下并非所有集合
都具有第一个元素的事实](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=517) [我还有另一个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=522) [集合的第二个元素是什么
我想在这里强调集合本身](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=524) [它可以是任何集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=528) [一个数组、一个Set
或者甚至还不存在的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=529) [我们通过协议扩展向集合
添加一个新属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=532) [我们称其为second](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=535) [和first一样
它的返回类型为可选的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=536) [因为并非所有集合都有两个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=538) [因为并非所有集合都有两个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=538) [我们试试这样写 self[1]](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=542) [但这里我们的基于0的索引直觉
会将我们带入歧途](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=546) [然后我们会再次被编译器抓个正着](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=550) [我们希望此代码能够适用于每种集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=553) [而不只是使用整数作为索引的集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=555) [所以我们尝试一种不同的方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=558) [我真正想要的是
比startIndex大1的索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=561) [（找到一个集合的第二个元素）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=563) [但编译器仍不依不饶](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=565) [你不能将对任意索引类型加一](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=569) [索引类型应该是不透明的
或者可以是不透明的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=571) [我们在这里真正要做的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=575) [是我们需要使用
集合协议提供的API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=576) [来做到这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=579) [我们来试试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=580) [我注释了为了找到第二个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=582) [需要做的事情的框架](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=585) [我们需要做的第一件事是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=587) [我们需要检查集合是否为空](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=588) [集合在其startIndex](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=591) [等于endIndex时为空](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=592) [所以我们来检查一下并返回nil](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=594) [因为这样的集合没有第二个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=597) [因为这样的集合没有第二个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=597) [现在可以假设我们的集合有一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=603) [我们可以使用index(after)函数
来获取第二个元素或第二个索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=607) [但我们需要确保该索引是有效的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=611) [我们直观地来看一下](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=614) [我们向前移动了一个元素
但如果集合中只有一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=615) [我们现在的索引实际上是无效的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=618) [如果我们试图用下标索引它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=619) [我们就会得到刚才看到的严重错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=621) [所以我们检查它是否有效](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=623) [这与空链非常相似](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=624) [我们只需要确保我们的索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=626) [不等于endIndex
否则返回nil](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=628) [同样 因为单元素集合
没有第二个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=630) [这时我们确认了所有假设都成立](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=635) [并知道我们的集合至少有两个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=637) [所以我们可以安全地
为该索引使用下标运算符](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=640) [从而检索我们想要的值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=643) [这些代码看起来很多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=647) [但值得指出的是
这个通用目的索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=650) [将可以处理任何集合
这非常棒](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=652) [但其实Swift有更好的方法
来做到这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=655) [即一个叫做切片的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=658) [即一个叫做切片的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=658) [但在展示如何使用切片
做到这点之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=660) [我想谈谈什么是切片
以及它们如何工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=662) [（构造一个切片）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=666) [切片是仅描述集合的一部分的类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=668) [每个切片都有自己的起始和结束索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=673) [并且切片与其原始集合分开存在](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=677) [切片如此高效的原因是
它们不占用额外的存储空间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=681) [它们只是引用原始集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=684) [当使用切片下标时
它将读出原始缓冲区中的数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=687) [它们可以这样做是因为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=692) [它们与其原始集合共享同样的索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=694) [我们来看看这是如何工作的
我们可以证明这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=697) [我们将从一个数组开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=700) [我们丢弃该数组的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=701) [以生成一个少了一个元素的切片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=703) [由于我们想要证明索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=707) [我们需要得到数组的第二个索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=709) [即得到起始索引之后的一个索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=711) [然后比较它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=714) [它们的确是一样的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=715) [这个dropFirst函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=718) [看起来就是我们得到集合中
第二个元素的简便方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=719) [看起来就是我们得到集合中
第二个元素的简便方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=719) [让我们回到之前的解决方案](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=723) [看看切片的表达能力有多强](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=725) [还记得我们之前写的复杂的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=728) [索引检查代码吗](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=730) [通过使用dropFirst
我们将让切片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=732) [替我们处理那些复杂的
索引边界检查过程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=735) [由于第一个返回值是可选的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=738) [这在集合为空或只有一个元素时
也能按预期工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=740) [让我们将发生的事情可视化出来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=745) [我们从一个数组开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=747) [我们通过丢弃第一个元素
来构造一个切片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=748) [然后我们使用first属性
对切片进行下标运算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=752) [并从原始集合中获取元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=757) [我不知道你怎么想
但我更愿意维护这样的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=759) [每种类型都可以
自由描述自己的切片类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=764) [很多也正是这样做的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=767) [例如 Array
定义了ArraySlice](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=768) [它们是为了数组最经常处理的情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=771) [所特别定制的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=773) [类似地 String定义了
Substring切片类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=774) [而Substring也是为了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=778) [而Substring也是为了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=778) [处理最常见的字符串行为而定制的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=780) [一些类型 如Set](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=783) [将使用标准库中定义的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=785) [广义切片类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=787) [因为Set是无序的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=789) [它们能做的事情并不多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=790) [它们基本上只需要维护
一个起始和一个结束索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=791) [以及一个指向原始集合的指针](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=794) [另一方面 Data和Range是
它们自己的切片类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=796) [所以这里有很多选项](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=800) [在继续之前我还想谈一件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=802) [关于切片的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=805) [假设我们有一个非常大的集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=807) [比如有上亿个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=809) [然后我们为该集合的一部分
创建几个小切片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=813) [重要的是要记住切片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=816) [使整个原始集合保持活跃状态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=818) [只要切片还存在](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=821) [而这可能导致令人惊讶的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=823) [我们看看这在代码中是什么样的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=825) [假设我在数组上有一个扩展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=828) [允许我返回其前半部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=830) [我在这里使用dropLast函数
来做到这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=831) [我们有一个包含8个数字的数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=835) [我们调用扩展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=837) [生成切片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=839) [生成切片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=839) [然后尝试释放这8个数字的
原始存储空间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=841) [我将该数组设为一个空数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=844) [第一件趣事的线索是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=847) [发生在我们访问切片的第一个元素时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=850) [我们竟然能够得到1](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=853) [尽管我们已经释放了
原始数组的存储空间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=854) [要么它有一个副本
要么发生了一些不可思议的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=859) [如果我们想要消除那个缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=863) [这里发生的神奇的事
是我们还能访问那个缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=867) [所以如果我们想清除它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=870) [我们可以做的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=871) [从切片创建一个
数组的真实副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=873) [然后如果我们将该切片
设置为一个空数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=875) [那个副本仍然有效](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=879) [让我们看看发生了什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=881) [我们从一个数组开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=883) [然后我们根据该数组的前半部分
构造了一个切片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=885) [（复制切片）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=887) [然后我们创建了它的一个副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=889) [将数组设置为空
并将该切片也设置为空](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=892) [只有在我们这样做后
底层存储才会真正消失](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=894) [就这点而言 切片有点像延迟拷贝](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=901) [你可以选择](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=904) [何时自己创建元素的副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=905) [事实证明 这种“懒”行为
和延迟做某事的概念](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=908) [在其他情况下也非常有用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=912) [其中一种情况是函数调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=915) [（“急切的”函数）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=917) [默认情况下 Swift中的
函数调用是"急切的"](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=918) [也就是说 它们接收了输入
并按照要求返回它们的输出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=922) [考虑这个例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=927) [我们从一个1到4,000
的Range开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=928) [Range是代表大量数字的
一种非常简洁的方式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=930) [它只需要首和尾
就能够知道如何生成它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=933) [我们将其映射为每个值乘以2](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=937) [所以我们现在已经分配了
包含4000个元素的数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=939) [并在它们中的每一个上
执行我们的映射函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=942) [然后我们将过滤出四个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=946) [迄今为止 我们已经](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=948) [分配了4,004个元素的空间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=950) [但我们只需要最后四个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=956) [这其中具有大量的中间计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=960) [而我们并不总是希望这样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=962) [如果有办法不进行这些计算
除非绝对需要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=964) [那就太好了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=967) [Swift对此的回答称为“懒惰”
就像在现实生活中一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=970) [（惰性函数）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=973) [我们仍然从Range开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=974) [我们会告诉该Range
让它"懒惰"一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=977) [当我们这样做时
所发生的事是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=979) [我们用LazyCollection
包装了原始集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=981) [当我们对这个LazyCollection
执行操作时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=985) [所发生的事是
我们要再次包装它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=988) [所以当我们在它上面调用map时
我们实际上并没有映射](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=990) [我们没对该闭包做任何事](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=994) [除了将其存储以便我们将来需要它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=995) [如果我进一步过滤了
LazyMapCollection](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=998) [过滤器只是简单地包装该映射集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1001) [请注意它会在将来按需过滤](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1003) [而不是现在](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1005) [现在让我们继续并请求](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1007) [LazyFilterCollection
的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1009) [当我们这样做时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1015) [我们将首先请求
LazyFilterCollection的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1017) [第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1019) [第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1019) [但LazyFilterCollection
并不知道](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1020) [然而它包装了可能知道它的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1022) [因此它将询问
MapCollection](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1025) [而MapCollection
也不知道它的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1026) [但它包装了一个可能知道的集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1030) [的确 Range知道
它的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1031) [Range的第一个元素是值1](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1034) [它被返回到
LazyMapCollection](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1037) [现在LazyMapCollection
可以实际执行它的闭包](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1039) [计算出值为2](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1043) [该值被返回到
LazyFilterCollection](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1045) [并作为候选的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1047) [在这种情况下 我们很幸运
因为2恰好比10小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1049) [所以LazyFilterCollection
在第一次尝试中就找到了它的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1052) [并将其返回给调用者](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1056) [这是很不同的计算方式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1058) [我提到懒惰的目的是
只根据需要进行计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1061) [但它避免的另一件事是创建中间存储](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1066) [所以我想向你展示一个例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1069) [假设我们有一个
包含不同类型的熊的数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1072) [然而我想指出的是
其中一些熊是多余的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1075) [我们已经知道他们是熊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1079) [我们已经知道他们是熊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1079) [它们不必再告诉我们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1080) [所以让我们编写一些代码
来找到那些愚蠢的冗余熊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1083) [我们将像刚才一样用惰性过滤器
执行此操作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1086) [在这个例子中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1088) [所生成的惰性过滤器将是一个
LazyFilterCollection](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1090) [包装的一个字符串数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1094) [在我们的闭包中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1096) [我们将在做断言检查之前
打印出我们目前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1097) [正在迭代的那只熊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1100) [这样做是因为我想](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1102) [更好理解过滤器工作原理
然后我们将调用first](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1103) [当我们这样做时 执行过程将被交给
LazyFilterCollection](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1106) [随后LazyFilterCollection
将调用原始存储](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1110) [这时我们将打印出
“Grizzly”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1116) [并检查断言
在这种情况下结果为false](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1120) [因为“Grizzly”
不包含“Bear”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1123) [并移动到下一个“Panda”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1124) [当我们到达“Panda”时…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1127) [当我们到达“Panda”时
我们会再次打印出“Panda”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1130) [检查它是否包含单词“Bear”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1133) [并移动到“Spectacled”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1135) [“Spectacled”被打印
它也不包含“Bear”一词](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1137) [“Spectacled”被打印
它也不包含“Bear”一词](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1137) [最后我们移动到
“Gummy Bears”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1141) [它包含“Bear”这个词](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1143) [LazyFilterCollection
现在可以将其返回给它的调用者](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1146) [若我们再次调用first
会发生什么？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1152) [其实还是一样的过程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1155) [我们询问LazyFilterCollection
它将再次询问底层集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1158) [底层集合重复刚才的计算
并将结果返回给调用者](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1162) [现在这可能不是你想要的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1167) [所以如果你发现自己需要
反复调用惰性集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1170) [来计算其结果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1172) [有一种方法可以确保
该计算只发生一次](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1174) [我们可以通过从惰性集合
创建一个新的非惰性集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1177) [来确保惰性集合只迭代一次](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1180) [当你这样做时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1184) [它仍然会将计算委托给惰性集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1185) [但现在迭代过程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1187) [将处理完整个底层集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1188) [从而产生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1193) [该惰性计算的非惰性版本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1195) [这例子中 我们得到一个包含字符串
“Gummy Bears”的数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1197) [这例子中 我们得到一个包含字符串
“Gummy Bears”的数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1197) [如果我们打印该数组的第一个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1201) [我们根本不需要咨询闭包
或者惰性集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1203) [我们基本消除了其惰性
并得到一个“急切的”数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1206) [我们何时该懒惰呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1211) [惰性集合是一种非常好的能够消除](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1214) [链式映射和过滤器的开销的方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1216) [当你发现你只需要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1218) [集合运算的部分结果时
它们就非常有用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1219) [但如果你的闭包有副作用
你就应该避免使用懒惰策略](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1223) [你的闭包应该鲜有副作用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1227) [并且记得一定要恢复…
或者应该说](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1229) [一定要考虑重新恢复到普通集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1231) [当你跨越API边界时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1234) [惰性通常应该是一个实现细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1236) [（建议：何时使用惰性？）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1238) [到目前为止 我们已经使用可变集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1240) [做了很多很酷的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1242) [但Swift也允许我们
改变我们的集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1244) [（集合协议层次结构）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1247) [让我们来谈谈](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1249) [这两种尚未讨论过的集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1250) [其中第一个是可变集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1253) [它为下标添加了一个setter](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1255) [以便你可以更改集合的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1257) [但不能更改它的长度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1259) [但不能更改它的长度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1259) [你必须能够
在常数时间内完成这项任务](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1260) [（可变集合）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1262) [下一个被称为范围可替换集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1265) [你可以在这种集合中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1268) [删除元素或插入元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1270) [现在我想谈谈
我一直被问到的一个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1276) [为什么我的完全合理的
集合代码会崩溃？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1280) [像所有好问题的答案一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1283) [一般我会反问他们我自己的一些问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1285) [有时候我会从经典问题开始
“你想做什么？”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1288) [接下来我马上会问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1291) [“你是怎么使用集合的？”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1293) [“你在尝试改变它们吗？”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1295) [“你确定没有从多个线程
访问你的集合吗？”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1296) [我问这些问题是因为其答案](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1298) [常常能引出导致问题的根本原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1302) [首先让我们先假设跟线程没关系](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1306) [我还没准备好考虑线程
现在9:30都还没到呢](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1308) [（崩溃的集合代码）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1310) [假设我们有一个数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1312) [我们获取一个已知元素的索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1313) [这个例子中 值为“E”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1317) [然后我们通过删除它的第一个元素
来改变集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1318) [然后我们通过删除它的第一个元素
来改变集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1318) [我们继续并打印与该索引关联的元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1322) [当我们这样做时
不幸的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1326) [这会产生一个严重错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1328) [索引不再有效](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1332) [实际上当我们改变集合时
索引立即变得无效了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1333) [更安全的方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1338) [是首先改变我们的集合
然后计算索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1340) [（避免索引失效）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1344) [值得指出的是
集合改变总会使索引无效](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1346) [这不仅适用于数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1349) [我们来看看这个问题
如何在字典中体现出来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1351) [我们假设有一个字典
其存储了一些熊最喜欢的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1354) [我们获取熊最喜爱的食物的索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1359) [并打印出来
它的确是“salmon”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1361) [接下来我们将添加更多
这只熊喜欢的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1365) [然后我们会确保熊最喜欢的食物
仍然是“salmon”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1368) [我们会看到…等一下](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1371) [熊最喜欢的食物不是“hibernation”
而是"salmon"](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1372) [就像数组一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1377) [在我们改变字典的那一刻
我们使索引无效了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1378) [在我们改变字典的那一刻
我们使索引无效了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1378) [值得指出的是
这段代码可能会崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1381) [我们该如何解决这个问题呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1385) [其实这与我们在数组中
使用的修复方法完全一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1387) [我们只需要在发生改变后
重新计算索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1391) [请记住一件事](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1394) [当你重新计算索引时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1395) [这有时会造成很大的开销](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1397) [一些索引搜索方法需要线性时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1398) [而且你只关心你所需要的那个索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1402) [所以如果你想](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1406) [避免陷入这种情况
以下是我的建议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1407) [请记住 改变集合几乎
总是使你的索引无效](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1410) [你有时可能会侥幸成功](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1413) [但最好将这视为一条硬性规则](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1416) [你最终会为此感到高兴](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1418) [还要记住切片依赖于](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1420) [其底层的原始集合的状态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1422) [即使是在它发生了改变之后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1425) [因此当底层集合是可变的时
如果你还想继续使用索引或切片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1426) [请务必三思而后行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1431) [并记住索引计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1433) [有时可能花费大量的时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1435) [（建议：索引和切片）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1437) [所以注意只在必要时才进行索引计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1439) [所以注意只在必要时才进行索引计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1439) [现在让我们来讨论一下线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1442) [我提到我问的其中一个问题是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1445) [“你的线程是否可以
由多个线程访问？”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1447) [我之所以这样问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1451) [是因为我们的集合假设](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1453) [你将从单个线程访问它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1454) [这对性能来说是一件好事](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1457) [这是因为单线程用例](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1460) [不需要花费大量资源在锁
或任何其它你用来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1462) [确保互斥的原语上面](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1466) [当涉及到线程时
只有使用集合的开发人员](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1470) [才拥有以适当的锁或串行队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1473) [限制访问所需的所有信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1475) [这些信息的抽象层次要比](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1477) [我们这些底层框架开发人员
所能提供的层次高](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1478) [我们看看这些问题会是什么样子的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1482) [假设我们有一个数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1485) [我们想将睡着的熊添加进去](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1486) [为了模拟每只熊都是独立的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1489) [并能够管理自己](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1491) [我们将访问并发调度队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1492) [我们将用它来告诉每只熊去睡觉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1496) [并且由于这是一个并发调度队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1498) [并且由于这是一个并发调度队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1498) [想象代码同时运行是很有帮助的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1500) [我将它们放在同一行上
以代表并发执行的情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1503) [稍后在app中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1507) [让我们检查一下那些睡觉的熊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1508) [有时我们会看到Grandpa
和Cub在快乐地打盹](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1511) [其他时候 Cub会先睡觉
然后才是Grandpa](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1515) [有时 非常神秘
只有Grandpa在睡觉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1519) [其他时候
则是只有Cub在睡觉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1523) [有时候 我们的程序崩溃了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1526) [并且没有熊能够睡觉](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1529) [所有这些可能性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1532) [表明存在可能的竞争条件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1533) [其实考虑到这个例子中的线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1535) [这的确有可能发生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1536) [我们可以使用Xcode中的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1541) [ThreadSanitizer
或TSan来证明这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1542) [假设我们这样做的话](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1545) [我们将得到这样的输出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1547) [TSan的确发现了竞争](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1549) [它告诉我们当前存在
Swift访问竞争](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1551) [它会告诉我们涉及哪些线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1554) [并在最后给个总结](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1557) [告诉我们应该从哪一行代码开始
寻找我们的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1558) [告诉我们应该从哪一行代码开始
寻找我们的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1558) [所有这些证据对于我们发现错误
都非常有帮助](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1562) [我们已证明这里有一个漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1566) [在我的经历中
TSan从未撒过谎](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1568) [我们可以](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1572) [通过解除熊的同时入睡能力
来解决这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1573) [我们将使用串行调度队列来实现这点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1576) [现在一次只有一只熊可以入睡](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1579) [所以如果我们现在再次查看
sleepingBears变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1581) [并在适当的队列上小心操作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1584) [我们可以看到 果然](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1587) [Grandpa和Cub
如预期的那样 平静地打瞌睡](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1589) [所以对于在多线程环境下使用集合
我的建议是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1594) [尝试隔离你的数据
以便它只能被单个线程访问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1596) [当你不能这样做时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1600) [确保你实现适当形式的互斥](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1602) [如串行调度队列或锁](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1604) [并总是使用ThreadSanitizer
来检查你的工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1607) [在app发布之前发现错误
要比之后好得多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1610) [（建议：多线程）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1614) [我对使用可变集合还有更多的建议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1615) [第一个是如果你可以避免它
就尽量不要使用可变状态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1619) [第一个是如果你可以避免它
就尽量不要使用可变状态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1619) [到目前为止我所描述的所有困难](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1624) [都是因为我们一直在使用可变状态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1626) [你可以通过避免使用可变集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1628) [来从一开始就杜绝各种可能的复杂性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1630) [很多时候 你可以通过使用切片
或惰性包装器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1633) [来模拟你想要执行的改变](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1637) [而且理解不可变数据几乎总是更容易](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1640) [多亏Swift内置的可变性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1644) [若在你没有改变状态时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1646) [却试图留下可变的状态
则编译器会帮助你进行处理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1647) [（建议：首选不可变集合）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1650) [现在我还有一条建议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1652) [关于如何在必要时
最好地使用可变状态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1654) [那就是当你正在构造新的集合时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1658) [你可以改善性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1660) [如果你碰巧知道
你所需要元素的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1661) [确切数量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1664) [或者非常好的近似值的话](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1665) [大多数集合API都能够
提供这种提示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1667) [当你这样做时
会得到所需的确切大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1671) [而且没有额外开销](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1673) [如果你不这样做
我们的集合就是通用工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1674) [它们可以在各种情况下工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1677) [随着你逐步添加元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1679) [随着你逐步添加元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1679) [你最终可能会分配比你所需要的
更多的存储空间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1681) [但请注意 在提供此类提示时
请不要高估](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1686) [否则你会发现自己处于同样的情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1689) [即你使用的存储空间比实际需要的多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1691) [现在我想继续今天的最后一个话题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1695) [当你导入foundation
集合时 你可以使用的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1698) [各种各样的集合
以及你何时应该考虑使用它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1702) [除了标准库集合之外](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1707) [当你导入foundation时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1708) [你可以访问很棒的引用类型集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1710) [它们已被Objective-C
开发人员用了几十年](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1712) [其中许多都可以兼容Swift](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1716) [因此它们与我们一直在谈论的
集合行为一致](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1719) [也就是说 有几件重要的事情
需要记住](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1722) [首先要记住的是这些NS类集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1725) [是引用类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1729) [我们通过一个例子来更好的理解这点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1730) [我们将定义值类型和引用类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1733) [并在两边对它们做同样的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1735) [对于我们的值类型
我们将它称为x](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1738) [对于我们的值类型
我们将它称为x](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1738) [它将是一个字符串数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1740) [我们得到一个名为x的空数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1742) [对于引用类型
我们得到一个空数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1745) [但x只是指向它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1747) [然后我们用数值类型来改变这个数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1749) [该数组内联地发生改变](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1752) [对于引用类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1754) [正在被引用的数组内联地发生改变](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1756) [我们创建另一个变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1761) [使用值类型时
会发生一些非常特殊的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1763) [这时我们实际上并不复制存储](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1765) [y是一个数组
但它知道它的存储实际上由x所有](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1767) [并且y实际上不会进行复制](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1772) [除非这些集合中的任何一个发生变化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1774) [引用类型有点不同](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1776) [y只是另一个
指向同一个底层数组的指针](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1778) [所以让我们继续并改变y
我们会在该数组中再放一只熊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1783) [对于值类型 所发生的事是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1786) [我们首先进行复制](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1787) [我们正在对y写入值
所以我们需要复制它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1789) [然后我们就可以插入下一个熊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1793) [对于引用 情况较为简单](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1796) [只存在一个数组
我们只是把熊猫放到数组中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1797) [只存在一个数组
我们只是把熊猫放到数组中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1797) [（值和引用集合）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1801) [在Swift中
使用foundation集合时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1803) [你需要记住的第二件事](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1805) [是Swift中的所有
Objective-C API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1809) [都以Swift原生值类型出现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1812) [这实际上非常棒
因为它允许每种语言的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1815) [自然而然使用它们各自最擅长的类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1818) [但是这如何实现呢？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1820) [这两种语言对这些集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1822) [有完全不同的实现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1824) [（SWIFT中的
OBJECTIVE-C API）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1825) [这能起作用的原因就是所谓的桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1826) [桥接是我们如何在两种不同的
运行时表示之间进行转换](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1829) [这是必要的 因为Swift
和Objective-C](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1833) [我相信你已经注意到
是非常不同的语言](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1836) [它们具有完全不同的
编译和运行时特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1838) [（桥接）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1841) [尽管我们已经优化了桥接速度
但这并不是免费的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1842) [在两种语言之间桥接时总会产生开销](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1846) [当我们桥接时会发生什么？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1850) [当我们在语言之间桥接时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1852) [我们必须先建立新的存储空间
对等的存储空间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1854) [如果你用一种语言占用N个单位](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1857) [在另一种语言中这也将占用N个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1859) [在另一种语言中这也将占用N个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1859) [然后我们需要逐个元素地
在它们之间进行转换](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1861) [并且这种按元素桥接
有时可以递归执行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1865) [比如我有一个字符串数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1867) [首先我们将桥接数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1869) [然后我们将桥接每个单独的字符串](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1870) [当这发生在两种语言的边界时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1873) [称之为“急切桥接”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1876) [当集合中的元素也需要桥接时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1878) [集合本身将总是“急切”进行桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1880) [这种情况最常出现在
以字符串作为键的字典中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1884) [当集合桥接并不急切时
我们称之为惰性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1888) [当集合元素的类型并不是桥接时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1891) [就会发生这种情况
比如NSView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1893) [在这种情况下
桥接将被推迟](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1896) [直到首次使用该集合](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1898) [让我们用一些例子来说明这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1901) [我们首先考虑一个Objective-C API
即NSArray](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1903) [NSArray被桥接到数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1907) [而NSData
被桥接到值类型的数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1909) [所以这样的集合将会被急切的桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1911) [（桥接示例）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1914) [我刚才提到NSView
没有在Swift中被桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1915) [它们在Swift中仍然是引用类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1918) [它们在Swift中仍然是引用类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1918) [所以NSArray将被延迟桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1920) [桥接不会发生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1924) [直到你第一次访问或尝试使用该数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1925) [最后 键类型为NSString的
NSDictionary](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1930) [将被急切桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1935) [因为字符串需在Swift中转换为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1937) [值类型的字符串](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1939) [现在我们知道了桥接是什么
它的原理以及何时发生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1942) [我们可以继续讨论最重要的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1945) [即你何时应该关心它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1947) [答案非常简单](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1949) [当你估计它会对你的app
产生负面影响时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1951) [具体而言 当你使用时间分析器
或追踪仪器时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1955) [要特别注意你的代码
在不同语言之间的交叉部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1958) [特别是当这发生在循环内时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1961) [少量的桥接完全没问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1964) [你所关心的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1967) [不成比例的时间
或者一个惊人的时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1968) [被花费在不是你写的代码中
并且其中包含单词“bridge”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1972) [我们来看一个具体的例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1976) [假设我正在写一本
关于儿童故事的手稿](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1978) [假设我正在写一本
关于儿童故事的手稿](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1978) [但它非常长](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1981) [所以我只会在这里展示一部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1982) [但为了让它受欢迎](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1984) [我想让每个单词“brown”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1987) [都真的显示为棕色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1990) [为了节省空间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1992) [我将只突出显示第一个单词](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1993) [为此 我将使用
NSMutableAttributedString](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1996) [我把我的故事传进去](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=1998) [然后使用属性字符串的
string属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2000) [我要得到Swift字符串
“Brown”的范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2005) [这将产生一个
字符串本地索引类型范围](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2007) [因为可变字符串
能与NSRange协同工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2011) [所以我会使用我们去年](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2013) [推出的便捷初始化器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2014) [来将其转换为NSRange](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2016) [在这里我再次调用
属性字符串的string属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2018) [来进行转换](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2023) [然后我们将为“brown”
这个词的第一个实例着色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2024) [当我运行这段代码时
我发现它有点慢](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2027) [所以我对其进行分析](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2030) [我看到 令我惊讶的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2032) [我以为大部分时间都会花在
为单词“brown”着色上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2034) [但它实际上是在计算索引](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2036) [为什么会这样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2038) [其中的原因是我们实际上正在](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2040) [两种语言间多次桥接字符串](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2042) [MutableAttributedString是一个
Objective-C引用类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2044) [所以当我们访问string属性时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2048) [我们实际上需要从NSString
转换为string](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2050) [当我们计算第一个范围时
我们在这里进行一次桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2053) [我们在转换为NSRange时
进行第二次桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2056) [你可以想象这样的开销有多大](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2060) [如果我们在一个循环中
查找所有文本以进行着色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2062) [现在我们来看看为什么
会发生这种情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2065) [每次调用text.string时
都会在Swift执行上下文中启动](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2067) [然而NSMutableAttributedString
是用Objective-C实现的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2071) [所以为了提供结果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2074) [我们实际上必须咨询其原始实现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2076) [（桥接发生时）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2079) [原始实现返回NSString
它是引用类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2080) [所以当返回到字符串时
它需要被桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2084) [逐个图像集](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2087) [逐个字符](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2090) [无论是返回类型还是参数
都会发生桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2092) [现在我们知道了这些细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2101) [我们可以做得更好一些](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2103) [我们只需桥接一次](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2106) [让我们重新测量代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2108) [并看到我们的确已将性能提高了一半](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2110) [但今年我们可以做得更好一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2113) [哦 现在我们在这里不再进行桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2116) [但今年我们可以做得更好一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2119) [今年当我们获取
text.string属性时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2121) [如果我们使用as语法
转换为NSString](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2124) [当我们得到变量时
实际上不会发生任何桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2125) [并且通过这样做
该字符串现是一个NSString](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2130) [当我们调用
range(of)属性时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2135) [我们实际上
会自动获得NSRange](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2136) [我们不需要在Swift原生类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2139) [和NSRange之间
做任何范围转换](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2141) [这非常棒](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2145) [我们来看看这段代码的效率](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2146) [这看起来很不错](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2149) [这比我们刚才耗费的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2150) [几乎800毫秒的时间要快得多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2152) [然而我想指出的是
这里仍然发生了桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2155) [这是很小的桥](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2157) [但我们仍进行了桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2159) [但我们仍进行了桥接](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2159) [这里的“brown”是一个
Swift值类型的字符串](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2161) [每当我们调用Objective-C API
中NSString的range(of)属性时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2165) [我们实际上会将这个小小的
字符串桥接回NSString](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2171) [在这种情况下它的开销不大
我只进行了一次](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2174) [但你可以想象
如果这是一个循环](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2177) [随着时间推移
这些小开销会积少成多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2179) [所以你要注意](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2181) [避免重复桥接相同的小字符串](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2182) [但在你做这样的优化之前
总是要进行测量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2185) [现在我们看过了桥接的细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2189) [我想提供些关于何时使用
foundation集合的建议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2191) [当你需要具有引用语义的集合时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2195) [你应该考虑明确使用它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2197) [你不需要自己写一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2200) [我们已经有很多很棒的集合了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2202) [当你知道你在处理引用类型时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2204) [也应该使用它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2205) [像NS代理或核心数据托管对象
之类的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2207) [最后应该考虑使用它们的情景是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2211) [当你在与Objective-C
代码之间来回切换时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2212) [但我强烈建议你
只有在测量并确定](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2215) [桥接确实是性能问题的罪魁祸首后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2217) [桥接确实是性能问题的罪魁祸首后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2217) [你才这样做](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2220) [现在我们对Swift中强大的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2223) [集合世界的探索已经接近尾声](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2226) [我希望你能够使用这种新视角](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2229) [来检视你现有的集合使用情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2231) [寻找可以通过更有效地](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2233) [使用索引和切片来改进代码的地方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2235) [测量你的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2238) [寻找你可以因惰性
或通过调整桥接方式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2240) [而受益的地方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2244) [用ThreadSanitizer
辅助审计可变状态](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2246) [并通过应用今天讨论的所有概念](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2250) [在Playground
或你自己的app中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2252) [进一步锻炼你对集合的掌握](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2254) [如果你对集合有任何疑问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2257) [请到访我们今天最后几个实验室](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2259) [我们将在那里提供帮助](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2261) [非常感谢
在实践中变得更高效吧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/229/?time=2262)