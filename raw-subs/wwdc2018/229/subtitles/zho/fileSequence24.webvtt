WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.206 --> 00:24:01.441 align:middle line:-1
所以注意只在必要时才进行索引计算

00:24:02.910 --> 00:24:05.746 align:middle line:-1
现在让我们来讨论一下线程

00:24:05.812 --> 00:24:07.481 align:middle line:-1
我提到我问的其中一个问题是

00:24:07.548 --> 00:24:10.317 align:middle line:-2
“你的线程是否可以
由多个线程访问？”

00:24:11.618 --> 00:24:12.853 align:middle line:-1
我之所以这样问

00:24:13.053 --> 00:24:14.555 align:middle line:-1
是因为我们的集合假设

00:24:14.621 --> 00:24:16.723 align:middle line:-1
你将从单个线程访问它们

00:24:17.691 --> 00:24:20.294 align:middle line:-1
这对性能来说是一件好事

00:24:20.694 --> 00:24:22.429 align:middle line:-1
这是因为单线程用例

00:24:22.496 --> 00:24:26.300 align:middle line:-2
不需要花费大量资源在锁
或任何其它你用来

00:24:26.366 --> 00:24:29.069 align:middle line:-1
确保互斥的原语上面

00:24:30.237 --> 00:24:33.140 align:middle line:-2
当涉及到线程时
只有使用集合的开发人员

00:24:33.207 --> 00:24:35.375 align:middle line:-1
才拥有以适当的锁或串行队列

00:24:35.442 --> 00:24:37.578 align:middle line:-1
限制访问所需的所有信息

00:24:37.644 --> 00:24:38.912 align:middle line:-1
这些信息的抽象层次要比

00:24:38.979 --> 00:24:41.381 align:middle line:-2
我们这些底层框架开发人员
所能提供的层次高

00:24:42.683 --> 00:24:45.285 align:middle line:-1
我们看看这些问题会是什么样子的

00:24:45.385 --> 00:24:46.486 align:middle line:-1
假设我们有一个数组

00:24:46.553 --> 00:24:48.488 align:middle line:-1
我们想将睡着的熊添加进去

00:24:49.256 --> 00:24:51.892 align:middle line:-1
为了模拟每只熊都是独立的

00:24:51.959 --> 00:24:52.793 align:middle line:-1
并能够管理自己

00:24:52.860 --> 00:24:55.362 align:middle line:-1
我们将访问并发调度队列

00:24:56.230 --> 00:24:58.232 align:middle line:-1
我们将用它来告诉每只熊去睡觉

00:24:58.899 --> 00:25:00.534 align:middle line:-1
并且由于这是一个并发调度队列

