WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:58.805 --> 00:09:00.908 align:middle line:-1
因为并非所有集合都有两个元素

00:09:02.176 --> 00:09:06.547 align:middle line:-1
我们试试这样写 self[1]

00:09:06.780 --> 00:09:10.017 align:middle line:-2
但这里我们的基于0的索引直觉
会将我们带入歧途

00:09:10.317 --> 00:09:12.386 align:middle line:-1
然后我们会再次被编译器抓个正着

00:09:13.854 --> 00:09:15.756 align:middle line:-1
我们希望此代码能够适用于每种集合

00:09:15.822 --> 00:09:18.091 align:middle line:-1
而不只是使用整数作为索引的集合

00:09:18.959 --> 00:09:20.561 align:middle line:-1
所以我们尝试一种不同的方法

00:09:21.195 --> 00:09:23.864 align:middle line:-2
我真正想要的是
比startIndex大1的索引

00:09:23.931 --> 00:09:25.566 align:middle line:-1
（找到一个集合的第二个元素）

00:09:25.632 --> 00:09:27.968 align:middle line:-1
但编译器仍不依不饶

00:09:29.102 --> 00:09:31.471 align:middle line:-1
你不能将对任意索引类型加一

00:09:31.572 --> 00:09:34.107 align:middle line:-2
索引类型应该是不透明的
或者可以是不透明的

00:09:35.576 --> 00:09:36.777 align:middle line:-1
我们在这里真正要做的

00:09:36.844 --> 00:09:39.513 align:middle line:-2
是我们需要使用
集合协议提供的API

00:09:39.580 --> 00:09:40.447 align:middle line:-1
来做到这一点

00:09:40.514 --> 00:09:41.849 align:middle line:-1
我们来试试

00:09:42.683 --> 00:09:45.519 align:middle line:-1
我注释了为了找到第二个元素

00:09:45.586 --> 00:09:46.854 align:middle line:-1
需要做的事情的框架

00:09:47.187 --> 00:09:48.422 align:middle line:-1
我们需要做的第一件事是

00:09:48.488 --> 00:09:50.691 align:middle line:-1
我们需要检查集合是否为空

00:09:51.024 --> 00:09:52.526 align:middle line:-1
集合在其startIndex

00:09:52.593 --> 00:09:54.561 align:middle line:-1
等于endIndex时为空

00:09:54.862 --> 00:09:56.763 align:middle line:-1
所以我们来检查一下并返回nil

00:09:57.431 --> 00:10:00.901 align:middle line:-1
因为这样的集合没有第二个元素

