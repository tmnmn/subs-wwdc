WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:59.126 --> 00:31:00.827 align:middle line:-1
在另一种语言中这也将占用N个

00:31:01.128 --> 00:31:05.032 align:middle line:-2
然后我们需要逐个元素地
在它们之间进行转换

00:31:05.098 --> 00:31:07.568 align:middle line:-2
并且这种按元素桥接
有时可以递归执行

00:31:07.634 --> 00:31:09.536 align:middle line:-1
比如我有一个字符串数组

00:31:09.603 --> 00:31:10.704 align:middle line:-1
首先我们将桥接数组

00:31:10.771 --> 00:31:12.840 align:middle line:-1
然后我们将桥接每个单独的字符串

00:31:13.941 --> 00:31:16.176 align:middle line:-1
当这发生在两种语言的边界时

00:31:16.243 --> 00:31:17.411 align:middle line:-1
称之为“急切桥接”

00:31:18.812 --> 00:31:20.681 align:middle line:-1
当集合中的元素也需要桥接时

00:31:20.747 --> 00:31:23.584 align:middle line:-1
集合本身将总是“急切”进行桥接

00:31:24.151 --> 00:31:27.321 align:middle line:-2
这种情况最常出现在
以字符串作为键的字典中

00:31:28.789 --> 00:31:31.325 align:middle line:-2
当集合桥接并不急切时
我们称之为惰性

00:31:31.658 --> 00:31:33.627 align:middle line:-1
当集合元素的类型并不是桥接时

00:31:33.694 --> 00:31:36.230 align:middle line:-2
就会发生这种情况
比如NSView

00:31:36.463 --> 00:31:38.298 align:middle line:-2
在这种情况下
桥接将被推迟

00:31:38.365 --> 00:31:40.701 align:middle line:-1
直到首次使用该集合

00:31:41.435 --> 00:31:43.437 align:middle line:-1
让我们用一些例子来说明这个问题

00:31:43.637 --> 00:31:47.074 align:middle line:-2
我们首先考虑一个Objective-C API
即NSArray

00:31:47.808 --> 00:31:49.643 align:middle line:-1
NSArray被桥接到数组

00:31:49.710 --> 00:31:51.845 align:middle line:-2
而NSData
被桥接到值类型的数据

00:31:51.979 --> 00:31:54.381 align:middle line:-1
所以这样的集合将会被急切的桥接

00:31:54.448 --> 00:31:55.649 align:middle line:-1
（桥接示例）

00:31:55.716 --> 00:31:58.352 align:middle line:-2
我刚才提到NSView
没有在Swift中被桥接

00:31:58.418 --> 00:32:00.554 align:middle line:-1
它们在Swift中仍然是引用类型

