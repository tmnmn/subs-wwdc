WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:01.201 --> 00:15:03.837 align:middle line:-1
就这点而言 切片有点像延迟拷贝

00:15:04.204 --> 00:15:05.205 align:middle line:-1
你可以选择

00:15:05.572 --> 00:15:07.574 align:middle line:-1
何时自己创建元素的副本

00:15:08.242 --> 00:15:11.478 align:middle line:-2
事实证明 这种“懒”行为
和延迟做某事的概念

00:15:12.179 --> 00:15:14.114 align:middle line:-1
在其他情况下也非常有用

00:15:15.516 --> 00:15:17.684 align:middle line:-1
其中一种情况是函数调用

00:15:17.751 --> 00:15:18.719 align:middle line:-1
（“急切的”函数）

00:15:18.785 --> 00:15:21.321 align:middle line:-2
默认情况下 Swift中的
函数调用是"急切的"

00:15:22.022 --> 00:15:26.126 align:middle line:-2
也就是说 它们接收了输入
并按照要求返回它们的输出

00:15:27.261 --> 00:15:28.328 align:middle line:-1
考虑这个例子

00:15:28.529 --> 00:15:30.397 align:middle line:-2
我们从一个1到4,000
的Range开始

00:15:30.664 --> 00:15:33.767 align:middle line:-2
Range是代表大量数字的
一种非常简洁的方式

00:15:33.867 --> 00:15:36.637 align:middle line:-2
它只需要首和尾
就能够知道如何生成它们

00:15:37.271 --> 00:15:39.706 align:middle line:-1
我们将其映射为每个值乘以2

00:15:39.773 --> 00:15:42.543 align:middle line:-2
所以我们现在已经分配了
包含4000个元素的数组

00:15:42.743 --> 00:15:45.612 align:middle line:-2
并在它们中的每一个上
执行我们的映射函数

00:15:46.413 --> 00:15:48.282 align:middle line:-1
然后我们将过滤出四个元素

00:15:48.815 --> 00:15:50.317 align:middle line:-1
迄今为止 我们已经

00:15:50.384 --> 00:15:54.988 align:middle line:-1
分配了4,004个元素的空间

00:15:56.156 --> 00:15:57.991 align:middle line:-1
但我们只需要最后四个

