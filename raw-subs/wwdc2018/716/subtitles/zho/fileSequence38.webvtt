WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:58.545 --> 00:38:01.048 align:middle line:-2
一个不幸的答案是
没有一种方法

00:38:01.114 --> 00:38:03.851 align:middle line:-2
适合所有的解决方案
但你可以尝试一些事情

00:38:04.151 --> 00:38:05.919 align:middle line:-1
首先 分别尝试快速和准确算法

00:38:05.986 --> 00:38:09.189 align:middle line:-1
从而弄清楚你的特定用例

00:38:09.256 --> 00:38:11.325 align:middle line:-1
更适合使用哪种算法

00:38:15.162 --> 00:38:17.264 align:middle line:-1
如果由你来手动选择边界框

00:38:17.798 --> 00:38:21.068 align:middle line:-1
请尝试在场景中找到一个明显的对象

00:38:22.870 --> 00:38:24.338 align:middle line:-1
该使用多大的置信度阈值

00:38:25.239 --> 00:38:26.940 align:middle line:-1
同样 这里也没有唯一的标准

00:38:27.174 --> 00:38:29.643 align:middle line:-1
你会发现某些用例可以使用某些阈值

00:38:29.710 --> 00:38:32.746 align:middle line:-1
而其它用例只能使用其它阈值

00:38:34.948 --> 00:38:36.984 align:middle line:0
还有一种我推荐的技术

00:38:37.050 --> 00:38:38.719 align:middle line:0
假设你有一个很长的跟踪序列

00:38:38.785 --> 00:38:40.921 align:middle line:0
举个例子 它有1000帧

00:38:42.155 --> 00:38:44.224 align:middle line:0
如果你开始跟踪序列

00:38:44.525 --> 00:38:47.828 align:middle line:0
你在第一帧中选择的对象将开始偏离

00:38:47.895 --> 00:38:53.567 align:middle line:0
你离开那个初始帧越远
它的改变就越大

00:38:54.234 --> 00:38:57.838 align:middle line:0
你可以做的是把那个序列
分成更小的子序列

00:38:57.905 --> 00:38:59.139 align:middle line:0
比如每个50帧

00:38:59.640 --> 00:39:02.943 align:middle line:0
你运行检测器
并在接下来的50帧跟踪该对象

