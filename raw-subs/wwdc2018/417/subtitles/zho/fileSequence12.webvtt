WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:00.120 --> 00:12:02.456 align:middle line:-1
当你遇到测试失败时

00:12:02.523 --> 00:12:04.925 align:middle line:-1
很难知道从哪里开始

00:12:04.992 --> 00:12:06.193 align:middle line:-1
寻找问题的根源

00:12:07.928 --> 00:12:10.731 align:middle line:-2
我们最近在测试中
帮助缓解这种情况的一件事是

00:12:11.298 --> 00:12:13.867 align:middle line:-1
设置一个模拟服务器的本地实例

00:12:14.301 --> 00:12:18.639 align:middle line:-2
中断我们的UI测试来对其发出请求
而不是对真正的服务器进行请求

00:12:19.706 --> 00:12:22.309 align:middle line:-1
这使得我们的UI测试更加可靠

00:12:22.376 --> 00:12:25.512 align:middle line:-2
因为我们可以控制
反馈到app中的数据

00:12:28.649 --> 00:12:31.785 align:middle line:-2
虽然在这个上下文中
使用模拟服务器是非常有用的

00:12:32.186 --> 00:12:35.989 align:middle line:-2
但是让一些测试针对真正的
服务器发出请求也是很好的

00:12:38.926 --> 00:12:40.561 align:middle line:-1
其一种很酷的技术就是

00:12:40.627 --> 00:12:43.230 align:middle line:-1
可以在单元测试包中进行一些测试

00:12:43.497 --> 00:12:46.233 align:middle line:-2
直接调用
在Stack中工作的app

00:12:47.000 --> 00:12:49.770 align:middle line:-2
并使用这些测试
将请求指向真正的服务器

00:12:51.071 --> 00:12:54.908 align:middle line:-2
这提供了一种验证服务器
接受请求的方式

00:12:54.975 --> 00:12:56.643 align:middle line:-1
是否与app的方式相同的方法

00:12:57.544 --> 00:12:59.847 align:middle line:-1
并且你可以解析服务器的响应

