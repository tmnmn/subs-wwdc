WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:57.771 --> 00:09:00.107 align:middle line:-1
是以时间为基准

00:09:00.174 --> 00:09:01.475 align:middle line:-1
刷新显示内容

00:09:02.109 --> 00:09:04.811 align:middle line:-1
这将确保用户看到的内容

00:09:04.878 --> 00:09:07.814 align:middle line:-1
尽可能最新并没有干扰

00:09:09.249 --> 00:09:11.118 align:middle line:-1
这不是个低能耗的方案

00:09:12.019 --> 00:09:13.453 align:middle line:-1
我们想想为什么

00:09:14.888 --> 00:09:18.625 align:middle line:-1
如果为方案画出耗能时间曲线

00:09:19.059 --> 00:09:21.094 align:middle line:-1
能看到每次绘图时

00:09:21.395 --> 00:09:23.964 align:middle line:-1
就要消耗一些激活能量

00:09:25.199 --> 00:09:28.669 align:middle line:-1
但真正重要的在于有大量的开销

00:09:29.503 --> 00:09:33.040 align:middle line:-1
因为每次请求显示新内容时

00:09:33.106 --> 00:09:36.944 align:middle line:-2
很可能要调用网络
绘图、处理等子系统

00:09:37.010 --> 00:09:39.947 align:middle line:-1
处理这些任务并显示内容

00:09:40.013 --> 00:09:41.748 align:middle line:-1
而用户未必想要这个

00:09:42.282 --> 00:09:44.751 align:middle line:-1
我们会在app运行时

00:09:44.818 --> 00:09:46.053 align:middle line:-1
持续大量耗能

00:09:47.354 --> 00:09:48.188 align:middle line:-1
我们能做得更好

00:09:49.656 --> 00:09:51.758 align:middle line:-1
如果考虑用户实际想要的

00:09:51.825 --> 00:09:52.759 align:middle line:-1
刷新内容

00:09:53.160 --> 00:09:55.996 align:middle line:-1
我们能实现一个贴合需求的方案

00:09:57.231 --> 00:09:58.732 align:middle line:0
新方案里

00:09:58.799 --> 00:10:01.902 align:middle line:0
用户交互或者某类服务器通知

