WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.733 --> 00:15:01.568 align:middle line:-1
然而我们在这里可以看到峰值

00:15:02.035 --> 00:15:04.905 align:middle line:-1
当新行即将进入滚动视图时

00:15:05.973 --> 00:15:10.310 align:middle line:-2
我们会看到较高的CPU使用率
然后再回到较低的水平

00:15:12.279 --> 00:15:16.950 align:middle line:-2
我们可以使用两种技术
来平滑我们的CPU使用率

00:15:17.584 --> 00:15:18.819 align:middle line:-1
第一个是预取

00:15:19.753 --> 00:15:23.190 align:middle line:-1
如果你想知道更多关于预取的知识

00:15:23.257 --> 00:15:26.894 align:middle line:-2
可以观看今年WWDC中的演讲
“CollectionView一览”

00:15:27.461 --> 00:15:28.862 align:middle line:-1
这里的基本思想

00:15:28.929 --> 00:15:33.267 align:middle line:-2
是预取允许CollectionView
告知我们的数据源

00:15:33.700 --> 00:15:37.905 align:middle line:-2
它当前不需要一个单元格
但它将在不久的将来需要

00:15:37.971 --> 00:15:40.607 align:middle line:-2
因此如果你有任何工作要做
也许现在就可以提前开始

00:15:41.375 --> 00:15:44.044 align:middle line:-2
这允许我们随时间推移
分摊CPU使用率

00:15:45.279 --> 00:15:47.848 align:middle line:-2
因此我们减少了CPU使用的
峰值大小

00:15:49.650 --> 00:15:52.653 align:middle line:-2
我们可以使用的另一种技术
是在后台执行工作

00:15:53.287 --> 00:15:55.155 align:middle line:-1
既然我们已经随时间分散了工作量

00:15:55.222 --> 00:15:57.858 align:middle line:-2
我们也可以将这些工作
分散到可用的CPU上

