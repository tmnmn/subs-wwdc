WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:59.693 --> 00:06:03.897 align:middle line:-2
包含图像文件的数据缓冲区
通常以某些元数据开头

00:06:03.964 --> 00:06:06.967 align:middle line:-2
这些元数据描述了
存储在数据缓冲区中的图像大小

00:06:07.935 --> 00:06:10.103 align:middle line:-1
然后 包含图像数据本身

00:06:10.170 --> 00:06:14.508 align:middle line:-2
图像数据以某种形式编码
如JPEG压缩或PNG

00:06:16.143 --> 00:06:19.379 align:middle line:-1
这意味着该元数据后面的字节

00:06:19.646 --> 00:06:23.851 align:middle line:-2
实际上并不直接描述图像中
像素的任何内容

00:06:26.987 --> 00:06:30.490 align:middle line:-2
因此 我们可以深入了解一下
我们设置的这条管道

00:06:30.958 --> 00:06:32.626 align:middle line:-1
这里有一个UIImageView

00:06:32.693 --> 00:06:34.795 align:middle line:-2
并且我们已经突出显示了
帧缓冲区的区域

00:06:34.862 --> 00:06:38.165 align:middle line:-1
这块区域将由图像视图进行渲染填充

00:06:38.699 --> 00:06:41.034 align:middle line:-2
我们已经为这个图像视图
分配了一个UIImage

00:06:41.101 --> 00:06:42.236 align:middle line:-1
（管道实战）

00:06:42.302 --> 00:06:45.606 align:middle line:-2
它有一个表示图像文件内容的
数据缓冲区

00:06:45.672 --> 00:06:48.509 align:middle line:-1
其可能是从网络下载或从磁盘读取的

00:06:49.343 --> 00:06:54.348 align:middle line:-2
但我们需要用每个像素的数据
来填充帧缓冲区

00:06:55.382 --> 00:06:56.517 align:middle line:-1
为了做到这一点

00:06:57.184 --> 00:07:00.087 align:middle line:-2
UIImage将分配
一个图像缓冲区

