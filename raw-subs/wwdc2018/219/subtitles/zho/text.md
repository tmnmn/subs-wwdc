# Image and Graphics Best Practices

## Summary
Whether it's for UI elements or a fundamental part of your application, at some point, you have to handle images. This session is packed with engaging insight into how images are handled in iOS including discussion of UIImage, UIImageView, custom drawing in UIKit, plus advanced CPU and GPU techniques that can help you maximize performance and minimize memory footprint.

## Info
* Media
* WWDC 2018 - Session 219 - iOS
* https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/

## Text
 [（图像和图形最佳实践
演讲219）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=16) [大家好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=24) [欢迎来到图像和图形最佳实践](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=26) [我叫Kyle 我在UIKit工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=28) [今天我将与你分享关于如何](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=31) [在你的app中高效使用图形内容的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=33) [一些技术以及策略](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=35) [我们将浏览整个框架栈](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=39) [首先 我们将从UIImage
和UIImageView开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=41) [这些都是UIKit的高级工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=45) [用于在你的app中使用图形内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=47) [接着我们将重点关注
如何在你的app中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=51) [使用UIKit最优地
进行自定义绘图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=55) [最后 我们将简要地介绍一下](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=57) [如何将先进的CPU和GPU技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=60) [集成到你的app中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=64) [在整个演讲中 我们将主要关注](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=66) [如何使用设备上的两个稀缺资源
内存和CPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=69) [我们倾向于将这些东西视为
具有各自独立的数量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=76) [它们在调试导航栏中
有各自独立的跟踪指标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=79) [它们在工具app中
拥有各自独立的工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=82) [但实际上
它们错综复杂地联系在一起](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=85) [很明显
当你的app使用更多的CPU时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=89) [将会对电池寿命和
app的响应能力](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=94) [具有负面的影响](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=97) [但可能不那么明显的是
随着你的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=100) [和系统上的其他app消耗更多内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=104) [也会导致更高的CPU使用率](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=108) [这对电池寿命和性能
有进一步的不利影响](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=111) [因此 我们将重点关注
如何改进对这些资源的使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=116) [讨论这个问题还能有什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=121) [比一个需要处理大量
图像内容的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=123) [更好的背景呢
比如Photos app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=126) [你看 我们正在这里编辑一张照片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=130) [正如我之前提到的
UIImages、UIKits](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=132) [都是用于处理图像数据的高级类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=135) [我们用一个UIImage
代表这个富内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=138) [我们倾向于将app中的图形内容
分为两类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=143) [富内容 如这张照片
以及图标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=147) [UIImage也是
UIKit中的数据类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=151) [用来表示某些事物
例如显示在此按钮中的图标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=154) [如前所述](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=159) [UIImageView
是UIKit提供](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=162) [用于显示UIImage的类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=165) [若采用经典的MVC模型进行类比](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=170) [UIImage可以被看作模型对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=172) [当然 正如名称所暗示
UIImageView是一个视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=175) [而这些对象作为模型和视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=179) [而这些对象作为模型和视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=179) [肩负着其在经典模型中的责任](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=182) [UIImage负责加载图片内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=184) [UIImageView
负责显示和渲染它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=188) [现在 我们可以将其理解为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=193) [我们建立的简单关系](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=195) [这是一种单向关系](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=197) [但实际情况却比这复杂一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=199) [除了渲染是一个连续的过程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=203) [而不是一次性事件之外](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=206) [这里的理解其实有一个隐藏的阶段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=208) [对衡量app的性能至关重要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=212) [这个阶段被称为解码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=215) [但为了讨论解码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=217) [我首先需要讨论
一个叫做“缓冲区”的概念](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=219) [缓冲区只是一段连续的内存区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=223) [但我们倾向于使用术语“缓冲区”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=226) [来表示由一系列元素组成的内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=228) [这些元素具有相同尺寸
并通常具有相同的内部结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=232) [而我们关注的重点
是其中一种非常重要的缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=237) [而我们关注的重点
是其中一种非常重要的缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=237) [即图像缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=241) [我们用这个术语](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=242) [来表示一种特定缓冲区
它保存了某些图像在内存中的表示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=244) [此缓冲区的每个元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=248) [描述了图像中
每个像素的颜色和透明度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=250) [因此这个缓冲区在内存中的大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=257) [与它包含的图像大小成正比](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=260) [缓冲区的一个特别重要的例子
是帧缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=265) [帧缓冲区负责在你的app中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=271) [保存实际渲染后的输出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=274) [因此 当你的app更新
其视图层次结构时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=276) [UIKit将重新渲染app的窗口
及其所有子视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=280) [到帧缓冲区中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=284) [该帧缓冲区提供每个像素的颜色信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=287) [显示硬件将读取这些信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=290) [以便点亮显示器上对应的像素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=292) [（图像缓冲区）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=295) [最后一部分以固定的时间间隔发生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=298) [最后一部分以固定的时间间隔发生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=298) [它可能以每秒60帧的频率发生
即每1/60秒发生一次](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=301) [或在配备ProMotion
Display的iPad上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=305) [它的速度可以达到
每1/120秒发生一次](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=308) [如果你的app中没有任何改变
则显示硬件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=313) [会将它上次看到的相同的数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=317) [从帧缓冲区中取出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=319) [但是当你改变](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=321) [app中视图的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=324) [例如 你为图像视图指定
一个新的UIImage](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=326) [UIKit将重新渲染
你的app窗口](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=331) [并将其放入帧缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=334) [下一次显示硬件从帧缓冲区中取出时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=335) [它将会得到你的新内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=338) [现在 你可以将图像缓冲区
与另一种“数据缓冲区”进行对比](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=341) [这只是一种包含一系列字节的缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=346) [在我们的例子中 我们关心的是
包含图像文件的数据缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=349) [也许我们已经从网络上下载了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=354) [或者我们从磁盘加载它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=356) [（数据缓冲区）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=358) [包含图像文件的数据缓冲区
通常以某些元数据开头](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=359) [包含图像文件的数据缓冲区
通常以某些元数据开头](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=359) [这些元数据描述了
存储在数据缓冲区中的图像大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=363) [然后 包含图像数据本身](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=367) [图像数据以某种形式编码
如JPEG压缩或PNG](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=370) [这意味着该元数据后面的字节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=376) [实际上并不直接描述图像中
像素的任何内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=379) [因此 我们可以深入了解一下
我们设置的这条管道](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=386) [这里有一个UIImageView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=390) [并且我们已经突出显示了
帧缓冲区的区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=392) [这块区域将由图像视图进行渲染填充](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=394) [我们已经为这个图像视图
分配了一个UIImage](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=398) [（管道实战）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=401) [它有一个表示图像文件内容的
数据缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=402) [其可能是从网络下载或从磁盘读取的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=405) [但我们需要用每个像素的数据
来填充帧缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=409) [为了做到这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=415) [UIImage将分配
一个图像缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=417) [UIImage将分配
一个图像缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=417) [其大小等于包含在数据缓冲区中的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=420) [图像的大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=423) [并执行称为解码的操作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=425) [这将JPEG或PNG
或其他编码的图像数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=428) [转换为每个像素的图像信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=433) [然后 取决于我们的图像视图
的内容模式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=437) [当UIKit要求
图像视图进行渲染时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=440) [它会在将数据复制到帧缓冲区
的过程中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=443) [对来自图像缓冲区的数据
进行复制和缩放](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=448) [现在 解码阶段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=452) [是CPU密集型的
特别是对于大型图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=454) [因此 不是每次UIKit要求
图像视图渲染时都执行一次这个过程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=458) [UIImage绑定在图像缓冲区上
所以它只执行一次这个过程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=463) [因此 你的app
对于每个被解码的图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=469) [都可能会持续存在大量的内存分配](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=473) [（解码注意事项）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=476) [正如我前面提到的那样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=477) [正如我前面提到的那样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=477) [这种内存分配与输入图像的大小
成正比](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=480) [而与帧缓冲区中实际渲染的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=483) [图像视图的大小没有必然联系](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=485) [而这会对性能
产生一些相当不利的后果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=488) [app地址空间中的大块内存分配](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=492) [可能会迫使其他相关内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=496) [远离它想要引用的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=499) [这种情况被称为碎片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=502) [（滥用内存的后果）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=503) [最终 如果你的app开始
占用越来越多的内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=505) [操作系统将会介入](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=510) [并开始透明地压缩物理内存的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=511) [CPU需要参与这个操作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=516) [因此 除了你自己的app
对CPU资源的使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=519) [你可能会增加你无法控制的
全局CPU使用率](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=523) [最终 你的app可能会
消耗过多的物理内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=528) [以至于操作系统需要启动终止进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=533) [它将从低优先级的后台进程开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=536) [最终 如果你的app消耗了
达到特定数量的内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=540) [你的app本身可能会被终止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=543) [而其中被终止的后台进程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=546) [可能正代表用户执行某些重要工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=547) [因此 它们可能一终止就立即
重新启动](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=549) [所以 即使你的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=553) [可能只会在短时间内消耗内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=555) [它也可能对CPU使用率
产生深远的影响](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=558) [因此 我们希望减少app的
内存使用量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=564) [我们可以用一种称为向下采样的技术
来实现这一目标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=567) [现在 我们来看一下
图像渲染管道的更多细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=572) [包括我们要在其中显示图像的
图像视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=576) [实际上比要显示的图像小的这一事实](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=580) [通常
Core Animation框架](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=584) [在渲染阶段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=587) [将负责缩小该图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=590) [但我们可以通过使用这种下采样技术
来节省一些内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=592) [本质上 我们要做的就是捕捉
该缩小的操作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=596) [并将其放入缩略图的对象中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=600) [最终我们将会降低内存开销](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=603) [因为我们将有一个较小的
解码图像缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=608) [这样 我们设置了一个图像源
创建了一个缩略图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=612) [然后将解码图像缓冲区
捕获到UIImage中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=616) [并将该UIImage
分配给我们的图像视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=620) [接着 我们就可以丢弃原来的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=623) [包含我们图片的数据缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=625) [其结果是我们的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=626) [将具有一个更小的长期内存占用足迹](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=630) [执行该操作的代码有几个步骤
我会带你们过一遍这个流程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=631) [我不打算讲述非常低级的细节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=635) [但我会重点介绍一些重要的部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=637) [首先 我们要创建一个
CGImageSource对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=640) [CGImageSourceCreate
可以接受一个选项字典参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=644) [我们这里要传递的重要选项参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=647) [是这个ShouldCache标志](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=649) [这就告诉了
Core Graphics框架](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=652) [我们只是在创建一个对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=654) [来表示存储在该URL的
文件中的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=655) [来表示存储在该URL的
文件中的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=655) [不要立即解码这个图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=661) [只需创建一个表示它的对象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=664) [我们将需要来自此URL的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=666) [然后 我们将在水平和垂直轴上
进行计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=671) [该计算基于期望的图片大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=674) [以及我们要渲染的像素和点大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=676) [这是以像素为单位的较大维度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=679) [计算这些信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=682) [然后为我们的缩略图
创建一个选项字典](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=684) [这里列出了几个选项](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=688) [你可以在文档中
查看这些选项的具体含义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=690) [但非常重要的是
这个CacheImmediately选项](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=692) [通过在这里传递这个选项
我们告诉Core Graphics](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=698) [当我要求你创建缩略图时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=701) [这就是你应该为我创建
解码图像缓冲区的确切时刻](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=704) [因此我们可以确切地控制](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=709) [何时调用CPU来进行解码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=710) [接着我们创建缩略图
即我们拿到所返回的CGImage](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=716) [接着我们创建缩略图
即我们拿到所返回的CGImage](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=716) [将其包装在UIImage中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=720) [从我们在此编写的
辅助函数中返回](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=722) [为了让你了解这项技术
为我们节省的开销数量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=725) [我们只在这里显示全屏图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=729) [这是一张大小为
3000 x 2000像素的照片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=731) [如果我们不做优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=734) [只是将UIImageView放入
Storyboard并将图片分配给它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=735) [这个app占用了31.5兆
却没有做任何事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=740) [现在 使用这种下采样技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=745) [并且只创建一个实际显示大小的
图像缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=747) [我们可以得到这个app的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=752) [内存使用情况
其降至18.4兆](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=753) [这大大减少了内存使用量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=756) [谢谢大家 但你们都应该
因在自己的app中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=764) [使用此技术而得到掌声](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=766) [你可以想象这对于一个
需要在屏幕上的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=769) [一小块空间里显示大量
可能很大输入图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=772) [的app来说有多么重要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=776) [例如Camera Roll](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=779) [例如Camera Roll](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=779) [你可以使用UICollectionView
来实现这样的视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=782) [因此我们为indexPath中
item实现了单元格](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=785) [并且我们使用之前写的辅助函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=789) [将图像向下采样使之缩小到
当单元格实际放在屏幕上时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=791) [它们将要显示的大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=795) [你认为这是一件很好的事情 对吧？](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=799) [我们实际上减少了内存的使用量
而不是允许系统中存在](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=802) [这些大的内存区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=805) [不幸的是 这并不能解决我们的
另一个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=807) [这些问题在可滚动视图 比如
表视图和集合视图中是很常见的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=810) [你可能曾经见过这种情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=815) [你在app中滚动页面
而在滚动过程中页面发生了粘连](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=817) [这里发生的情况是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=821) [当我们滚动页面时
CPU相对比较空闲](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=822) [或它所做的工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=829) [可以在显示硬件需要帧缓冲的
下一个副本之前完成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=830) [所以当帧缓冲区被更新时
我们能够看到流动的效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=835) [并且显示硬件能够及时获得新帧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=839) [并且显示硬件能够及时获得新帧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=839) [但现在 我们即将显示另一行图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=843) [在将单元格交回
UICollectionView之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=846) [我们要求Core Graphics
解码这些图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=850) [这将会花费很长的CPU时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=853) [以至于我们不得不重新渲染帧缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=856) [但显示器硬件按固定的时间间隔运行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=860) [因此 从用户的角度来看
app好像卡住了一样](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=863) [在可滚动视图中进行解码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=867) [我们完成了对图像的解码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=869) [我们可以将单元格提供给
UICollectionView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=870) [和以前一样 动画继续](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=875) [刚刚在那里看到了一个粘连](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=877) [现在 除了这种行为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=880) [明显的响应性后果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=882) [其对电池寿命有更细微的不利影响](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=885) [因为iOS非常擅长管理
当CPU需求相对平稳持续时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=890) [对电池的电量需求](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=895) [然而我们在这里可以看到峰值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=899) [然而我们在这里可以看到峰值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=899) [当新行即将进入滚动视图时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=902) [我们会看到较高的CPU使用率
然后再回到较低的水平](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=905) [我们可以使用两种技术
来平滑我们的CPU使用率](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=912) [第一个是预取](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=917) [如果你想知道更多关于预取的知识](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=919) [可以观看今年WWDC中的演讲
“CollectionView一览”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=923) [这里的基本思想](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=927) [是预取允许CollectionView
告知我们的数据源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=928) [它当前不需要一个单元格
但它将在不久的将来需要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=933) [因此如果你有任何工作要做
也许现在就可以提前开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=937) [这允许我们随时间推移
分摊CPU使用率](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=941) [因此我们减少了CPU使用的
峰值大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=945) [我们可以使用的另一种技术
是在后台执行工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=949) [既然我们已经随时间分散了工作量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=953) [我们也可以将这些工作
分散到可用的CPU上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=955) [这样做的效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=961) [是你的app具有更强的响应能力](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=962) [并且该设备具有更长的电池寿命](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=965) [为了在这里进行实际演示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=969) [我们已经在数据源上实现了预取方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=971) [它将会调用我们的辅助函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=976) [来生成我们将要在
CollectionView单元格中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=978) [所显示图片的下采样版本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=981) [它通过将工作分派到
其中一个全局异步队列来完成此任务](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=987) [很好 我们的工作正在后台进行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=993) [这就是我们想要做的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=995) [但这里有一个潜在的缺陷](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=997) [这是一个我们喜欢称之为
线程爆炸的现象](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1000) [当我们要求系统去做
比CPU能够做的工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1004) [更多的工作时就会发生这种情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1008) [如果我们要显示大量的图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1011) [比如同时显示6张或8张图片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1013) [但是我们在只有两个CPU的
设备上运行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1015) [我们不能一次完成所有这些工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1018) [我们不能一次完成所有这些工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1018) [我们无法在不存在的CPU上
进行并行处理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1020) [（线程爆炸）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1023) [现在 为了避免](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1025) [向一个全局队列中
异步的分配任务时发生死锁](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1026) [GCD将创建新线程来捕捉
我们要求它所做的工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1030) [然后 CPU将花费大量时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1036) [在这些线程之间进行切换](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1038) [尝试在所有工作上取得我们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1040) [要求操作系统为我们做的渐进式进展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1043) [在这些线程之间不停切换](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1045) [实际上是相当大的开销](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1047) [如果有一个或多个CPU有机会](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1051) [一次处理完图片 效果会更好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1054) [因此 我们将借鉴去年的
“现代化中心调度GCD用法”](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1059) [演讲中所提出的一项技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1063) [我们将同步一些工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1066) [抱歉 不是同步
我们要序列化一些工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1068) [因此 我们现在不是简单地
将工作分派到全局异步队列之一](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1072) [而是创建一个串行队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1078) [并且在预取方法的实现中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1081) [我们异步地将工作分派到该队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1085) [它的确意味着单个图像的加载](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1087) [可能要比以前晚才能开始取得进展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1090) [但这也意味着CPU将花费更少时间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1093) [在它可以做的小任务之间来回切换](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1097) [（图片来源）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1099) [我们显示的这些图像
可能来自多个地方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1101) [它们可能是随app附带的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1105) [在这种情况下
它们可以存储在图像素材中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1108) [或者可能存储在一个文件中
而不是我们的程序包中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1110) [或者它们可能来自网络](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1113) [或者是在app的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1115) [文档目录的文档中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1117) [它们可以存储在缓存中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1121) [但是对于你的app所附带的图片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1123) [我们强烈建议你使用
图像素材来存储](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1126) [这其中有很多原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1131) [图像素材针对基于名称和
基于特征的查找进行了优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1134) [在素材目录中查找图片资源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1138) [在素材目录中查找图片资源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1138) [会比搜索具有特定命名格式的
磁盘上的文件要快得多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1141) [（预置图像素材）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1144) [素材目录运行时在管理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1146) [缓冲区大小方面也非常智能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1150) [还有一些与运行时性能无关的特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1153) [是图像素材独有的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1157) [包括针对不同设备瘦身的功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1159) [这意味着你的app只下载](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1161) [与其所运行的设备相关的图像资源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1164) [还有矢量图形功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1167) [矢量图形是iOS 11中
引入的一项功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1170) [你可以在图像素材编辑器中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1173) [选中“保留矢量数据”
复选框来启用它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1177) [其效果是如果你的图像
在图像视图的渲染中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1180) [大于或小于图像的原始大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1184) [它也不会变得模糊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1187) [这种图像实际上是从矢量图形
重新栅格化的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1189) [因此它具有很好的边缘清晰度](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1192) [我们在操作系统中的一个地方
使用了这种技术](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1195) [若你在Accessibility
设置中调整动态类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1198) [若你在Accessibility
设置中调整动态类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1198) [到一个非常大的尺寸](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1201) [然后点击并按住标签栏中的项目](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1203) [将会出现一个小HUD](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1207) [显示当前你的手指所按住
物体的放大视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1210) [因此如果你希望你的图片在这样的
情境下看起来效果更好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1214) [那就选中图像素材管理器中的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1218) [“保留向量插图”复选框](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1221) [抱歉 应该是
“保留矢量数据”复选框](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1223) [它的工作方式与我们之前看到的
管道非常相似](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1226) [只是这里不是一个解码阶段
而是一个栅格化阶段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1230) [其负责获取矢量数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1234) [并将其转换为可复制到
帧缓冲区的位图数据](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1237) [（矢量图形管道）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1241) [（矢量图形优化）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1243) [如果我们必须为你的app中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1245) [所有矢量图形进行这项操作
我们会消耗更多的CPU资源](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1246) [因此我们在这里做了一个优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1250) [如果你有一张选中了
“保留矢量数据”的图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1253) [但你以正常尺寸渲染它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1257) [实际上素材目录编译器已经生成了
那个图片的预栅格化版本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1261) [并将其存储在素材目录中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1266) [因此并不需要做复杂的数学运算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1269) [来将矢量图形栅格化为位图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1272) [我们可以直接解码
存储在素材目录中的图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1275) [并将其直接渲染到帧缓冲区中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1279) [如果你计划以几种固定大小呈现图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1284) [比如你有一个小图标和一个大图标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1289) [你不需要依赖
“保留矢量数据”复选框](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1293) [只需创建这两种你预先确定好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1297) [需要渲染的尺寸的图片素材](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1301) [这将允许在编译期](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1304) [调用CPU对你的图片进行栅格化
从而达到优化的效果](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1307) [而不是每次将图像复制到帧缓冲区时
都进行计算](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1312) [我们已经看到了如何使用
UIImage和UIImageView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1318) [我们已经看到了如何使用
UIImage和UIImageView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1318) [但你的app所做的图形工作
不止这些](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1322) [有时 app在运行时绘制内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1325) [这种情况的例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1332) [可以在如Photos app中的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1334) [编辑视图中看到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1337) [这个UIButton显示了一个图标
并且UIButton可以直接使用UIImageView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1341) [但是UIButton在这里不支持
这个Live按钮的风格](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1348) [以实现点击
以启用或禁用Live Photo](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1352) [因此我们自己将不得不
在这里做一些工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1356) [这里一个可能的实现是
继承UIView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1359) [并实现draw方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1363) [这里的这个实现绘制一个
黄色的roundRect](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1365) [绘制一些文字
并在其上绘制一个图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1369) [出于若干原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1373) [我们并不推荐这种方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1376) [我们将这个视图子类与
UIImageView进行比较](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1378) [我们将这个视图子类与
UIImageView进行比较](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1378) [你可能已经知道
每个UIView实际上都是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1384) [依赖Core Animation
运行时的CALayer实现的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1388) [对于我们的图像视图
图像视图创建…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1391) [要求图像创建解码图像缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1394) [然后 将解码后的图像
交给CALayer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1399) [用作其所在层的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1402) [（自定义绘图
与UIIMAGEVIEW）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1404) [对于我们重写draw得到的
自定义视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1406) [它们很相似 但略有不同](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1409) [负责创建图像缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1411) [来保存我们draw方法的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1414) [以及我们视图的层
执行draw函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1417) [并填充该图像缓冲区的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1420) [这些内容接着根据显示硬件的需要](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1423) [被复制到帧缓冲区中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1426) [（后备存储器存储开销）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1432) [为了解这将产生多大的开销](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1435) [以及为什么我们不应该寻求](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1436) [实现这个UI的替代方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1439) [实现这个UI的替代方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1439) [我们在此使用的后备存储器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1441) [即连接到CALayer
的图像缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1443) [其大小与我们正在显示的
视图大小成正比](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1446) [我们在iOS 12中引入了
一项新功能和优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1451) [即后备存储器中元素的大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1454) [实际上会动态增长](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1459) [取决于你是否绘制任何有颜色的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1461) [以及该颜色的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1464) [是在标准色彩范围之内或之外](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1465) [因此如果你使用扩展的SRGB颜色
绘制广色域内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1468) [则后备存储器实际上会比](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1473) [仅使用0到1范围内的颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1477) [的后备存储器大](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1478) [在之前的iOS版本中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1483) [你可以通过设置CALayer的
内容格式属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1486) [来作为对Core Animation
的一个提示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1489) [即我知道我不需要在这个视图中
支持广色域内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1491) [或我知道我需要在这个视图中
支持广色域内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1495) [如果你这样做 你实际上将会禁用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1498) [如果你这样做 你实际上将会禁用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1498) [我们在iOS 12中引入的优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1502) [因此 请检查
layerWillDraw的实现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1505) [确保你不会意外关闭这项优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1508) [该优化能够使你的运行
在iOS 12上的代码受益无穷](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1511) [但我们可以做得比仅仅提示我们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1517) [是否需要一个支持广色域的
后备存储器更好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1520) [我们实际上可以减少](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1523) [app所需的后备存储器总量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1526) [我们可以通过将这个较大的视图
重构为较小的子视图来实现这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1527) [并且减少或消除
重写draw函数的地方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1532) [（减少后备存储器的使用）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1536) [这将帮助我们消除](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1538) [内存中图像数据的重复副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1541) [并且这将允许我们利用
UIView的优化属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1542) [其不需实现后备存储器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1546) [因此 正如我所提到的
重写draw方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1550) [将需要创建一个后备存储器
以与CALayer一起使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1553) [但是即使你不重写draw方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1557) [UIView中的一些属性
仍然可以工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1559) [UIView中的一些属性
仍然可以工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1559) [例如设置UIView的背景颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1561) [并不需要创建后备存储器
除非你使用的是图案颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1564) [因此我建议不要在UIView中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1569) [使用具有背景颜色属性的图案颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1571) [而应该创建
一个UIImageView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1575) [将你的图像分配到该图像视图并使用
UIImageView中的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1577) [恰当地设置平铺参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1582) [当我们想要剪切圆角矩形的角时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1587) [我们希望使用CALayer的
cornerRadius属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1592) [因为Core Animation
能够渲染削角](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1595) [而不需要额外的内存分配](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1600) [如果我们改用更强大的
maskView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1603) [或maskLayer属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1606) [我们最终需要额外分配
内存来存储该mask](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1608) [如果你有更复杂透明区域的背景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1613) [并且不能通过cornerRadius属性
进行设置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1618) [并且不能通过cornerRadius属性
进行设置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1618) [你应该考虑使用
UIImageView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1620) [将这些信息存储在你的素材目录中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1623) [或在运行时渲染它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1626) [并将其作为图像提供给图像视图](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1628) [而不应该使用maskView
或maskLayer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1630) [最后
对于该Live Photo图标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1635) [UIImageView
能够对单色图稿进行着色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1639) [而不需要额外的内存分配](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1644) [你要做的第一件事是勾选…](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1648) [不是勾选复选框](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1650) [而是在图片素材编辑器中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1651) [将渲染模式属性设置为
always template](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1654) [或在UIImageView上调用
withRenderingMode函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1657) [来创建一个渲染模式为
always template的UIImage](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1661) [然后将该图像分配给图像视图
并将该图像视图的tintColor](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1664) [设置为你想要图像渲染的颜色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1668) [在UIImage将图像渲染到
帧缓冲区的过程中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1672) [它会在该复制操作中使用纯色](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1675) [而不需要持有一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1680) [app了纯色图像的单独副本](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1683) [UIKit提供的视图中
内置了另一项优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1687) [UILabel可以在显示单色文本时
比显示彩色文本或表情符号时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1691) [减少75%的内存使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1698) [如果你想更详细地了解
此优化的工作原理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1701) [以及如何将其app于
UIView的自定义子类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1704) [可以参考“iOS内存深潜”演讲](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1708) [其详细介绍了这种名为A8的
后备存储器格式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1711) [有时候 你想渲染存储在内存中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1718) [图像缓冲区中的图像](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1722) [UIKit为此提供的类
是UIGraphicsImageRenderer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1726) [还有另一个更旧的函数
UIGraphicsBeginImageContext](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1730) [但请不要使用它
因为只有图形图像渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1735) [能够正确渲染广色域内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1739) [能够正确渲染广色域内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1739) [（屏外绘制）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1742) [你可以在app中
使用UIGraphicsImageRenderer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1743) [渲染到屏幕外的地方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1747) [然后使用UIImageView
在屏幕上进行高效显示](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1749) [与我们在CALayer
后备存储器中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1755) [引入的优化类似](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1757) [我们也使
UIGraphicsImageRenderer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1760) [能够动态增长其图像缓冲区的大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1763) [这取决于你在操作块中执行的操作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1766) [如果你在iOS 12之前的
操作系统上运行代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1773) [你可以使用
UIGraphicsImageRendererFormat](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1778) [中的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1779) [prefersExtendedRange属性
来告诉UIKit](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1781) [你是否计划绘制广色域内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1784) [但这里有一个中间地带](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1790) [如果你主要将图像渲染
到图形图像渲染器中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1793) [该图像可能使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1798) [该图像可能使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1798) [超出SRGB色域的色彩空间值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1800) [但实际上并不需要更大的元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1806) [来存储这些信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1809) [UIImage有一个可以用来获取一个预构建的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1810) [UIGraphicsImageRendererFormat
对象的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1813) [image renderer format属性
该对象用于在重新渲染图像时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1815) [进行最优化存储](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1821) [最后我们将谈一些](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1826) [有关如何在你的app中集成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1828) [我们在iOS中提供的先进
CPU和GPU技术的话题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1832) [如果你需要使用
Core Image](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1837) [对你的图片实时进行大量的高级处理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1840) [（高级图像效果）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1845) [Core Image
是这样一个框架](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1845) [它允许你创建处理图像的配方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1848) [并在CPU或GPU上进行处理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1851) [如果你从CIImage创建一个
UIImage并将其交给UIImageView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1855) [如果你从CIImage创建一个
UIImage并将其交给UIImageView](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1855) [UIImageView将负责
在GPU上执行该配方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1860) [这非常高效 并且它可以](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1866) [保持CPU空闲从而能够
在你的app中执行其他工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1867) [为了使用它
像平常一样创建你的CIImage](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1872) [然后调用UIImage
CIImage初始程序](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1875) [（高级图像处理）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1878) [iOS上还有其他用于处理和渲染](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1879) [图形内容的高级框架](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1881) [包括Metal Vision
和Accelerate](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1885) [这些框架中常见的数据类型之一
是CVPixelBuffer](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1891) [这是一种数据类型
其用来表示在CPU或GPU上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1896) [正在使用的缓冲区
或尚未使用的缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1900) [构建这些像素缓冲区之一时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1904) [确保使用最好的初始化程序](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1906) [即最接近你手头表述的那个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1908) [不要展开任何解码工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1912) [这些工作已经由现有的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1915) [UIImage
或CGImage实现完成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1918) [UIImage
或CGImage实现完成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1918) [在CPU和GPU之间移动数据时
要格外小心](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1921) [这样你就不会仅在两者之间
进行权衡工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1924) [实际上你可以让它们并行执行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1927) [最后请关注一下
Accelerate框架](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1931) [如何正确格式化待处理缓冲区的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1934) [Accelerate
和simd演讲](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1937) [总结一下几个关键点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1942) [在表视图和集合视图中实现预取](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1945) [以便可以事先完成一些工作
并避免粘连](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1948) [确保你没有关闭UIKit提供的
任何优化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1953) [这些优化可以减少与视图关联的
后备存储器大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1957) [（总结）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1962) [如果你将图像与app捆绑在一起](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1963) [将其存储在素材目录中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1966) [不要将其存储在与你的app
相关联的文件中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1969) [最后 如果你以不同大小
渲染相同的图标](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1973) [不要过分依赖
“保留矢量数据”复选框](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1977) [不要过分依赖
“保留矢量数据”复选框](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1977) [欲了解更多信息
有许多相关的演讲](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1983) [包括一个调查性能问题的演讲](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1986) [明天和星期五我们还会有实验室讨论](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1992) [如果你有任何问题
请来实验室找我们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1996) [感谢你的收看](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/219/?time=1999)