WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:01.195 --> 00:21:06.600 align:middle line:-2
实际上素材目录编译器已经生成了
那个图片的预栅格化版本

00:21:06.667 --> 00:21:08.936 align:middle line:-1
并将其存储在素材目录中

00:21:09.436 --> 00:21:11.939 align:middle line:-1
因此并不需要做复杂的数学运算

00:21:12.005 --> 00:21:14.908 align:middle line:-1
来将矢量图形栅格化为位图

00:21:15.209 --> 00:21:18.846 align:middle line:-2
我们可以直接解码
存储在素材目录中的图像

00:21:19.580 --> 00:21:22.149 align:middle line:-1
并将其直接渲染到帧缓冲区中

00:21:24.952 --> 00:21:29.489 align:middle line:-1
如果你计划以几种固定大小呈现图像

00:21:29.556 --> 00:21:33.093 align:middle line:-1
比如你有一个小图标和一个大图标

00:21:33.794 --> 00:21:37.130 align:middle line:-2
你不需要依赖
“保留矢量数据”复选框

00:21:37.731 --> 00:21:41.034 align:middle line:-1
只需创建这两种你预先确定好

00:21:41.101 --> 00:21:43.070 align:middle line:-1
需要渲染的尺寸的图片素材

00:21:44.972 --> 00:21:46.907 align:middle line:-1
这将允许在编译期

00:21:47.741 --> 00:21:52.212 align:middle line:-2
调用CPU对你的图片进行栅格化
从而达到优化的效果

00:21:52.613 --> 00:21:55.649 align:middle line:-2
而不是每次将图像复制到帧缓冲区时
都进行计算

00:21:58.285 --> 00:22:01.755 align:middle line:-2
我们已经看到了如何使用
UIImage和UIImageView

