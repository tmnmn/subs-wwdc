WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:58.619 --> 00:17:00.921 align:middle line:-1
我们不能一次完成所有这些工作

00:17:00.988 --> 00:17:03.457 align:middle line:-2
我们无法在不存在的CPU上
进行并行处理

00:17:03.524 --> 00:17:04.958 align:middle line:-1
（线程爆炸）

00:17:05.025 --> 00:17:06.159 align:middle line:-1
现在 为了避免

00:17:06.627 --> 00:17:09.762 align:middle line:-2
向一个全局队列中
异步的分配任务时发生死锁

00:17:10.263 --> 00:17:15.569 align:middle line:-2
GCD将创建新线程来捕捉
我们要求它所做的工作

00:17:16.236 --> 00:17:18.438 align:middle line:-1
然后 CPU将花费大量时间

00:17:18.505 --> 00:17:20.040 align:middle line:-1
在这些线程之间进行切换

00:17:20.339 --> 00:17:23.109 align:middle line:-1
尝试在所有工作上取得我们

00:17:23.176 --> 00:17:25.244 align:middle line:-1
要求操作系统为我们做的渐进式进展

00:17:25.712 --> 00:17:27.146 align:middle line:-1
在这些线程之间不停切换

00:17:27.214 --> 00:17:29.016 align:middle line:-1
实际上是相当大的开销

00:17:31.351 --> 00:17:34.688 align:middle line:-1
如果有一个或多个CPU有机会

00:17:34.755 --> 00:17:38.058 align:middle line:-1
一次处理完图片 效果会更好

00:17:39.193 --> 00:17:43.297 align:middle line:-2
因此 我们将借鉴去年的
“现代化中心调度GCD用法”

00:17:43.764 --> 00:17:46.300 align:middle line:-1
演讲中所提出的一项技术

00:17:46.733 --> 00:17:47.935 align:middle line:-1
我们将同步一些工作

00:17:48.001 --> 00:17:50.771 align:middle line:-2
抱歉 不是同步
我们要序列化一些工作

00:17:52.940 --> 00:17:57.444 align:middle line:-2
因此 我们现在不是简单地
将工作分派到全局异步队列之一

00:17:58.178 --> 00:17:59.880 align:middle line:-1
而是创建一个串行队列

