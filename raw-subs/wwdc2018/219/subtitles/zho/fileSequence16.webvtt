WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:01.595 --> 00:16:02.829 align:middle line:-1
这样做的效果

00:16:02.896 --> 00:16:05.399 align:middle line:-1
是你的app具有更强的响应能力

00:16:05.732 --> 00:16:08.035 align:middle line:-1
并且该设备具有更长的电池寿命

00:16:09.570 --> 00:16:11.071 align:middle line:-1
为了在这里进行实际演示

00:16:11.438 --> 00:16:15.542 align:middle line:-1
我们已经在数据源上实现了预取方法

00:16:16.610 --> 00:16:18.412 align:middle line:-1
它将会调用我们的辅助函数

00:16:18.645 --> 00:16:21.248 align:middle line:-2
来生成我们将要在
CollectionView单元格中

00:16:21.849 --> 00:16:25.485 align:middle line:-1
所显示图片的下采样版本

00:16:27.254 --> 00:16:31.925 align:middle line:-2
它通过将工作分派到
其中一个全局异步队列来完成此任务

00:16:33.727 --> 00:16:35.195 align:middle line:-1
很好 我们的工作正在后台进行

00:16:35.262 --> 00:16:36.697 align:middle line:-1
这就是我们想要做的

00:16:37.564 --> 00:16:40.200 align:middle line:-1
但这里有一个潜在的缺陷

00:16:40.734 --> 00:16:43.737 align:middle line:-2
这是一个我们喜欢称之为
线程爆炸的现象

00:16:44.505 --> 00:16:47.908 align:middle line:-2
当我们要求系统去做
比CPU能够做的工作

00:16:48.408 --> 00:16:50.444 align:middle line:-1
更多的工作时就会发生这种情况

00:16:51.411 --> 00:16:53.447 align:middle line:-1
如果我们要显示大量的图像

00:16:53.514 --> 00:16:55.282 align:middle line:-1
比如同时显示6张或8张图片

00:16:55.616 --> 00:16:58.018 align:middle line:-2
但是我们在只有两个CPU的
设备上运行

00:16:58.619 --> 00:17:00.921 align:middle line:-1
我们不能一次完成所有这些工作

