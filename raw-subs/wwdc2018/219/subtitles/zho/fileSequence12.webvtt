WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:56.016 --> 00:12:00.220 align:middle line:-2
接着我们创建缩略图
即我们拿到所返回的CGImage

00:12:00.687 --> 00:12:02.189 align:middle line:-1
将其包装在UIImage中

00:12:02.256 --> 00:12:03.924 align:middle line:-2
从我们在此编写的
辅助函数中返回

00:12:05.993 --> 00:12:09.196 align:middle line:-2
为了让你了解这项技术
为我们节省的开销数量

00:12:09.796 --> 00:12:11.765 align:middle line:-1
我们只在这里显示全屏图像

00:12:11.832 --> 00:12:14.434 align:middle line:-2
这是一张大小为
3000 x 2000像素的照片

00:12:14.501 --> 00:12:15.836 align:middle line:-1
如果我们不做优化

00:12:15.903 --> 00:12:19.606 align:middle line:-2
只是将UIImageView放入
Storyboard并将图片分配给它

00:12:20.007 --> 00:12:24.144 align:middle line:-2
这个app占用了31.5兆
却没有做任何事情

00:12:25.879 --> 00:12:27.814 align:middle line:-1
现在 使用这种下采样技术

00:12:27.881 --> 00:12:31.652 align:middle line:-2
并且只创建一个实际显示大小的
图像缓冲区

00:12:32.152 --> 00:12:33.921 align:middle line:-1
我们可以得到这个app的

00:12:33.987 --> 00:12:36.390 align:middle line:-2
内存使用情况
其降至18.4兆

00:12:36.857 --> 00:12:39.726 align:middle line:-1
这大大减少了内存使用量

00:12:44.331 --> 00:12:46.567 align:middle line:-2
谢谢大家 但你们都应该
因在自己的app中

00:12:46.633 --> 00:12:48.468 align:middle line:-1
使用此技术而得到掌声

00:12:49.770 --> 00:12:52.739 align:middle line:-2
你可以想象这对于一个
需要在屏幕上的

00:12:52.806 --> 00:12:56.276 align:middle line:-2
一小块空间里显示大量
可能很大输入图像

00:12:56.844 --> 00:12:58.779 align:middle line:-1
的app来说有多么重要

00:12:59.446 --> 00:13:00.514 align:middle line:-1
例如Camera Roll

