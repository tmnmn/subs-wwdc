WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:59.446 --> 00:13:00.514 align:middle line:-1
例如Camera Roll

00:13:02.616 --> 00:13:05.519 align:middle line:-2
你可以使用UICollectionView
来实现这样的视图

00:13:05.586 --> 00:13:08.422 align:middle line:-2
因此我们为indexPath中
item实现了单元格

00:13:09.089 --> 00:13:11.859 align:middle line:-1
并且我们使用之前写的辅助函数

00:13:11.925 --> 00:13:15.863 align:middle line:-2
将图像向下采样使之缩小到
当单元格实际放在屏幕上时

00:13:15.929 --> 00:13:18.165 align:middle line:-1
它们将要显示的大小

00:13:19.733 --> 00:13:22.135 align:middle line:-1
你认为这是一件很好的事情 对吧？

00:13:22.202 --> 00:13:25.339 align:middle line:-2
我们实际上减少了内存的使用量
而不是允许系统中存在

00:13:25.405 --> 00:13:27.007 align:middle line:-1
这些大的内存区域

00:13:27.407 --> 00:13:30.511 align:middle line:-2
不幸的是 这并不能解决我们的
另一个问题

00:13:30.577 --> 00:13:34.314 align:middle line:-2
这些问题在可滚动视图 比如
表视图和集合视图中是很常见的

00:13:35.415 --> 00:13:37.084 align:middle line:-1
你可能曾经见过这种情况

00:13:37.150 --> 00:13:40.487 align:middle line:-2
你在app中滚动页面
而在滚动过程中页面发生了粘连

00:13:41.188 --> 00:13:42.422 align:middle line:-1
这里发生的情况是

00:13:42.823 --> 00:13:48.529 align:middle line:-2
当我们滚动页面时
CPU相对比较空闲

00:13:49.096 --> 00:13:50.130 align:middle line:-1
或它所做的工作

00:13:50.197 --> 00:13:54.902 align:middle line:-2
可以在显示硬件需要帧缓冲的
下一个副本之前完成

00:13:55.536 --> 00:13:59.473 align:middle line:-2
所以当帧缓冲区被更新时
我们能够看到流动的效果

00:13:59.540 --> 00:14:02.342 align:middle line:-1
并且显示硬件能够及时获得新帧

