WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.593 --> 00:21:00.928 align:middle line:-1
之后对图形编码

00:21:01.361 --> 00:21:03.564 align:middle line:-1
编码命令即刻返回

00:21:04.264 --> 00:21:06.333 align:middle line:-1
用户指定的回调函数会被调用

00:21:06.767 --> 00:21:08.602 align:middle line:-1
在GPU完成图形运行的时候

00:21:09.369 --> 00:21:11.705 align:middle line:-1
这样我们就知道GPU运行完了

00:21:12.105 --> 00:21:16.577 align:middle line:-1
CPU可以继续为GPU工作编码

00:21:17.711 --> 00:21:20.113 align:middle line:-2
就是之前在信号量上
等待处理的部分

00:21:21.315 --> 00:21:22.816 align:middle line:-1
为什么使用双缓冲呢？

00:21:22.883 --> 00:21:27.487 align:middle line:-2
为什么不能同时对GPU的
多次运行进行编码

00:21:28.822 --> 00:21:31.258 align:middle line:-1
因为编码命令用时少

00:21:31.325 --> 00:21:33.360 align:middle line:-1
命令缓冲比运行训练图快

00:21:33.660 --> 00:21:36.363 align:middle line:-2
所以不会编码
多次训练图执行

00:21:36.430 --> 00:21:38.465 align:middle line:-1
为了减少内存占用

00:21:41.268 --> 00:21:43.837 align:middle line:-1
我们讲过了如何执行训练图

00:21:43.904 --> 00:21:46.540 align:middle line:-1
执行图形时 我们做正向传播

00:21:46.607 --> 00:21:49.276 align:middle line:-1
计算损失 再梯度传播

00:21:49.343 --> 00:21:51.211 align:middle line:-1
然后图形会更新权重

00:21:51.545 --> 00:21:53.747 align:middle line:-1
现在说说权重更新

00:21:55.883 --> 00:21:59.353 align:middle line:-1
我说过数据源提供器很重要

00:21:59.987 --> 00:22:00.921 align:middle line:-1
对训练而言

