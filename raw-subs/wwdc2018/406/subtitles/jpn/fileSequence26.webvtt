WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:58.625 --> 00:26:01.195 align:start position:27% line:-2
この両方のケイパビリティを
合わせました

00:26:02.396 --> 00:26:07.201 align:start position:27% line:-2
準拠型と汎用アルゴリズムが
複数ずつある場合―

00:26:07.301 --> 00:26:10.537 align:start position:23% line:-1
プロトコル階層を成形しがちです

00:26:10.637 --> 00:26:15.309 align:start position:29% line:-2
これらの階層は大きすぎず
細かすぎないことです

00:26:15.876 --> 00:26:21.782 align:start position:21% line:-2
要るのはドメイン内の型を記述する
少数のプロトコルです

00:26:22.616 --> 00:26:26.420 align:start position:25% line:-1
プロトコル階層のビルドでは―

00:26:26.520 --> 00:26:32.125 align:start position:21% line:-2
上に行くにつれプロトコルの要件が
少なくなります

00:26:32.226 --> 00:26:36.930 align:start position:29% line:-2
それで 要件を実装できる
準拠型が増えます

00:26:37.464 --> 00:26:43.403 align:start position:25% line:-2
一方で 階層を下りながら
様々なプロトコルを結合すると

00:26:43.537 --> 00:26:46.607 align:start position:29% line:-2
より複雑なアルゴリズムが
実装できます

00:26:46.707 --> 00:26:51.178 align:start position:25% line:-2
高いケイパビリティが要り
対応する準拠型は減りますがね

00:26:55.549 --> 00:27:00.020 align:start position:29% line:-2
では Swiftの新機能
条件付き準拠に進みます

