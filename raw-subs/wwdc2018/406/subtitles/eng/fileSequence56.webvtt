WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:56:00.216 --> 00:56:01.986 A:middle
that are only supportable on a

00:56:01.986 --> 00:56:03.626 A:middle
subset of the conforming types.

00:56:04.726 --> 00:56:06.116 A:middle
And, conditional conformance

00:56:06.446 --> 00:56:07.716 A:middle
when you're writing generic

00:56:07.816 --> 00:56:11.046 A:middle
types, so that they can compose

00:56:11.046 --> 00:56:12.576 A:middle
nicely, especially when working

00:56:12.576 --> 00:56:13.686 A:middle
with protocol hierarchies.

00:56:14.456 --> 00:56:15.276 A:middle
And finally, when you're

00:56:15.336 --> 00:56:16.656 A:middle
reasoning about the tricky

00:56:16.656 --> 00:56:18.126 A:middle
interaction between class

00:56:18.126 --> 00:56:19.506 A:middle
inheritance and the generic

00:56:19.506 --> 00:56:19.976 A:middle
system.

00:56:20.536 --> 00:56:21.786 A:middle
Go back to the Liskov

00:56:21.786 --> 00:56:23.306 A:middle
substitution principle, and

00:56:23.306 --> 00:56:26.036 A:middle
think about what happens here if

00:56:26.036 --> 00:56:27.866 A:middle
I introduce a subclass rather

00:56:27.866 --> 00:56:29.546 A:middle
than a superclass at which I

00:56:29.546 --> 00:56:30.406 A:middle
wrote the conformance.

00:56:32.576 --> 00:56:34.626 A:middle
Well, thank you very much.

00:56:34.866 --> 00:56:35.776 A:middle
There's a couple of related

00:56:35.776 --> 00:56:37.536 A:middle
sessions on embracing algorithms

00:56:37.536 --> 00:56:38.596 A:middle
and understanding how they can

00:56:38.596 --> 00:56:39.706 A:middle
help you build better code.

00:56:39.976 --> 00:56:41.276 A:middle
As well as using Swift

00:56:41.276 --> 00:56:43.296 A:middle
collections effectively in your

00:56:43.296 --> 00:56:44.126 A:middle
everyday programming.

00:56:45.026 --> 00:56:45.536 A:middle
Thank you.

00:56:46.508 --> 00:56:48.508 A:middle
[ Applause ]

