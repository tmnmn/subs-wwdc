WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:54.276 --> 00:06:01.266 A:middle
这意味着我们可以实现在内存的
连续块中保留全部元素的目标

00:06:01.306 --> 00:06:02.416 A:middle
而不会超前

00:06:02.416 --> 00:06:05.476 A:middle
即使那些类型任意大

00:06:05.476 --> 00:06:12.416 A:middle
因为编译器始终能直接了解

00:06:12.416 --> 00:06:15.376 A:middle
关于缓冲器具体包含哪种元素类型

00:06:15.956 --> 00:06:16.976 A:middle
它就有机会进行优化

00:06:16.976 --> 00:06:19.646 A:middle
而其它时候却没有

00:06:20.586 --> 00:06:23.436 A:middle
那么在本例中 在我声明整型缓冲器的位置

00:06:24.296 --> 00:06:27.366 A:middle
一个类似这样的循环应该被编译为

00:06:27.366 --> 00:06:28.766 A:middle
仅仅应用于某些非常有效的 CPU 指令

00:06:28.766 --> 00:06:36.186 A:middle
现在如果你正在一个常规基础上写一个这样的循环

00:06:36.546 --> 00:06:37.826 A:middle
用于总计整型缓冲器

00:06:38.006 --> 00:06:40.776 A:middle
把它提取到一个方法中可能会有意义

00:06:40.876 --> 00:06:44.086 A:middle
缓冲器上的扩展单位-可测试性更好

00:06:44.086 --> 00:06:46.966 A:middle
把它提取到一个方法中也可读性也更强

00:06:47.026 --> 00:06:50.306 A:middle
但你很可能知道 如果你像这样写代码

00:06:50.706 --> 00:06:52.026 A:middle
你会出现编译问题

00:06:52.516 --> 00:06:57.366 A:middle
因为并不是所有的元素类型
都可以像这样总计起来

00:06:57.666 --> 00:06:58.916 A:middle
我们需要告诉编译器

00:06:59.126 --> 00:07:03.646 A:middle
更多关于元素所需要具备的性能的信息

