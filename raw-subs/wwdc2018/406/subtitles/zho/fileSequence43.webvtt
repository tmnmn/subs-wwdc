WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:42:53.376 --> 00:43:01.496 A:middle
这里是算法的排序和插入点的非递归实现

00:43:02.096 --> 00:43:04.356 A:middle
我们来看看核心的算法并没有不同

00:43:04.356 --> 00:43:09.816 A:middle
但它是用这个 while 循环迭代
而不是递归表示的

00:43:10.536 --> 00:43:11.626 A:middle
所以我们要做的第一件事

00:43:11.626 --> 00:43:14.546 A:middle
就是获取整个集合的一个切片

00:43:15.306 --> 00:43:18.546 A:middle
这个切片变量将表示我们在每次

00:43:18.546 --> 00:43:21.196 A:middle
迭代中看到的集合的一部分

00:43:21.986 --> 00:43:24.726 A:middle
现在我们看到了熟悉的分治模式

00:43:25.226 --> 00:43:26.766 A:middle
找到切片的中间位置

00:43:27.206 --> 00:43:31.836 A:middle
然后将插入值与切片中的中间元素进行比较

00:43:32.616 --> 00:43:34.536 A:middle
然后 在再次进入循环之前

00:43:34.846 --> 00:43:37.986 A:middle
我们通过分割切片来缩小搜索范围

00:43:39.286 --> 00:43:41.246 A:middle
然而 我们碰到了一个问题

00:43:41.556 --> 00:43:46.566 A:middle
我们对切片变量赋值为子序列类型

00:43:46.566 --> 00:43:50.526 A:middle
另一个方面 右边是切片的切片

00:43:50.526 --> 00:43:52.646 A:middle
正如我们之前讨论过的

00:43:53.006 --> 00:43:57.216 A:middle
子序列的子序列可能是一个完全不同的类型

00:43:57.636 --> 00:43:58.556 A:middle
我们会得到一个编译错误

00:43:58.556 --> 00:44:01.496 A:middle
告诉我们这两种类型不一定相同

