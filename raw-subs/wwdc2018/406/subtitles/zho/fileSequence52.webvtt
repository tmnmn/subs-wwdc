WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:52:00.136 --> 00:52:03.006 A:middle
现在第二件有意思的事是 我们要如何实施它？

00:52:03.006 --> 00:52:04.956 A:middle
我们调用上边那个初始化程序

00:52:04.956 --> 00:52:07.206 A:middle
来创建一个全新的实例

00:52:07.206 --> 00:52:12.516 A:middle
是我们所拥有的可解码类型的实例 然后返回它

00:52:12.516 --> 00:52:15.326 A:middle
很公平

00:52:16.146 --> 00:52:18.466 A:middle
我们可以继续并让汽车类型可解码

00:52:19.426 --> 00:52:22.776 A:middle
然后我们期待当应用 Liskov 替换原理时

00:52:22.776 --> 00:52:26.426 A:middle
我们可以使用汽车的任意子类

00:52:27.146 --> 00:52:29.176 A:middle
带有我们通过协议一致性 创建的这些新 API

00:52:29.176 --> 00:52:32.806 A:middle
那么我们可以在出租车子类上调用解码

00:52:33.486 --> 00:52:35.726 A:middle
而我们得到的不是汽车 也不是任意汽车实例

00:52:35.726 --> 00:52:39.076 A:middle
而是出租车 出租车的实例

00:52:40.476 --> 00:52:41.846 A:middle
很棒 但应该如何使用它？

00:52:41.846 --> 00:52:45.496 A:middle
让我们看看出租车会包含什么？

00:52:45.496 --> 00:52:47.296 A:middle
也许这里有一个按小时计费的工具

00:52:47.356 --> 00:52:51.496 A:middle
当我们调用 Taxi.decode(from:) 时

00:52:51.496 --> 00:52:53.856 A:middle
我们就会通过协议 通过协议初始化程序要求

00:52:53.856 --> 00:52:58.096 A:middle
它其实只能调用一个初始化程序

00:52:58.096 --> 00:53:02.266 A:middle
就是在汽车类内部声明的初始化程序

