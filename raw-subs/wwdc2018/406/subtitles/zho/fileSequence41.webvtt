WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:40:58.766 --> 00:41:06.406 A:middle
但是返回的索引 也需要是当前集合的有效索引

00:41:06.766 --> 00:41:10.246 A:middle
我们可以在集合协议中捕获所有这些要求

00:41:10.246 --> 00:41:15.376 A:middle
现在我们要做的第一件事是定义集合的子序列

00:41:15.376 --> 00:41:17.076 A:middle
本身就是一个集合

00:41:17.076 --> 00:41:19.606 A:middle
这就是所谓的“递归约束”

00:41:19.606 --> 00:41:23.626 A:middle
因为关联的类型符合它自己的封闭协议

00:41:23.626 --> 00:41:27.176 A:middle
然后我们可以使用关联类型

00:41:27.176 --> 00:41:30.736 A:middle
where 子句来进一步约束我们的子序列

00:41:31.356 --> 00:41:34.576 A:middle
如前所述它有一个元素类型

00:41:34.576 --> 00:41:38.006 A:middle
这个元素类型需要与原始集合相同

00:41:38.006 --> 00:41:41.656 A:middle
我们可以用同样的类型约束来表示

00:41:41.856 --> 00:41:43.416 A:middle
子序列元素与元素相同

00:41:43.416 --> 00:41:47.466 A:middle
由此也可以推及到索引类型

00:41:48.266 --> 00:41:51.696 A:middle
这些覆盖了我们通过观察算法的

00:41:51.696 --> 00:41:54.926 A:middle
排序插入点的实现而发现的所有属性

00:41:55.076 --> 00:41:58.886 A:middle
这就引出了一个有趣的问题

00:41:58.886 --> 00:42:01.666 A:middle
你能切片一个子序列吗

