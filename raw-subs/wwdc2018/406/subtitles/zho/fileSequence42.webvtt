WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:58.886 --> 00:42:01.666 A:middle
你能切片一个子序列吗

00:42:02.416 --> 00:42:03.936 A:middle
每个子序列都是一个集合

00:42:03.936 --> 00:42:05.856 A:middle
每个集合都有一个切片操作

00:42:05.856 --> 00:42:09.706 A:middle
因此你当然可以切片一个子序列

00:42:09.986 --> 00:42:14.146 A:middle
结果将是子序列的一个子序列

00:42:15.156 --> 00:42:18.166 A:middle
现在你可以再执行一次得到一个子序列的

00:42:18.166 --> 00:42:19.996 A:middle
一个子序列的一个子序列

00:42:20.566 --> 00:42:22.956 A:middle
如此一直继续下去

00:42:22.956 --> 00:42:28.226 A:middle
有趣的是 在每一点
我们都可以得到一个全新的类型

00:42:28.226 --> 00:42:31.376 A:middle
于是我们就拥有了这个潜在的无尽的模型塔

00:42:31.906 --> 00:42:33.156 A:middle
这实际上很好理解

00:42:33.896 --> 00:42:36.546 A:middle
我们的泛型算法中的每个递归步骤

00:42:36.546 --> 00:42:41.236 A:middle
都可以创建一个基于当前集合类型的新类型

00:42:41.236 --> 00:42:46.166 A:middle
只要递归最终在运行时终止就没有问题

00:42:46.166 --> 00:42:49.116 A:middle
然而 通常情况下

00:42:49.166 --> 00:42:51.646 A:middle
我们可以使分治算法不具备递归特性

00:42:51.646 --> 00:42:53.376 A:middle
从而更有效地实现

00:42:53.376 --> 00:43:01.496 A:middle
这里是算法的排序和插入点的非递归实现

