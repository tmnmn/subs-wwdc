WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:59.096 --> 00:35:02.956 A:middle
在下一步中我们找到新的中间值 14

00:35:02.956 --> 00:35:04.246 A:middle
并将其与我们想要插入的值进行比较

00:35:05.196 --> 00:35:07.546 A:middle
11 小于 14

00:35:07.546 --> 00:35:10.776 A:middle
所以插入点必须在中间值之前

00:35:11.246 --> 00:35:13.676 A:middle
再把剩下的集合部分分成两半

00:35:14.586 --> 00:35:16.976 A:middle
继续将我们观察的集合分成两半

00:35:17.096 --> 00:35:19.626 A:middle
直到我们指向到合适的插入点

00:35:19.966 --> 00:35:20.986 A:middle
这就是我们的解决方案

00:35:22.546 --> 00:35:25.216 A:middle
像这样的分治算法十分出色

00:35:25.556 --> 00:35:27.316 A:middle
因为它们的效率非常高

00:35:27.806 --> 00:35:30.486 A:middle
二进制搜索所需的时间呈对数变化

00:35:30.726 --> 00:35:33.616 A:middle
这意味着把输入的大小加倍

00:35:33.616 --> 00:35:36.436 A:middle
并不会像线性算法一样 使算法的运行慢两倍

00:35:36.436 --> 00:35:38.716 A:middle
对于像二进制搜索

00:35:38.716 --> 00:35:40.646 A:middle
只需要执行一个额外的步骤

00:35:40.646 --> 00:35:44.906 A:middle
就可以再次将问题的规模减半

00:35:44.906 --> 00:35:47.646 A:middle
现在我们把它转换成代码

00:35:48.226 --> 00:35:51.996 A:middle
首先要做的是找到中间元素的索引

00:35:51.996 --> 00:35:55.446 A:middle
我们可以通过一个函数使用

00:35:55.446 --> 00:35:56.746 A:middle
randomAccessCollections 指数偏移

00:35:57.616 --> 00:36:01.716 A:middle
接下来 我们需要检查值是否位于中间元素之前

