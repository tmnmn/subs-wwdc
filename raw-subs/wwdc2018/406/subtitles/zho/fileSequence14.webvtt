WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.006 --> 00:14:01.556 A:middle
但看起来非常非常烦人

00:14:01.556 --> 00:14:04.276 A:middle
如果我们不得不经常在我们所写的每一个扩展上

00:14:04.276 --> 00:14:06.696 A:middle
应用这个约束

00:14:06.696 --> 00:14:09.396 A:middle
因为我们几乎总是需要比较两个索引

00:14:10.316 --> 00:14:13.556 A:middle
相反 它作为协议的要求 很可能更好地进行表述

00:14:13.556 --> 00:14:19.016 A:middle
作为我们索引相关联类型的约束

00:14:20.386 --> 00:14:21.406 A:middle
把这个约束应用到协议上

00:14:21.406 --> 00:14:23.246 A:middle
意味着遵循协议的全部类型

00:14:23.246 --> 00:14:26.266 A:middle
都需要向它们的索引提供一个
等同的类型

00:14:26.266 --> 00:14:32.046 A:middle
那样你就不需要在每次写扩展时都要指定它了

00:14:33.476 --> 00:14:36.936 A:middle
这是协商协议约束的另一个例子

00:14:36.936 --> 00:14:39.946 A:middle
协议的用户有一个要求

00:14:39.946 --> 00:14:41.306 A:middle
他们需要能比较索引

00:14:41.306 --> 00:14:48.186 A:middle
一致性协议 他们查看了一下
他们可以很合理地进行调整

00:14:48.186 --> 00:14:49.566 A:middle
而不需要放弃太多的灵活性

00:14:50.726 --> 00:14:52.116 A:middle
在本例中他们当然可以

00:14:56.296 --> 00:14:59.646 A:middle
并且通过 Swift 4.2 的
新功能自动合成等同的一致性

00:14:59.646 --> 00:15:03.976 A:middle
字典可以很简单地把它的索引类型变为等同

