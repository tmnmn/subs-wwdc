WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:58.806 --> 00:39:00.736 A:middle
不提供自己的子序列类型的

00:39:00.736 --> 00:39:02.626 A:middle
任何符合的集合类型

00:39:02.626 --> 00:39:08.446 A:middle
这与前面从切片下标开始的实现匹配得很好

00:39:08.446 --> 00:39:12.326 A:middle
在集合协议的扩展中进行编写

00:39:12.756 --> 00:39:16.336 A:middle
它还可以作为默认的实现

00:39:16.336 --> 00:39:18.946 A:middle
提供返回切片的切片下标操作

00:39:19.886 --> 00:39:21.736 A:middle
我们甚至可以更进一步

00:39:21.946 --> 00:39:25.426 A:middle
在选择默认子序列类型的情况下

00:39:25.426 --> 00:39:29.046 A:middle
限制默认切片下标实现的适用性

00:39:29.046 --> 00:39:34.546 A:middle
因此这种模式可以防止默认实现

00:39:34.546 --> 00:39:36.706 A:middle
显示为对自定义子序列的

00:39:36.706 --> 00:39:39.486 A:middle
集合类型的重载

00:39:39.486 --> 00:39:41.256 A:middle
比如字符串和区间类型

00:39:41.806 --> 00:39:43.666 A:middle
所以这种模式很好地符合了各种类型

00:39:43.916 --> 00:39:45.766 A:middle
它们可以免费得到切片

00:39:45.766 --> 00:39:47.446 A:middle
或者根据需要自定义切片

00:39:48.606 --> 00:39:49.896 A:middle
但请记住我们的目标

00:39:50.256 --> 00:39:52.926 A:middle
我们希望编写出针对集合协议的分治算法

00:39:52.926 --> 00:39:54.416 A:middle
针对集合协议的分治算法

00:39:55.016 --> 00:39:58.116 A:middle
所以我们必须回答一个非常重要的问题

00:39:58.706 --> 00:40:00.596 A:middle
子序列的作用是什么

