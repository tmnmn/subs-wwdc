WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:43:58.556 --> 00:44:01.496 A:middle
告诉我们这两种类型不一定相同

00:44:01.496 --> 00:44:04.296 A:middle
这一点很不方便

00:44:04.296 --> 00:44:06.646 A:middle
因为它阻止我们编写这个非递归算法

00:44:06.646 --> 00:44:10.996 A:middle
它并不能真正反映特定集合类型的行为

00:44:10.996 --> 00:44:12.706 A:middle
考虑一下字符串

00:44:13.266 --> 00:44:15.996 A:middle
当你切片一个字符串时
你会得到一个子字符串

00:44:16.446 --> 00:44:18.276 A:middle
如果你切片一个子字符串

00:44:18.276 --> 00:44:20.586 A:middle
你并不会得到子字符串的子字符串

00:44:21.256 --> 00:44:24.296 A:middle
你只会得到子字符串的另一个实例

00:44:25.206 --> 00:44:28.646 A:middle
让我们讨论之前的
这个适配型切片的工作方式

00:44:28.646 --> 00:44:29.816 A:middle
来概括这个概念

00:44:30.306 --> 00:44:32.426 A:middle
我们有一个集合 命名为 Self

00:44:32.776 --> 00:44:34.606 A:middle
并将其分割为 I 到 J 几个切片

00:44:35.536 --> 00:44:37.996 A:middle
现在将构建一个 Self 的类型切片

00:44:37.996 --> 00:44:40.676 A:middle
它只是底层 Self 集合的一个视图

00:44:40.676 --> 00:44:45.276 A:middle
如果我们分割这个切片

00:44:45.276 --> 00:44:47.676 A:middle
我们将得到 Self 的切片的一个切片

00:44:47.866 --> 00:44:50.586 A:middle
它是一个相同的基础 Self 集合上的视图

00:44:50.586 --> 00:44:52.576 A:middle
的一个视图

00:44:52.576 --> 00:44:56.876 A:middle
这就是我们在实践中得到的无限塔

00:44:57.346 --> 00:44:58.956 A:middle
然而也可以不必这样

00:44:58.956 --> 00:45:04.246 A:middle
请记住 切片类型使用与其基础集合

