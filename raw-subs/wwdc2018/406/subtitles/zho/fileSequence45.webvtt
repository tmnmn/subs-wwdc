WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:44:58.956 --> 00:45:04.246 A:middle
请记住 切片类型使用与其基础集合

00:45:04.246 --> 00:45:07.546 A:middle
相同的索引 它们了解自己的基础集合

00:45:07.546 --> 00:45:11.686 A:middle
所以当我们切片的时候

00:45:11.686 --> 00:45:14.286 A:middle
我们可以取那些新的索引 I2 和 J2

00:45:14.286 --> 00:45:18.766 A:middle
将它们置入原始的基础集合

00:45:18.766 --> 00:45:19.936 A:middle
并从那里形成新的切片

00:45:19.936 --> 00:45:23.946 A:middle
它的作用是 当你分割一个切片的时候

00:45:23.946 --> 00:45:25.436 A:middle
你会得到相同的切片类型

00:45:25.436 --> 00:45:28.746 A:middle
有效地约束了递归

00:45:28.746 --> 00:45:32.946 A:middle
这和子字符串的行为完全一样

00:45:33.246 --> 00:45:38.706 A:middle
并且有理由预想所有子序列类型
都以这种方式运行

00:45:39.026 --> 00:45:43.746 A:middle
让我们将其建模为集合协议需求的
一个显式部分

00:45:44.416 --> 00:45:49.976 A:middle
这里我们定义一个子序列的子序列
和子序列的类型是一样的

00:45:49.976 --> 00:45:55.356 A:middle
换句话说 当你分割切片的时候
你会得到相同类型的切片

00:45:56.326 --> 00:45:59.256 A:middle
这样我们的非递归
分治算法将得以运行

00:45:59.336 --> 00:46:01.286 A:middle
而且简化了集合协议的使用

