WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:59.636 --> 00:49:04.376 A:middle
那么如果我要用一个新方法扩展汽车

00:49:04.376 --> 00:49:07.066 A:middle
让它变成驱动器

00:49:07.166 --> 00:49:08.736 A:middle
我非常期待我可以在我的一个子类上

00:49:08.736 --> 00:49:10.086 A:middle
调用那个方法 比如出租车

00:49:11.016 --> 00:49:15.426 A:middle
那么这是面向对象编程中的一个根本方面

00:49:15.756 --> 00:49:18.836 A:middle
Barbara Liskov 其实很好地描述了相关信息

00:49:18.836 --> 00:49:20.106 A:middle
在 80 年代的一场演讲中

00:49:20.846 --> 00:49:23.656 A:middle
自那时起 我们就把这个叫做 Liskov 替换原则

00:49:23.656 --> 00:49:25.856 A:middle
理念其实很简单

00:49:25.856 --> 00:49:28.986 A:middle
那么如果你的程序中有一些地方

00:49:28.986 --> 00:49:34.246 A:middle
引用了一个超类型或超类 比如汽车

00:49:34.376 --> 00:49:37.316 A:middle
你就应该可以获取它的子类型

00:49:37.316 --> 00:49:39.056 A:middle
或子类的任意实例

00:49:39.056 --> 00:49:44.346 A:middle
比如出租车或汽车子类 并使用它

00:49:44.806 --> 00:49:47.996 A:middle
程序应该仍然继续监测类型 并正常运行

00:49:48.746 --> 00:49:51.226 A:middle
那么这里的替换是作为子类的实例

00:49:51.226 --> 00:49:53.756 A:middle
应该可以去到子类所能去到的任何地方

00:49:53.756 --> 00:49:56.476 A:middle
这是一个很简单的原则

00:49:56.476 --> 00:50:00.026 A:middle
我们把它内在化了 但它仍然很强大

