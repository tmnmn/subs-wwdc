WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:59.756 --> 00:28:01.976 A:middle
并没说切片也是一个
BidirectionalCollection

00:28:02.636 --> 00:28:05.966 A:middle
我们可以修复这个问题

00:28:05.966 --> 00:28:09.156 A:middle
让我们把切片扩展一下
使它遵循 BidirectionalCollection 协议

00:28:09.156 --> 00:28:13.026 A:middle
我们需要实施这个
index(before:) 操作

00:28:13.026 --> 00:28:16.176 A:middle
这样我们可以按照下面的基础集合进行实施

00:28:17.146 --> 00:28:18.666 A:middle
除非编译器会在这里进行约束

00:28:19.736 --> 00:28:22.676 A:middle
关于基础集合
我们所了解的唯一一件事就是

00:28:22.676 --> 00:28:23.516 A:middle
它是一个集合

00:28:23.666 --> 00:28:26.286 A:middle
它并没有 index(before:) 操作

00:28:27.806 --> 00:28:28.966 A:middle
我们知道如何修复这个问题

00:28:29.516 --> 00:28:32.646 A:middle
我们所需要做的就是在这个扩展中引入一个要求

00:28:32.646 --> 00:28:35.016 A:middle
换句话说就是基础集合需要是
BidirectionalCollection

00:28:35.786 --> 00:28:37.186 A:middle
这是条件一致性

00:28:38.146 --> 00:28:41.836 A:middle
其实就是扩展声明遵循某个协议

00:28:41.836 --> 00:28:45.416 A:middle
然后那个协议下的约束条件实际上就有意义了

00:28:45.416 --> 00:28:49.146 A:middle
关于条件一致性的最棒的事就是

00:28:49.146 --> 00:28:51.516 A:middle
当你拥有这些协议等级时
它会漂亮地进行堆栈

00:28:51.836 --> 00:28:55.656 A:middle
所以我们还可以说切片是一个
RandomAccessCollection

00:28:56.026 --> 00:28:59.286 A:middle
当它下面的基础类型是
RandomAccessCollection 时

