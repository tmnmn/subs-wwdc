WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:57.616 --> 00:36:01.716 A:middle
接下来 我们需要检查值是否位于中间元素之前

00:36:01.956 --> 00:36:05.516 A:middle
所以我们知道了集合的哪一半包含插入点

00:36:06.516 --> 00:36:10.316 A:middle
在我们的示例中要插入的值大于中间的元素

00:36:10.656 --> 00:36:13.766 A:middle
我们从中间值之后的索引中取出集合的一个切片

00:36:13.766 --> 00:36:16.036 A:middle
直到完成

00:36:16.556 --> 00:36:19.616 A:middle
然后递归地调用切片上的排序和插入点

00:36:19.616 --> 00:36:22.936 A:middle
这在分治算法中很常见

00:36:23.126 --> 00:36:26.036 A:middle
也就是减少问题的规模 然后递归

00:36:26.036 --> 00:36:30.116 A:middle
为了使它能够使用 现在我们需要那个切片的语法

00:36:30.116 --> 00:36:32.316 A:middle
为了提供集合中适当的切片

00:36:33.076 --> 00:36:37.846 A:middle
我们可以为所有的集合引入一个
获取一系列索引

00:36:37.846 --> 00:36:41.816 A:middle
并生成切片的通用操作 就像这样

00:36:42.966 --> 00:36:46.086 A:middle
现在请记住我们前面讨论的适配式切片

00:36:46.126 --> 00:36:51.576 A:middle
适用于任何集合 提供基础集合中元素的视图

00:36:51.866 --> 00:36:53.956 A:middle
而基础集合本身就是集合

00:36:54.616 --> 00:36:57.776 A:middle
这就使得 我们的分治算法适用于任何集合

00:36:58.196 --> 00:37:02.186 A:middle
以及为所有集合提供切片语法

