WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:57.726 --> 00:34:02.566 A:middle
那么你为什么需要它呢 
让我们来看一个基于它的泛型算法

00:34:03.086 --> 00:34:06.006 A:middle
这里是一个给定的已经排序过的集合

00:34:06.316 --> 00:34:09.496 A:middle
我们想要找到应该插入一个新值的索引

00:34:09.496 --> 00:34:12.076 A:middle
从而保持排序的顺序

00:34:12.456 --> 00:34:14.656 A:middle
我们将要计算值为 11 的排序插入点

00:34:14.656 --> 00:34:19.936 A:middle
当我们在索引处插入 11 时

00:34:19.936 --> 00:34:21.406 A:middle
结果仍然是一个排序好的数组

00:34:22.036 --> 00:34:25.386 A:middle
函数的排序插入点是通过二进制搜索实现的

00:34:25.386 --> 00:34:26.846 A:middle
是通过二进制搜索实现的

00:34:27.536 --> 00:34:30.716 A:middle
二进制搜索是一种经典的分治算法

00:34:31.005 --> 00:34:34.646 A:middle
这意味着在每个步骤中它都会做出一个决策

00:34:34.646 --> 00:34:37.056 A:middle
从而显著地减小问题的规模

00:34:37.196 --> 00:34:41.476 A:middle
需要考虑的下一步是对于二进制查找

00:34:41.476 --> 00:34:43.216 A:middle
我们首先观察中间元素 8

00:34:43.735 --> 00:34:46.545 A:middle
然后与我们要插入的值进行比较 也就是 11

00:34:47.226 --> 00:34:49.085 A:middle
因为 11 大于 8

00:34:49.085 --> 00:34:54.556 A:middle
所以 11 需要在 8 之后插入
在集合的后半部分

00:34:54.556 --> 00:34:57.826 A:middle
所以我们把搜索空间限制了一半

00:34:59.096 --> 00:35:02.956 A:middle
在下一步中我们找到新的中间值 14

