WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:58.706 --> 00:40:00.596 A:middle
子序列的作用是什么

00:40:01.266 --> 00:40:04.296 A:middle
关于子序列 我们现在所知道的就是

00:40:04.296 --> 00:40:05.456 A:middle
它是切片下标操作的结果类型

00:40:05.456 --> 00:40:08.666 A:middle
但我们需要了解更多从而真正地使用它

00:40:08.666 --> 00:40:10.816 A:middle
为了回答这个问题

00:40:10.816 --> 00:40:15.196 A:middle
我们必须回顾刚才
我们想要用子序列表示的算法

00:40:15.776 --> 00:40:17.666 A:middle
我们的算法是递归的

00:40:18.186 --> 00:40:22.186 A:middle
它形成一个切片 也就是现在的子序列类型的值

00:40:22.186 --> 00:40:26.856 A:middle
然后递归地调用切片上的排序插入点

00:40:26.856 --> 00:40:32.176 A:middle
只有当返回的子序列类型本身就是一个集合时

00:40:32.176 --> 00:40:35.716 A:middle
它才有意义 当它执行该调用时

00:40:35.916 --> 00:40:39.076 A:middle
我们将传递集合的元素类型的值

00:40:39.666 --> 00:40:45.126 A:middle
但是递归调用本身期望
这个子序列的元素类型的值

00:40:45.816 --> 00:40:49.716 A:middle
唯有这些元素类型相同时算法才有意义

00:40:49.716 --> 00:40:56.196 A:middle
当从递归调用返回一个索引时

00:40:56.196 --> 00:40:58.766 A:middle
也会出现相同的问题 递归调用将由子序列计算

00:40:58.766 --> 00:41:06.406 A:middle
但是返回的索引 也需要是当前集合的有效索引

