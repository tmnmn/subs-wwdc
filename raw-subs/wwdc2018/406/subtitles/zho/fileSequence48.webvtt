WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:48:00.726 --> 00:48:03.256 A:middle
如果你发现 你在集合层级结构中的不同位置

00:48:03.256 --> 00:48:05.896 A:middle
需要不同的默认关联类型

00:48:06.216 --> 00:48:07.686 A:middle
那么你的设计可能出现了问题

00:48:08.316 --> 00:48:09.396 A:middle
递归约束是一个强大的工具

00:48:09.396 --> 00:48:13.916 A:middle
协同关联类型以及协议 where 子句

00:48:13.916 --> 00:48:14.996 A:middle
它们帮助我们编写协议需求

00:48:14.996 --> 00:48:17.016 A:middle
从而能够用泛型代码

00:48:17.016 --> 00:48:20.116 A:middle
自然地表达分治算法

00:48:20.596 --> 00:48:23.606 A:middle
现在我们回到 WWDC 演讲的最后一部分

00:48:25.026 --> 00:48:26.506 A:middle
那么 Swift 是一个多范式语言

00:48:26.506 --> 00:48:29.636 A:middle
现在我们一直在专心讲通用型

00:48:29.636 --> 00:48:32.136 A:middle
但是当然了 Swift 也支持面向对象的编程

00:48:32.136 --> 00:48:37.686 A:middle
那么我想花一些时间谈谈这两个功能
之间的相互影响

00:48:37.686 --> 00:48:40.646 A:middle
以及它们如何在 Swift 语言中协同合作

00:48:41.166 --> 00:48:44.546 A:middle
那么对于类继承
我们知道类继承是如何运作的

00:48:44.576 --> 00:48:45.866 A:middle
非常简单

00:48:46.386 --> 00:48:48.386 A:middle
你可以声明一个超类 比如汽车

00:48:48.536 --> 00:48:52.786 A:middle
你可以声明某些子类 比如出租车和警车
它们都继承自汽车

00:48:53.606 --> 00:48:56.466 A:middle
一旦你这么做了
你就拥有了这个面向对象的等级

00:48:56.956 --> 00:48:59.636 A:middle
你期望那些子类可以在哪里使用

00:48:59.636 --> 00:49:04.376 A:middle
那么如果我要用一个新方法扩展汽车

