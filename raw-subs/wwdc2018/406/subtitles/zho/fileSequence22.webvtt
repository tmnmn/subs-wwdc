WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.816 --> 00:22:00.776 A:middle
你可以使用那些集合算法

00:22:00.776 --> 00:22:04.976 A:middle
但是 BidirectionalCollection
添加了这个额外要求

00:22:05.016 --> 00:22:07.226 A:middle
就是能在集合中倒着操作

00:22:07.226 --> 00:22:09.866 A:middle
有一个重点需要注意

00:22:10.006 --> 00:22:12.386 A:middle
并不是每个集合都可以实施
这个特定的要求

00:22:12.436 --> 00:22:16.936 A:middle
思考一下 SinglyLinkedList
你只能让这些指针

00:22:17.496 --> 00:22:19.856 A:middle
从一个位置跳到下一个位置

00:22:20.156 --> 00:22:22.786 A:middle
并没有一种有效的方式
可以按照这个顺序倒着进行

00:22:22.926 --> 00:22:25.406 A:middle
因此它不能是 BidirectionalCollection

00:22:25.776 --> 00:22:26.566 A:middle
那么一旦我们引入了继承

00:22:26.566 --> 00:22:28.046 A:middle
你就已经限制了一致性类型

00:22:28.046 --> 00:22:33.346 A:middle
但你也允许你自己实施更多有趣的算法

00:22:33.346 --> 00:22:37.136 A:middle
那么这是这个 lastIndex(where:)
操作背后的代码

00:22:37.356 --> 00:22:41.496 A:middle
非常简单
我们只是在集合中倒着进行

00:22:41.496 --> 00:22:44.166 A:middle
使用这个来自 BidirectionalCollection
协议的新要求

00:22:44.166 --> 00:22:47.996 A:middle
让我们看一个更有意思的算法

00:22:47.996 --> 00:22:50.346 A:middle
那么这是一个洗牌操作

00:22:50.516 --> 00:22:53.526 A:middle
那么它在 Swift 4.2 中
针对集合进行了引入

00:22:53.666 --> 00:22:54.506 A:middle
你不需要自己实施它

00:22:54.506 --> 00:22:55.646 A:middle
我们会查看算法自身

00:22:55.646 --> 00:22:56.816 A:middle
了解它引入了哪些要求

00:22:56.816 --> 00:23:01.566 A:middle
从而算出如何有意义地将那些归类到协议中

