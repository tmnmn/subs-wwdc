WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:49:56.476 --> 00:50:00.026 A:middle
我们把它内在化了 但它仍然很强大

00:50:00.586 --> 00:50:03.346 A:middle
如果你思考一下的话
请考虑你程序中的任何一点

00:50:03.346 --> 00:50:05.906 A:middle
如果我得到一个不同的子类 会发生什么

00:50:05.906 --> 00:50:07.086 A:middle
也许是一个我没有想到的子类？

00:50:07.086 --> 00:50:11.786 A:middle
那么返回到通用型

00:50:12.756 --> 00:50:15.906 A:middle
当在通用型系统上应用 Liskov 替换原则时

00:50:15.906 --> 00:50:18.326 A:middle
我们期待什么呢？

00:50:18.976 --> 00:50:21.126 A:middle
也许我们添加了一个新协议 可驾驶

00:50:21.426 --> 00:50:25.146 A:middle
无论是什么 并把汽车扩展为可驾驶

00:50:25.496 --> 00:50:26.786 A:middle
我们期待发生什么呢？

00:50:26.786 --> 00:50:29.066 A:middle
我们期待你可以使用协议一致性

00:50:29.066 --> 00:50:32.436 A:middle
把汽车的一致性 用于可驾驶的一致性

00:50:32.436 --> 00:50:33.626 A:middle
并用在它的某些子类上

00:50:34.616 --> 00:50:38.316 A:middle
比如你在可驾驶协议中添加了一个

00:50:38.316 --> 00:50:39.966 A:middle
简单的通用算法 比如 sundayDrive

00:50:40.386 --> 00:50:44.476 A:middle
现在你应该可以在警车上使用
那个 API 了

00:50:44.956 --> 00:50:46.116 A:middle
即使这并不是最好的方式

00:50:46.116 --> 00:50:52.096 A:middle
那么子类有效地继承了协议一致性

00:50:52.306 --> 00:50:55.906 A:middle
并且这在一致性上添加了约束

00:50:55.906 --> 00:50:59.446 A:middle
你所写的那个一致性 就是让汽车可驾驶的东西

00:50:59.866 --> 00:51:06.416 A:middle
现在必须适用于汽车的全部子类
以及稍后出现的子类

