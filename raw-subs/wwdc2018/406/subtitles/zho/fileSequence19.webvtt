WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:57.706 --> 00:19:03.126 A:middle
通过一个扩展 编译器可以了解

00:19:03.126 --> 00:19:06.026 A:middle
有一个可用的方法 或属性的更好的实施

00:19:06.026 --> 00:19:09.956 A:middle
因此在通用情境中

00:19:09.956 --> 00:19:13.416 A:middle
它会在协议中动态地调遣那个实施

00:19:13.416 --> 00:19:18.856 A:middle
那么现在如果你在字典上调用地图

00:19:18.856 --> 00:19:19.876 A:middle
即便是一个完全通用的函数

00:19:20.596 --> 00:19:22.456 A:middle
你将会得到计数的更好的实施

00:19:24.596 --> 00:19:26.086 A:middle
添加这样的自定义点

00:19:26.086 --> 00:19:28.756 A:middle
同时通过扩展添加默认实施

00:19:28.756 --> 00:19:32.906 A:middle
是一种很强大的方式 可以获得同样的好处

00:19:32.976 --> 00:19:34.396 A:middle
跟你用类获得的好处一样

00:19:34.396 --> 00:19:37.086 A:middle
实施继承和方法重写

00:19:37.086 --> 00:19:41.916 A:middle
但这个技巧可以用在 结构和枚举以及类上

00:19:41.916 --> 00:19:48.476 A:middle
现在并不是每一个方法 都可以像这样进行优化

00:19:49.026 --> 00:19:53.146 A:middle
并且自定义点在你的二进制尺寸上
有一个小但非零的影响

00:19:53.146 --> 00:19:55.006 A:middle
你的编译器运行时间的性能

00:19:55.056 --> 00:19:59.506 A:middle
那么只有当明确有机会自定义时

00:19:59.506 --> 00:20:00.036 A:middle
添加自定义点才有意义

