WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:59.276 --> 00:30:00.606 A:middle
由那个运算符创建的类型

00:30:00.646 --> 00:30:04.306 A:middle
它适当地命名了范围类型

00:30:04.306 --> 00:30:08.126 A:middle
它相对于下面的绑定类型来说是通用的

00:30:08.126 --> 00:30:11.126 A:middle
这种情况下 我们有一系列双浮点精度型

00:30:11.126 --> 00:30:12.456 A:middle
它仅仅存储较低和较高的绑定型

00:30:12.646 --> 00:30:13.456 A:middle
非常简单

00:30:14.286 --> 00:30:18.816 A:middle
但在 Swift 4.2 之前 你从整型范围中得到的

00:30:18.876 --> 00:30:20.036 A:middle
实际上是一个不同的类型

00:30:20.466 --> 00:30:22.176 A:middle
这是 CountableRange 类型

00:30:23.126 --> 00:30:26.056 A:middle
现在请注意 它与范围类型的结构一模一样

00:30:26.056 --> 00:30:27.236 A:middle
它有一个类型参数

00:30:27.236 --> 00:30:28.696 A:middle
它有较低和较高绑定型

00:30:29.246 --> 00:30:32.686 A:middle
但它在那个绑定型上增加了一些额外的要求

00:30:32.686 --> 00:30:34.876 A:middle
那个绑定型是可跨过的 对吧？

00:30:35.286 --> 00:30:37.436 A:middle
意思是你可以枚举全部元素

00:30:37.866 --> 00:30:40.056 A:middle
现在这是你所需要的功能 从而可以

00:30:40.056 --> 00:30:42.456 A:middle
让 CountableRange 遵循
RandomAccessCollection

00:30:43.676 --> 00:30:46.826 A:middle
那就启用了 forEach 迭代循环
和其它功能

00:30:48.076 --> 00:30:50.736 A:middle
但是通过条件一致性 当然了
我们可以做得更好

00:30:51.516 --> 00:30:57.306 A:middle
让我们把基础范围类型变成一个集合

00:30:57.306 --> 00:31:01.376 A:middle
当绑定类型拥有这些额外的可跨过的要求时

