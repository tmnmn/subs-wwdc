WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:58.326 --> 00:24:00.886 A:middle
大纲视图从一小组项目开始

00:24:00.886 --> 00:24:02.386 A:middle
然后我们试着

00:24:02.386 --> 00:24:03.906 A:middle
在我们代码的这个区域内

00:24:03.906 --> 00:24:05.676 A:middle
不断修复扩展状态

00:24:05.676 --> 00:24:06.666 A:middle
我们会告诉它打开

00:24:06.666 --> 00:24:08.256 A:middle
比如说顶部的项目

00:24:08.506 --> 00:24:09.436 A:middle
而当我告诉它打开顶部的项目时

00:24:09.436 --> 00:24:11.406 A:middle
你能够想象

00:24:11.406 --> 00:24:12.576 A:middle
它同时将里面的其他项目

00:24:12.576 --> 00:24:13.296 A:middle
都向下移了

00:24:14.056 --> 00:24:15.716 A:middle
然后我继续扩展第二个项目

00:24:16.106 --> 00:24:17.516 A:middle
它就会再次下移其他项目

00:24:17.906 --> 00:24:19.386 A:middle
接着是第三个项目 以此类推

00:24:19.386 --> 00:24:20.666 A:middle
而等到你做完这些

00:24:20.966 --> 00:24:22.546 A:middle
你已经将这些底部的项目

00:24:22.586 --> 00:24:24.246 A:middle
向下移动了数千次

00:24:25.166 --> 00:24:26.396 A:middle
那这些都是多余的工作

00:24:26.396 --> 00:24:27.626 A:middle
而它们正是

00:24:27.656 --> 00:24:28.976 A:middle
我在提高性能时

00:24:29.206 --> 00:24:30.736 A:middle
想要消除的东西

00:24:31.406 --> 00:24:32.596 A:middle
现在 这些方法调用

00:24:32.596 --> 00:24:35.376 A:middle
谈到的批量处理

00:24:35.376 --> 00:24:36.666 A:middle
让我觉得或许

00:24:36.666 --> 00:24:38.006 A:middle
在一些 API 中我可以

00:24:38.006 --> 00:24:39.416 A:middle
让大纲视图批量地进行工作

00:24:39.416 --> 00:24:41.436 A:middle
因此它就可以对所有的位置

00:24:41.436 --> 00:24:43.336 A:middle
只进行一次计算

00:24:43.336 --> 00:24:44.386 A:middle
而不是在我进行调用的时候

00:24:44.426 --> 00:24:44.986 A:middle
反复地计算

00:24:46.236 --> 00:24:48.256 A:middle
我还看到一个调用

00:24:48.256 --> 00:24:50.056 A:middle
用来进行最后更新之后的工作

00:24:50.406 --> 00:24:52.616 A:middle
那么 有时 API 会提供那种

00:24:52.726 --> 00:24:53.956 A:middle
在一组列阵上进行运算的

00:24:53.956 --> 00:24:55.696 A:middle
整体方法

00:24:55.696 --> 00:24:57.416 A:middle
而有时它则会提供一种

00:24:57.416 --> 00:24:59.456 A:middle
事务型 API 

00:24:59.456 --> 00:25:00.806 A:middle
它会说我要开始进行更改

