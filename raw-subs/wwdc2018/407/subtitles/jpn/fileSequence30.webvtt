WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:59.399 --> 00:30:02.870 align:start position:29% line:-2
モデルコードの変更に
必死に応答しているのです

00:30:02.970 --> 00:30:05.505 align:start position:25% line:-2
これに CPUが多くの時間を
費やしていて

00:30:05.606 --> 00:30:09.042 align:start position:25% line:-2
変更全体で考えた時に
不要な処理となっているのです

00:30:09.443 --> 00:30:13.480 align:start position:27% line:-2
これが モデルコードからの
呼び出しだったら？

00:30:13.580 --> 00:30:15.983 align:start position:25% line:-1
通知や委譲を経由していたり―

00:30:16.083 --> 00:30:17.684 align:start position:30% line:-2
手動のブロックベース
コールバックだったら？

00:30:17.785 --> 00:30:21.221 align:start position:32% line:-2
何が起こっているかが
ずっと明らかです

00:30:21.321 --> 00:30:23.657 align:start position:23% line:-1
そして適切な処理をするでしょう

00:30:23.757 --> 00:30:28.161 align:start position:27% line:-2
いくつかの通知を
ループの中から外に出して―

00:30:28.262 --> 00:30:29.963 align:start position:23% line:-1
パフォーマンス向上を図るのです

00:30:30.430 --> 00:30:32.833 align:start position:32% line:-2
コントローラサイドの
やり方もあります

00:30:32.933 --> 00:30:36.203 align:start position:29% line:-2
ここでは 延期とバッチの
テクニックを使って

00:30:36.303 --> 00:30:39.606 align:start position:30% line:-2
ムダな仕事を省いて
同期応答を回避できます

00:30:40.874 --> 00:30:42.509 align:start position:38% line:-1
最後は簡単です

00:30:42.709 --> 00:30:46.413 align:start position:27% line:-2
コードが
すでに適切に動いていれば―

00:30:46.513 --> 00:30:49.183 align:start position:29% line:-2
すでにリニアということで
理想的です

00:30:49.283 --> 00:30:53.020 align:start position:27% line:-2
ある意味 パフォーマンスの
向上の余地も限られます

00:30:53.520 --> 00:30:56.290 align:start position:25% line:-2
その場合は
定期的な改善を続けることです

00:30:57.157 --> 00:31:00.994 align:start position:23% line:-2
オブジェクト指向の
ディクショナリを使っているなら

