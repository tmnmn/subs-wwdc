WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:15:57.406 --> 00:16:00.436 A:middle
这样一来 你的 App 可以拥有更好的

00:16:00.436 --> 00:16:01.096 A:middle
视觉化效果

00:16:02.856 --> 00:16:04.216 A:middle
但这里有一点要注意

00:16:05.436 --> 00:16:07.386 A:middle
因为现在模拟

00:16:07.386 --> 00:16:09.256 A:middle
会在上一帧就开始

00:16:09.956 --> 00:16:12.196 A:middle
所以需要独立的一组

00:16:12.286 --> 00:16:13.326 A:middle
预测停顿

00:16:14.066 --> 00:16:16.586 A:middle
这一组可以预测到

00:16:16.586 --> 00:16:18.956 A:middle
未来的 56 毫秒

00:16:18.956 --> 00:16:20.276 A:middle
这样就能和针对渲染线程

00:16:20.366 --> 00:16:21.886 A:middle
进行预测的小组相匹配

00:16:22.416 --> 00:16:24.176 A:middle
而且这两组会

00:16:24.206 --> 00:16:25.266 A:middle
和发射光子的时刻相匹配

00:16:27.126 --> 00:16:28.646 A:middle
这张图从中央处理器来看

00:16:28.646 --> 00:16:31.056 A:middle
已经很不错了 正如我们所见

00:16:31.056 --> 00:16:32.276 A:middle
App 在中央处理器中

00:16:32.276 --> 00:16:35.236 A:middle
很好的分配了它的工作 但是

00:16:36.236 --> 00:16:37.566 A:middle
让我们把重点放在图形处理器上

00:16:38.446 --> 00:16:43.596 A:middle
如你所见 我们例子中的 App

00:16:43.596 --> 00:16:46.696 A:middle
现在正在对所有这些图形处理器

00:16:46.696 --> 00:16:48.576 A:middle
所有工作流程进行编码

00:16:48.746 --> 00:16:51.286 A:middle
从而使一帧进入单一的公用缓冲区

00:16:51.286 --> 00:16:54.016 A:middle
因此除非这一公用缓冲区已完成

00:16:54.016 --> 00:16:56.466 A:middle
否则图形处理器就会

00:16:56.466 --> 00:16:57.316 A:middle
处于空闲的等待状态

00:16:58.836 --> 00:17:00.306 A:middle
不过 值得注意的是

