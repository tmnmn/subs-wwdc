WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:23:59.856 --> 00:24:01.936 A:middle
执行停顿依赖性工作就会变得安全

00:24:01.966 --> 00:24:05.246 A:middle
因此第二个命令缓冲区

00:24:05.556 --> 00:24:08.206 A:middle
就会发出封锁事件的信号

00:24:08.356 --> 00:24:10.166 A:middle
让停顿依赖性工作知道

00:24:10.166 --> 00:24:11.546 A:middle
它可以开始执行操作了

00:24:12.366 --> 00:24:14.346 A:middle
在将这两个命令缓冲区

00:24:14.416 --> 00:24:15.776 A:middle
编码并提交之后

00:24:16.386 --> 00:24:18.436 A:middle
渲染线程可以向往常一样继续

00:24:18.436 --> 00:24:20.566 A:middle
等待停顿

00:24:20.816 --> 00:24:21.826 A:middle
并在之后

00:24:21.916 --> 00:24:26.076 A:middle
对停顿依赖性工作进行编码

00:24:26.296 --> 00:24:28.296 A:middle
那么现在我们就有了一个

00:24:28.296 --> 00:24:30.306 A:middle
同步不同图形处理器间

00:24:30.306 --> 00:24:31.146 A:middle
不同工作负荷的机制

00:24:31.146 --> 00:24:35.156 A:middle
但是你可以看到

00:24:35.156 --> 00:24:37.426 A:middle
我们的次图形处理器仍然

00:24:37.426 --> 00:24:38.176 A:middle
有些空闲

00:24:38.226 --> 00:24:40.506 A:middle
这是因为在这个例子里

00:24:40.926 --> 00:24:43.886 A:middle
我们想要设法完成

00:24:44.316 --> 00:24:45.846 A:middle
停顿依赖性工作负荷

00:24:45.846 --> 00:24:47.396 A:middle
即那些拥有依赖于

00:24:47.396 --> 00:24:48.856 A:middle
停顿依赖性的工作

00:24:49.346 --> 00:24:49.786 A:middle
抱歉

00:24:50.796 --> 00:24:52.156 A:middle
不过 当然也有一些

00:24:52.206 --> 00:24:53.396 A:middle
工作负荷不具

00:24:53.396 --> 00:24:55.086 A:middle
依赖性 它们可以

00:24:55.216 --> 00:24:57.496 A:middle
在较低频率中发生

00:24:57.496 --> 00:24:58.806 A:middle
也就是头戴式设备的频率

00:24:59.576 --> 00:25:01.076 A:middle
这样的工作负荷

