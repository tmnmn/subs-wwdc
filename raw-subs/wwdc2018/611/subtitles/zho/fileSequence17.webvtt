WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:58.836 --> 00:17:00.306 A:middle
不过 值得注意的是

00:17:00.546 --> 00:17:02.676 A:middle
在中央处理器上 对图形处理器的操作

00:17:02.676 --> 00:17:05.336 A:middle
进行编码所花费的时间

00:17:05.586 --> 00:17:06.796 A:middle
比在图形处理器上处理这些操作

00:17:06.796 --> 00:17:08.165 A:middle
所花费的时间要少很多

00:17:08.986 --> 00:17:10.336 A:middle
因此我们可以利用这一事实

00:17:10.336 --> 00:17:13.935 A:middle
并将我们的编码操作

00:17:13.935 --> 00:17:15.656 A:middle
分解成为几个公用缓冲区

00:17:15.656 --> 00:17:17.876 A:middle
而几个公用缓冲区

00:17:17.876 --> 00:17:19.276 A:middle
可以进行快速编码

00:17:19.276 --> 00:17:21.266 A:middle
仅需几步操作而已

00:17:21.776 --> 00:17:23.715 A:middle
并尽快将其提交至

00:17:23.786 --> 00:17:24.336 A:middle
图形处理器

00:17:25.626 --> 00:17:30.426 A:middle
这样一来 我们就能

00:17:30.486 --> 00:17:33.016 A:middle
在图形处理器已经处理帧的同时

00:17:33.016 --> 00:17:34.626 A:middle
进行我们的编码

00:17:35.086 --> 00:17:36.826 A:middle
而且如你所见

00:17:36.826 --> 00:17:39.926 A:middle
在图形处理器进行处理的时候

00:17:40.036 --> 00:17:43.456 A:middle
我们延长了时间

00:17:43.456 --> 00:17:45.216 A:middle
作为结果 这样进一步增加了

00:17:45.216 --> 00:17:46.706 A:middle
你可以在一帧中提交的工作量

00:17:48.156 --> 00:17:49.226 A:middle
现在让我们回到我们的图表

00:17:49.266 --> 00:17:50.826 A:middle
看一下全部放在一起

00:17:50.826 --> 00:17:51.906 A:middle
看起来会如何

00:17:53.446 --> 00:17:55.636 A:middle
如你所见 现在中央处理器

00:17:55.636 --> 00:17:57.766 A:middle
和图形处理器都被完全利用起来了

00:17:58.746 --> 00:18:00.056 A:middle
那么这样的 App 已经

