WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.306 --> 00:19:01.346 A:middle
正在等待停顿

00:19:01.346 --> 00:19:02.996 A:middle
以对图形处理器的任何工作进行编码

00:19:03.626 --> 00:19:05.336 A:middle
但如果我们将这些工作负荷平分开来

00:19:05.336 --> 00:19:08.636 A:middle
我们就能立即

00:19:08.636 --> 00:19:09.676 A:middle
对非停顿依赖性工作负荷编码

00:19:09.766 --> 00:19:11.936 A:middle
然后等待停顿

00:19:12.026 --> 00:19:15.156 A:middle
以继续对停顿依赖性工作负荷编码

00:19:16.126 --> 00:19:19.456 A:middle
在这张幻灯片中 我们已经

00:19:19.456 --> 00:19:21.076 A:middle
将非停顿依赖性工作负荷

00:19:21.076 --> 00:19:23.006 A:middle
与停顿依赖性工作负荷

00:19:23.036 --> 00:19:23.346 A:middle
区分来开

00:19:24.516 --> 00:19:26.096 A:middle
非停顿依赖性工作负荷

00:19:26.096 --> 00:19:27.346 A:middle
现在已经在公用缓冲区

00:19:27.496 --> 00:19:29.096 A:middle
被编码 如果将它和后面的停顿依赖性

00:19:29.446 --> 00:19:31.066 A:middle
工作负荷比较的话

00:19:31.276 --> 00:19:32.746 A:middle
它被标记地

00:19:32.746 --> 00:19:33.446 A:middle
要更暗一些

00:19:34.336 --> 00:19:35.666 A:middle
因为停顿依赖性工作负荷

00:19:35.666 --> 00:19:36.886 A:middle
可以被立即编码

00:19:36.886 --> 00:19:39.146 A:middle
所以我们就会

00:19:39.146 --> 00:19:39.376 A:middle
采取如下操作

00:19:39.966 --> 00:19:41.526 A:middle
我们会在

00:19:41.636 --> 00:19:42.796 A:middle
上一帧工作负荷编码完成后

00:19:42.796 --> 00:19:43.286 A:middle
立即对其编码

00:19:44.766 --> 00:19:46.866 A:middle
这给了你的中央处理器更多时间

00:19:46.866 --> 00:19:49.246 A:middle
以对图形处理器工作进行编码

00:19:49.416 --> 00:19:51.646 A:middle
更重要的是 这确保了

00:19:51.646 --> 00:19:54.196 A:middle
这一图形处理器工作

00:19:54.196 --> 00:19:56.556 A:middle
已在图形处理器上等待被执行

00:19:56.556 --> 00:19:59.336 A:middle
因此图形处理器就没有

00:19:59.336 --> 00:20:00.576 A:middle
任何空闲时间

