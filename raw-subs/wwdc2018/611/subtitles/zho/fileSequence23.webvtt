WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:59.146 --> 00:23:01.396 A:middle
编码简单操作

00:23:01.396 --> 00:23:03.736 A:middle
将这些结果传输到

00:23:03.736 --> 00:23:05.806 A:middle
对两个图形处理器都可见

00:23:05.806 --> 00:23:06.676 A:middle
的系统内存中

00:23:07.426 --> 00:23:08.786 A:middle
一旦传输完成

00:23:08.786 --> 00:23:12.436 A:middle
我们的次图形处理器就能

00:23:12.906 --> 00:23:15.216 A:middle
安全地向我们的共享事件发出信号

00:23:15.866 --> 00:23:18.256 A:middle
这一信号会告诉外置图形处理器

00:23:18.316 --> 00:23:20.236 A:middle
现在接受这些结果是安全的

00:23:21.496 --> 00:23:23.536 A:middle
所以我们的渲染线程

00:23:23.536 --> 00:23:24.576 A:middle
执行这一些

00:23:24.576 --> 00:23:26.886 A:middle
共用缓冲区 并且辅助图形处理器

00:23:26.916 --> 00:23:29.246 A:middle
已经在处理这一工作

00:23:30.016 --> 00:23:32.336 A:middle
与此同时 我们可以开始

00:23:32.336 --> 00:23:34.086 A:middle
对驱动头戴式设备的

00:23:34.166 --> 00:23:36.486 A:middle
主图形处理器的命令缓冲区进行编码

00:23:37.676 --> 00:23:39.356 A:middle
在这一命令缓冲区中

00:23:39.356 --> 00:23:41.626 A:middle
我们一开始会等待我们的

00:23:41.626 --> 00:23:43.446 A:middle
共享事件 确保数据存储在

00:23:43.446 --> 00:23:45.516 A:middle
在系统内存里

00:23:45.516 --> 00:23:47.426 A:middle
只要它在那里  并且共享事件

00:23:47.426 --> 00:23:50.066 A:middle
收到信号 那么我们可以执行一个

00:23:50.066 --> 00:23:51.306 A:middle
简单操作

00:23:51.306 --> 00:23:52.516 A:middle
它会通过 Thunderbolt 3 接口

00:23:52.516 --> 00:23:54.826 A:middle
将这一数据传回

00:23:55.096 --> 00:23:57.856 A:middle
我们的外部图形处理器中

00:23:57.956 --> 00:23:59.856 A:middle
一旦传输完成

00:23:59.856 --> 00:24:01.936 A:middle
执行停顿依赖性工作就会变得安全

