WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:58.746 --> 00:18:00.056 A:middle
那么这样的 App 已经

00:18:00.056 --> 00:18:01.846 A:middle
为你的 App 提供了

00:18:01.846 --> 00:18:03.966 A:middle
很好的示范

00:18:03.966 --> 00:18:05.446 A:middle
但我们仍有提升的空间

00:18:07.196 --> 00:18:09.396 A:middle
你可能会注意到

00:18:09.506 --> 00:18:11.626 A:middle
在收到预测停顿之前

00:18:11.696 --> 00:18:13.786 A:middle
当对任何种类的图形处理器 进行编码时

00:18:14.306 --> 00:18:16.876 A:middle
渲染线程仍然处于等待状态

00:18:17.566 --> 00:18:19.186 A:middle
但是并非一帧里的所有工作流程

00:18:19.186 --> 00:18:21.486 A:middle
都需要这些停顿

00:18:22.536 --> 00:18:24.766 A:middle
那么让我们进行更加细致的分析

00:18:24.886 --> 00:18:26.086 A:middle
来选择帧的工作负荷

00:18:27.486 --> 00:18:29.956 A:middle
在这里 你可以看到

00:18:30.006 --> 00:18:32.916 A:middle
工作负荷列表 它们可能会在每一帧中被执行

00:18:34.056 --> 00:18:35.656 A:middle
其中一部分在屏幕空间中进行

00:18:35.656 --> 00:18:37.696 A:middle
或者需要了解

00:18:37.696 --> 00:18:39.766 A:middle
与为了渲染帧所产生的停顿

00:18:39.766 --> 00:18:40.736 A:middle
有关的总体信息

00:18:41.496 --> 00:18:42.726 A:middle
我们将这样的工作负荷

00:18:42.846 --> 00:18:44.116 A:middle
称为停顿依赖性工作负荷

00:18:44.986 --> 00:18:46.506 A:middle
与此同时

00:18:46.506 --> 00:18:48.746 A:middle
还有一般性的

00:18:48.746 --> 00:18:50.056 A:middle
无需与停顿有关的信息

00:18:50.096 --> 00:18:51.996 A:middle
就能立即执行的工作负荷

00:18:53.096 --> 00:18:54.886 A:middle
我们将这些工作负荷称为

00:18:54.886 --> 00:18:55.886 A:middle
非停顿依赖性工作负荷

00:18:56.496 --> 00:18:59.306 A:middle
那么现在 我们的 App 

00:18:59.306 --> 00:19:01.346 A:middle
正在等待停顿

