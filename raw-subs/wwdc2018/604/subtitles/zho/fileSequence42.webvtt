WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:41:58.286 --> 00:42:01.006 A:middle
同时我们还需要一个

00:42:01.006 --> 00:42:02.616 A:middle
frameBoundarySemaphore

00:42:02.616 --> 00:42:04.466 A:middle
它在初始化的时候被设置成了 3

00:42:05.096 --> 00:42:06.906 A:middle
所以这就表明信号量

00:42:06.906 --> 00:42:09.276 A:middle
会在每一帧的边缘被测到

00:42:09.576 --> 00:42:11.246 A:middle
就是在 GPU 完成

00:42:11.246 --> 00:42:14.046 A:middle
执行一帧的时候

00:42:14.046 --> 00:42:17.466 A:middle
这允许 CPU 去重复使用它的缓存

00:42:17.466 --> 00:42:19.826 A:middle
同样 初始化缓存索引去

00:42:19.826 --> 00:42:23.466 A:middle
指向当前帧的缓存

00:42:23.806 --> 00:42:26.386 A:middle
而且在你的渲染循环里

00:42:26.386 --> 00:42:28.006 A:middle
在你写进缓存之前我们需要

00:42:28.006 --> 00:42:30.006 A:middle
先确定它的

00:42:30.006 --> 00:42:31.276 A:middle
响应帧已经

00:42:31.326 --> 00:42:33.926 A:middle
在 GPU 上完成了执行

00:42:34.366 --> 00:42:35.836 A:middle
所以在帧的一开始

00:42:36.236 --> 00:42:37.386 A:middle
我们等待

00:42:37.386 --> 00:42:38.656 A:middle
frameBoundarySemaphore

00:42:39.696 --> 00:42:41.386 A:middle
一旦信号量被检测到了

00:42:41.506 --> 00:42:42.786 A:middle
这就表明当前帧

00:42:42.786 --> 00:42:44.166 A:middle
已经完成了它的

00:42:44.166 --> 00:42:46.126 A:middle
GPU 上的执行 

00:42:47.536 --> 00:42:50.846 A:middle
所以为了新的一帧的数据

00:42:50.846 --> 00:42:51.716 A:middle
去重复利用缓存是安全的

00:42:52.406 --> 00:42:55.426 A:middle
而且现在我们会编码一些

00:42:55.426 --> 00:42:59.176 A:middle
命令去绑定这个缓存和 GPU

00:42:59.176 --> 00:43:01.186 A:middle
在我们提交这个命令缓存给 GPU 之前

