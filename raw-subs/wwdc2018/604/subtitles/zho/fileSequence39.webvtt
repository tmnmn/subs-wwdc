WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:58.756 --> 00:39:01.546 A:middle
最适合你 App 的

00:39:01.546 --> 00:39:03.376 A:middle
优化同步策略

00:39:04.256 --> 00:39:06.966 A:middle
所以在很多情况下

00:39:07.026 --> 00:39:08.686 A:middle
最好的方法是 你分享资源使用的多个缓存

00:39:08.686 --> 00:39:11.706 A:middle
这样的话 CPU 和 GPU

00:39:11.706 --> 00:39:13.286 A:middle
就永远不会同时试图

00:39:13.286 --> 00:39:15.136 A:middle
访问同一个缓存

00:39:17.436 --> 00:39:19.916 A:middle
让我们来看一个例子

00:39:19.916 --> 00:39:22.126 A:middle
你有一个 OpenGL App

00:39:22.126 --> 00:39:24.676 A:middle
并且你刚刚把它移植到 Metal

00:39:24.736 --> 00:39:26.296 A:middle
这个 App 使用的是单个缓存去

00:39:26.296 --> 00:39:28.956 A:middle
更新这些数据并且

00:39:28.956 --> 00:39:30.386 A:middle
你还没有在 App 里

00:39:30.386 --> 00:39:32.766 A:middle
实现任何同步方法

00:39:32.766 --> 00:39:36.356 A:middle
那么 可能发生的事情是

00:39:36.906 --> 00:39:38.316 A:middle
你的 App 会在

00:39:38.316 --> 00:39:39.956 A:middle
生成第一个帧的命令的时候

00:39:39.956 --> 00:39:41.866 A:middle
写进那个缓存里

00:39:41.866 --> 00:39:45.426 A:middle
然后将这个命令缓存提交给 GPU

00:39:45.426 --> 00:39:47.406 A:middle
然后当你的 GPU 在

00:39:47.406 --> 00:39:48.876 A:middle
执行这个命令缓存的时候

00:39:48.876 --> 00:39:49.896 A:middle
会尝试从缓存里读取信息

00:39:50.436 --> 00:39:53.796 A:middle
并且当你在为下一帧

00:39:53.796 --> 00:39:55.446 A:middle
更新同一个缓存的时候

00:39:55.686 --> 00:39:57.816 A:middle
GPU 依旧会从这个缓存里读取

00:39:58.076 --> 00:40:01.266 A:middle
所以这很明显是个

