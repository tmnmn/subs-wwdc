WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:58.456 --> 00:38:00.486 A:middle
同时这样就允许我们去追踪

00:38:00.486 --> 00:38:02.116 A:middle
和有效地更新

00:38:02.116 --> 00:38:04.236 A:middle
在每一帧里都被改变的

00:38:04.236 --> 00:38:05.076 A:middle
分享的资源

00:38:05.556 --> 00:38:08.676 A:middle
既然我们到了这里 我们再来说一说

00:38:08.676 --> 00:38:09.876 A:middle
这些资源的更新

00:38:09.876 --> 00:38:12.486 A:middle
和看一看我们如何

00:38:12.486 --> 00:38:14.656 A:middle
通过完成处理器来让它们更高效

00:38:14.656 --> 00:38:18.626 A:middle
几乎所有的 App 都会在

00:38:18.626 --> 00:38:21.436 A:middle
每一帧将新的数据推送给 GPU

00:38:21.926 --> 00:38:24.206 A:middle
举个例子比如说动画里需要的

00:38:24.316 --> 00:38:25.716 A:middle
新的渲染单元

00:38:26.256 --> 00:38:29.146 A:middle
在 Metal 里 CPU 可以在任意时候

00:38:29.146 --> 00:38:31.776 A:middle
写入这些共享资源

00:38:31.886 --> 00:38:33.966 A:middle
即使 GPU 是在同一时刻访问

00:38:35.206 --> 00:38:36.276 A:middle
同一内存

00:38:37.376 --> 00:38:38.876 A:middle
Metal 并不能保护你不被这些

00:38:38.876 --> 00:38:40.456 A:middle
数据竞争影响

00:38:41.256 --> 00:38:44.176 A:middle
相比之下

00:38:44.176 --> 00:38:45.666 A:middle
OpenGL 默认地会避免这些

00:38:45.666 --> 00:38:48.056 A:middle
数据竞争

00:38:48.056 --> 00:38:50.676 A:middle
要么是等待 GPU 完成工作

00:38:50.676 --> 00:38:53.166 A:middle
要么是制作额外的副本

00:38:53.166 --> 00:38:54.586 A:middle
这样对你的 App 而言 可能并不是

00:38:54.586 --> 00:38:55.376 A:middle
最优选择

00:38:56.256 --> 00:38:58.756 A:middle
通过 Metal 你可以实现任何

00:38:58.756 --> 00:39:01.546 A:middle
最适合你 App 的

