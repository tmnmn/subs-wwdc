WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:58.926 --> 00:25:00.486 A:middle
数据的权限

00:25:00.486 --> 00:25:01.356 A:middle
这就允许了 Metal 

00:25:01.356 --> 00:25:03.906 A:middle
去执行优化

00:25:03.906 --> 00:25:05.786 A:middle
不然可能在 CPU 有访问数据权限的时候

00:25:05.786 --> 00:25:06.206 A:middle
是无法达成的

00:25:06.896 --> 00:25:08.776 A:middle
但是只有 GPU 可以直接

00:25:08.886 --> 00:25:11.096 A:middle
填写这种纹理类型的内容

00:25:12.606 --> 00:25:14.016 A:middle
你也可以间接的通过 CPU 去填写数据

00:25:14.206 --> 00:25:15.996 A:middle
这可以通过使用 blit 编码器让 CPU 实现

00:25:15.996 --> 00:25:17.786 A:middle
blit 通过共享的存储

00:25:18.076 --> 00:25:21.026 A:middle
从第二中间资源去拷贝

00:25:22.446 --> 00:25:23.966 A:middle
在具有专用视频内存的设备上

00:25:23.966 --> 00:25:25.656 A:middle
设定这个资源去使用

00:25:25.656 --> 00:25:27.306 A:middle
私有存储

00:25:27.306 --> 00:25:28.396 A:middle
将它分配成仅用于视频存储

00:25:30.396 --> 00:25:32.776 A:middle
最后 在 macOS 上你可以使用

00:25:32.866 --> 00:25:34.756 A:middle
第三种存储模式 托管存储

00:25:35.696 --> 00:25:37.796 A:middle
这种模式允许 GPU 和 CPU 一起

00:25:37.826 --> 00:25:39.066 A:middle
访问对象数据

00:25:39.776 --> 00:25:40.946 A:middle
而且对于有专用视频内存的系统

00:25:40.946 --> 00:25:43.226 A:middle
Metal 会建立一个镜像内存

00:25:43.226 --> 00:25:46.696 A:middle
反向用于两个处理器的高效访问

00:25:47.926 --> 00:25:49.396 A:middle
正因为这样

00:25:49.396 --> 00:25:51.166 A:middle
显性的调用对于确认

00:25:51.236 --> 00:25:53.876 A:middle
数据在 CPU GPU 上的同步访问是很有必要的

00:25:58.126 --> 00:26:00.376 A:middle
这里是一个创建纹理对象的例子

