WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:39:58.076 --> 00:40:01.266 A:middle
所以这很明显是个

00:40:01.266 --> 00:40:03.806 A:middle
竞争条件并且结果还是未知的

00:40:03.806 --> 00:40:06.826 A:middle
有一些潜在的修复

00:40:07.356 --> 00:40:09.806 A:middle
你可以在你的 App 中实现它们

00:40:10.396 --> 00:40:13.386 A:middle
最简单的方法是在每一帧之后

00:40:13.386 --> 00:40:14.396 A:middle
调用命令缓存里的

00:40:14.396 --> 00:40:17.306 A:middle
waitUntilCompleted 方法

00:40:18.516 --> 00:40:22.556 A:middle
但是这样的话需要等到 GPU

00:40:22.556 --> 00:40:24.246 A:middle
在你为了下一帧重写这一缓存之前

00:40:24.246 --> 00:40:26.296 A:middle
完成读取工作之后

00:40:27.096 --> 00:40:30.936 A:middle
不过就像你看到的

00:40:30.936 --> 00:40:32.866 A:middle
这里 CPU 和 GPU 的利用率都很差

00:40:33.036 --> 00:40:35.606 A:middle
所以这并不是

00:40:35.606 --> 00:40:38.166 A:middle
你想要完成的传输代码

00:40:38.936 --> 00:40:40.756 A:middle
但是如果你想要你的 Metal 

00:40:40.756 --> 00:40:42.856 A:middle
App 设置好并跑起来它还是很有用的

00:40:43.746 --> 00:40:45.976 A:middle
甚至如果你的 App

00:40:45.976 --> 00:40:47.766 A:middle
真的有这样的数据冲突

00:40:47.766 --> 00:40:49.716 A:middle
它是能检测出来的

00:40:51.756 --> 00:40:54.366 A:middle
一个高效的方法去同步

00:40:54.366 --> 00:40:55.926 A:middle
你的资源更新是使用

00:40:55.926 --> 00:40:56.826 A:middle
多个缓存

00:40:57.546 --> 00:40:58.906 A:middle
所以在这种情况下我们会用到

00:40:58.956 --> 00:41:00.526 A:middle
三个缓存去更新

