WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:59.876 --> 00:14:01.396 A:middle
调用惯例 这样一来

00:14:01.396 --> 00:14:02.606 A:middle
就不再由被调用的

00:14:02.606 --> 00:14:04.806 A:middle
一方来释放对象

00:14:05.206 --> 00:14:06.526 A:middle
这样一来 所有的保留

00:14:06.526 --> 00:14:10.366 A:middle
和释放都不复存在

00:14:10.606 --> 00:14:12.066 A:middle
可以显著减少

00:14:12.066 --> 00:14:13.016 A:middle
保留和释放的数据量

00:14:13.936 --> 00:14:15.076 A:middle
这有两重意义

00:14:15.546 --> 00:14:16.916 A:middle
一 可以缩减代码体积

00:14:16.986 --> 00:14:19.026 A:middle
因为这些调用不复存在

00:14:19.026 --> 00:14:20.336 A:middle
二 可以改善运行时

00:14:21.776 --> 00:14:24.746 A:middle
另一项重要的优化

00:14:24.746 --> 00:14:25.746 A:middle
针对字符串

00:14:26.186 --> 00:14:28.506 A:middle
Swift 4.2 的字符串为 16 个

00:14:28.506 --> 00:14:30.316 A:middle
字节长 此前长度为 24

00:14:30.756 --> 00:14:31.976 A:middle
这也是我们 

00:14:31.976 --> 00:14:33.266 A:middle
权衡内存使用和

00:14:33.266 --> 00:14:33.936 A:middle
性能的结果

00:14:35.346 --> 00:14:37.356 A:middle
但同时 这一长度

00:14:37.356 --> 00:14:38.936 A:middle
也足以对小字符串

00:14:38.936 --> 00:14:40.026 A:middle
进行优化

00:14:40.706 --> 00:14:42.746 A:middle
如果字符串不足 15

00:14:42.746 --> 00:14:45.226 A:middle
字节长 实际的字符串

00:14:45.226 --> 00:14:46.636 A:middle
就可以直接用

00:14:46.636 --> 00:14:48.246 A:middle
字符串类型表示 而不用

00:14:48.246 --> 00:14:49.306 A:middle
分配单独的

00:14:49.306 --> 00:14:50.806 A:middle
缓冲区来表示字符串

00:14:51.436 --> 00:14:53.456 A:middle
这显然既有利于内存

00:14:53.456 --> 00:14:55.066 A:middle
也有利于性能

00:14:55.716 --> 00:14:56.546 A:middle
这很像我们在

00:14:56.546 --> 00:14:57.866 A:middle
NSString 中

00:14:57.866 --> 00:14:58.286 A:middle
所做的优化

00:14:58.586 --> 00:15:00.516 A:middle
但我们可以存储更大的字符串

