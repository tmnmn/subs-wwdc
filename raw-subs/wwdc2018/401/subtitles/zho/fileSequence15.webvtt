WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:58.586 --> 00:15:00.516 A:middle
但我们可以存储更大的字符串

00:15:03.396 --> 00:15:05.096 A:middle
最后 在我把舞台交给

00:15:05.156 --> 00:15:06.126 A:middle
Slava 之前 我们来谈谈

00:15:06.126 --> 00:15:07.086 A:middle
语言本身的改进

00:15:07.086 --> 00:15:08.576 A:middle
我想多谈一下

00:15:08.576 --> 00:15:10.636 A:middle
缩减代码体积方面的努力

00:15:12.176 --> 00:15:13.146 A:middle
我之前在谈到

00:15:13.146 --> 00:15:14.586 A:middle
调用惯例改变的时候 提到了

00:15:14.586 --> 00:15:15.826 A:middle
缩减代码体积

00:15:15.826 --> 00:15:17.546 A:middle
我们还推出了一个新的

00:15:17.546 --> 00:15:19.936 A:middle
优化水平选项 即优化

00:15:19.936 --> 00:15:20.256 A:middle
体积（Optimize for Size [-Osize]）

00:15:21.466 --> 00:15:22.366 A:middle
这一点很有用

00:15:22.366 --> 00:15:23.986 A:middle
尤其是当 App 非常

00:15:24.056 --> 00:15:25.966 A:middle
关心体积限制的时候 例如

00:15:25.966 --> 00:15:27.216 A:middle
使用蜂窝网络进行

00:15:27.216 --> 00:15:28.056 A:middle
下载的限制

00:15:29.146 --> 00:15:30.626 A:middle
Swift 是一门强大的

00:15:30.696 --> 00:15:33.656 A:middle
静态语言 以静态的方式

00:15:33.656 --> 00:15:34.846 A:middle
理解程序行为

00:15:35.306 --> 00:15:36.306 A:middle
因此 编译器有很多

00:15:36.306 --> 00:15:38.626 A:middle
优化性能的

00:15:38.626 --> 00:15:40.016 A:middle
机会 例如

00:15:40.016 --> 00:15:41.596 A:middle
将函数调用内联（function call inlining）

00:15:41.596 --> 00:15:43.126 A:middle
以及推测性去虚化（speculative 

00:15:43.126 --> 00:15:44.326 A:middle
devirtualization） 这些方法牺牲代码体积

00:15:44.326 --> 00:15:45.846 A:middle
以换取性能 然而

00:15:45.846 --> 00:15:46.936 A:middle
有时候 这部分性能

00:15:47.226 --> 00:15:49.346 A:middle
并非实际需要

00:15:49.956 --> 00:15:51.726 A:middle
这是对 Swift 源编译套件

00:15:51.786 --> 00:15:54.466 A:middle
实行 Osize 优化的结果 其中

00:15:54.466 --> 00:15:55.546 A:middle
包括一系列

00:15:55.546 --> 00:15:58.266 A:middle
GitHub 项目 如框架和 App

00:15:59.156 --> 00:16:00.176 A:middle
可以看到 优化范围

