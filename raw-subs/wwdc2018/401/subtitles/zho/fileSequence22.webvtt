WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:21:59.676 --> 00:22:01.536 A:middle
合成 equality（相等性）

00:22:01.536 --> 00:22:02.926 A:middle
的使用

00:22:03.386 --> 00:22:04.966 A:middle
如果忘记了实现部分

00:22:05.186 --> 00:22:06.326 A:middle
编译器会为你

00:22:06.326 --> 00:22:08.046 A:middle
补上 前提是

00:22:08.046 --> 00:22:10.036 A:middle
存储属性本身为 Equatable

00:22:11.076 --> 00:22:12.626 A:middle
这也适用于 Hashable

00:22:13.996 --> 00:22:15.726 A:middle
那么如果是泛型呢

00:22:16.266 --> 00:22:17.986 A:middle
这个数据类型中

00:22:17.986 --> 00:22:19.556 A:middle
值可能是

00:22:19.556 --> 00:22:22.316 A:middle
左类型的实例 或者是右类型的实例

00:22:22.936 --> 00:22:26.216 A:middle
我想让左右类型都为

00:22:26.216 --> 00:22:28.876 A:middle
Equatable  因为我想令这两个类型

00:22:28.876 --> 00:22:31.046 A:middle
为函数 错误（errors）

00:22:31.046 --> 00:22:32.446 A:middle
或其他不为 Equatable 的类型

00:22:32.916 --> 00:22:34.326 A:middle
但显然 我可以定义

00:22:34.326 --> 00:22:36.226 A:middle
条件一致性 这样

00:22:36.226 --> 00:22:37.506 A:middle
如果左右类型都为

00:22:37.506 --> 00:22:39.726 A:middle
Equatable  二者之一即为 Equatable

00:22:40.116 --> 00:22:41.696 A:middle
但还可以进一步改进

00:22:42.166 --> 00:22:43.666 A:middle
注意此处的可等性

00:22:43.666 --> 00:22:45.576 A:middle
实现 只有一种

00:22:45.576 --> 00:22:47.616 A:middle
显然正确的实现方式

00:22:47.946 --> 00:22:49.186 A:middle
需要确保两个值

00:22:49.186 --> 00:22:51.416 A:middle
包含相同的样例

00:22:51.416 --> 00:22:53.286 A:middle
如果确实如此 则需要检查载体（payloads）

00:22:53.286 --> 00:22:53.996 A:middle
以确保可等性

00:22:54.776 --> 00:22:56.396 A:middle
你可能会想 

00:22:56.396 --> 00:22:57.426 A:middle
编译器应该能够

00:22:57.426 --> 00:22:58.926 A:middle
替你进行合成

00:22:58.926 --> 00:23:00.256 A:middle
Swift 4.2 中确实可以

