WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:57.686 --> 00:31:00.196 A:middle
看看它的思维模型

00:31:00.196 --> 00:31:01.266 A:middle
应该如何理解它

00:31:01.966 --> 00:31:04.426 A:middle
从 Swift 3 开始

00:31:04.426 --> 00:31:06.326 A:middle
不是表达式的一种类型

00:31:06.816 --> 00:31:08.006 A:middle
不要认为它是一种类型

00:31:08.446 --> 00:31:09.856 A:middle
而要认为

00:31:09.856 --> 00:31:11.256 A:middle
它是声明的

00:31:11.256 --> 00:31:13.096 A:middle
特性之一

00:31:13.996 --> 00:31:15.756 A:middle
当你引用这种声明是

00:31:15.756 --> 00:31:17.526 A:middle
编译器会首先

00:31:17.846 --> 00:31:19.186 A:middle
检查它的类型

00:31:19.186 --> 00:31:21.536 A:middle
看它是不是普通的选项

00:31:21.536 --> 00:31:23.006 A:middle
如果在它的使用场景中

00:31:23.006 --> 00:31:24.556 A:middle
它不合理

00:31:24.746 --> 00:31:26.916 A:middle
编译器就会将其解析

00:31:26.916 --> 00:31:28.096 A:middle
进行类型检查 将其标记为

00:31:28.096 --> 00:31:28.876 A:middle
下划线类型（underlined type）

00:31:30.296 --> 00:31:31.746 A:middle
我们来看看第一种

00:31:31.746 --> 00:31:32.506 A:middle
情况的例子

00:31:33.236 --> 00:31:34.886 A:middle
这里有两个函数

00:31:34.966 --> 00:31:36.596 A:middle
第一个会生成

00:31:36.596 --> 00:31:37.906 A:middle
整型的隐式解析选项

00:31:37.906 --> 00:31:39.656 A:middle
第二个则会接受

00:31:39.656 --> 00:31:41.226 A:middle
任何类型的传入值

00:31:41.836 --> 00:31:43.306 A:middle
我要用第一个函数的

00:31:43.306 --> 00:31:45.256 A:middle
结果 来调用第二个函数

00:31:45.916 --> 00:31:47.966 A:middle
这个例子中 我可以

00:31:47.966 --> 00:31:50.506 A:middle
在任意（Any）类型中存入整型选项

00:31:50.856 --> 00:31:53.206 A:middle
不会进行强制解析

00:31:53.466 --> 00:31:55.896 A:middle
值会变成一个普通的选项

00:31:55.896 --> 00:31:59.966 A:middle
我们再看看第二种情况的例子

