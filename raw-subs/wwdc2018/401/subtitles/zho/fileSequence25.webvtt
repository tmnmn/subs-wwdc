WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:58.536 --> 00:25:01.066 A:middle
所以 在 Swift 4.2 中 我们添加了

00:25:01.066 --> 00:25:02.476 A:middle
更好的 API 实现该功能

00:25:03.316 --> 00:25:05.396 A:middle
可以回想一下 Swift 4

00:25:05.396 --> 00:25:06.896 A:middle
和 4.1 中的 Hashable 协议

00:25:07.486 --> 00:25:09.076 A:middle
其中一个 hashValue

00:25:09.076 --> 00:25:10.446 A:middle
要求（requirement） 返回一个

00:25:10.446 --> 00:25:11.696 A:middle
整型值

00:25:12.446 --> 00:25:14.676 A:middle
Swift 4.2 中 我们重新设计了

00:25:14.676 --> 00:25:16.936 A:middle
Hashable 协议 现在

00:25:17.296 --> 00:25:19.746 A:middle
有了新的 Hash into 要求

00:25:20.126 --> 00:25:21.346 A:middle
Hash into 不产生

00:25:21.346 --> 00:25:23.466 A:middle
单一哈希值

00:25:23.466 --> 00:25:26.146 A:middle
而是选用一个 Hasher 实例

00:25:26.146 --> 00:25:27.636 A:middle
之后可以将

00:25:27.636 --> 00:25:29.616 A:middle
多个值传入 Hasher

00:25:29.616 --> 00:25:31.376 A:middle
Hasher 会结合传入值 生成一个哈希值

00:25:32.306 --> 00:25:34.096 A:middle
回到城市数据类型的

00:25:34.096 --> 00:25:36.076 A:middle
例子 我们只需要 

00:25:36.076 --> 00:25:38.226 A:middle
对我们给出的 Hasher 对象实例中

00:25:38.226 --> 00:25:42.576 A:middle
传入的城市名和州

00:25:42.576 --> 00:25:44.596 A:middle
进行递归的

00:25:44.596 --> 00:25:45.316 A:middle
Hash into 调用

00:25:46.486 --> 00:25:49.786 A:middle
Hasher 中的

00:25:49.786 --> 00:25:51.726 A:middle
哈希合并算法

00:25:51.726 --> 00:25:53.526 A:middle
可以有效平衡

00:25:53.526 --> 00:25:55.146 A:middle
哈希值质量和性能

00:25:55.476 --> 00:25:56.556 A:middle
还可以作为额外保护

00:25:56.606 --> 00:25:57.816 A:middle
抵御阻断服务攻击

00:25:57.816 --> 00:25:59.686 A:middle
为此 它使用了

00:25:59.686 --> 00:26:01.616 A:middle
App 启动时生成的

