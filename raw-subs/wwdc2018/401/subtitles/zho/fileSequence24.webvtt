WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:01.286 --> 00:24:02.796 A:middle
如果我想计算

00:24:02.836 --> 00:24:04.566 A:middle
城市对象的哈希值

00:24:05.066 --> 00:24:06.986 A:middle
我就要算出

00:24:07.016 --> 00:24:08.336 A:middle
城市名的哈希值和

00:24:08.336 --> 00:24:09.636 A:middle
州的哈希值

00:24:09.636 --> 00:24:11.086 A:middle
再想办法结合二者

00:24:11.646 --> 00:24:12.686 A:middle
但该怎么做呢

00:24:13.296 --> 00:24:15.286 A:middle
可以用异或运算

00:24:15.286 --> 00:24:18.246 A:middle
也可以用

00:24:18.246 --> 00:24:20.196 A:middle
网上随便找的

00:24:20.196 --> 00:24:21.866 A:middle
或者自己编的

00:24:21.866 --> 00:24:22.656 A:middle
运算方式

00:24:23.246 --> 00:24:24.976 A:middle
但这两种办法

00:24:24.976 --> 00:24:27.306 A:middle
都不够好 好像

00:24:27.306 --> 00:24:28.896 A:middle
结合哈希值的函数

00:24:29.176 --> 00:24:30.556 A:middle
是一种魔法似的

00:24:30.876 --> 00:24:32.336 A:middle
而出错的成本

00:24:32.336 --> 00:24:34.376 A:middle
也相当高 因为

00:24:34.376 --> 00:24:35.846 A:middle
字典和集合

00:24:35.846 --> 00:24:37.526 A:middle
要想具备良好性能

00:24:37.526 --> 00:24:39.716 A:middle
确实需要依赖

00:24:39.716 --> 00:24:41.416 A:middle
高质量的哈希函数

00:24:42.146 --> 00:24:44.266 A:middle
同时也有安全考量

00:24:44.636 --> 00:24:46.966 A:middle
如果攻击者

00:24:46.966 --> 00:24:49.336 A:middle
打造的输入能生成

00:24:49.336 --> 00:24:51.086 A:middle
相同的哈希值

00:24:51.086 --> 00:24:52.336 A:middle
并通过互联网发给你的 App 

00:24:52.396 --> 00:24:54.286 A:middle
就可能降低 App

00:24:54.286 --> 00:24:55.466 A:middle
运行速度 以致

00:24:55.466 --> 00:24:56.906 A:middle
无法使用 即发起

00:24:56.906 --> 00:24:58.056 A:middle
阻断服务攻击（denial-of-service attack）

00:24:58.536 --> 00:25:01.066 A:middle
所以 在 Swift 4.2 中 我们添加了

