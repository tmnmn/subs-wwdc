WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:59.606 --> 00:33:00.956 A:middle
接下来 我就可以用这个

00:33:01.016 --> 00:33:03.166 A:middle
typealias 创建数组

00:33:03.166 --> 00:33:04.756 A:middle
从而使编译器的行为

00:33:04.756 --> 00:33:06.906 A:middle
匪夷所思 令代码难以理解

00:33:07.596 --> 00:33:09.516 A:middle
因此 在 Swift 4.2 中 我们

00:33:09.516 --> 00:33:10.816 A:middle
重新采用了

00:33:10.816 --> 00:33:12.556 A:middle
隐式解析选项

00:33:12.666 --> 00:33:14.736 A:middle
完美契合我之前

00:33:14.736 --> 00:33:17.186 A:middle
提到的思维模型

00:33:17.386 --> 00:33:19.226 A:middle
这一段匪夷所思的代码

00:33:19.226 --> 00:33:20.986 A:middle
现在会生成编译时间错误

00:33:21.306 --> 00:33:23.586 A:middle
编译器也会将其

00:33:23.946 --> 00:33:25.816 A:middle
按照普通整型数组

00:33:25.816 --> 00:33:27.576 A:middle
或整型选项数组来解析

00:33:28.546 --> 00:33:30.836 A:middle
大多数代码不会

00:33:30.836 --> 00:33:32.266 A:middle
因隐式解析选项的

00:33:32.266 --> 00:33:33.626 A:middle
这一变化而受影响

00:33:34.036 --> 00:33:35.436 A:middle
但如果你碰巧

00:33:35.436 --> 00:33:37.426 A:middle
用到了这些极端案例

00:33:37.426 --> 00:33:38.696 A:middle
我建议你看一看

00:33:38.746 --> 00:33:41.096 A:middle
Swift.org 上的这篇博客文章

00:33:41.096 --> 00:33:42.486 A:middle
这篇文章包含更多细节

00:33:42.486 --> 00:33:44.736 A:middle
举了很多例子 来说明

00:33:44.736 --> 00:33:47.136 A:middle
变化的种类和方式

00:33:47.376 --> 00:33:50.566 A:middle
好的 还有最后一项

00:33:50.986 --> 00:33:52.566 A:middle
我们来谈谈内存

00:33:52.566 --> 00:33:53.866 A:middle
独占性检查（memory exclusivity checking）

00:33:55.196 --> 00:33:57.946 A:middle
大家还记得 在 Swift 4 中 我们

00:33:57.946 --> 00:33:59.896 A:middle
带来了所谓的

00:33:59.896 --> 00:34:01.386 A:middle
内存独占性检查

