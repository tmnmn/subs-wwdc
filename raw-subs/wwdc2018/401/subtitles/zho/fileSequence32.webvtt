WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:00.876 --> 00:32:02.856 A:middle
现在 第一个函数生成

00:32:02.856 --> 00:32:05.486 A:middle
对不起 第二个函数

00:32:05.486 --> 00:32:07.086 A:middle
现在接受整型

00:32:07.516 --> 00:32:09.066 A:middle
如果我使用第一个函数的

00:32:09.066 --> 00:32:10.646 A:middle
结果 调用第二个

00:32:10.706 --> 00:32:13.006 A:middle
函数 我就不能

00:32:13.086 --> 00:32:14.986 A:middle
传递整型选项 因为

00:32:14.986 --> 00:32:16.126 A:middle
函数需要整型

00:32:16.596 --> 00:32:18.246 A:middle
所以 编译器必须进行

00:32:18.246 --> 00:32:21.296 A:middle
强制解析 之后

00:32:21.296 --> 00:32:22.656 A:middle
代码运行正常 因为这里需要整型

00:32:22.836 --> 00:32:26.266 A:middle
也传入了整型 这个思维模型

00:32:26.346 --> 00:32:27.626 A:middle
可以很好地

00:32:27.626 --> 00:32:29.506 A:middle
帮助理解隐式解析选项

00:32:30.206 --> 00:32:32.566 A:middle
但直到最近 编译器

00:32:32.776 --> 00:32:34.166 A:middle
还是会遇到一些不遵从

00:32:34.166 --> 00:32:35.636 A:middle
此模型的极端案例

00:32:36.316 --> 00:32:38.956 A:middle
所以记住 隐式解析选项

00:32:38.956 --> 00:32:41.696 A:middle
不能是其他类型的一部分

00:32:42.416 --> 00:32:43.706 A:middle
Swift 4.2 中

00:32:43.706 --> 00:32:44.646 A:middle
依然如此

00:32:44.816 --> 00:32:46.616 A:middle
数组不能包含

00:32:46.676 --> 00:32:48.296 A:middle
隐式解析整型

00:32:49.136 --> 00:32:51.566 A:middle
但在 Swift 4 中

00:32:51.876 --> 00:32:53.536 A:middle
有一些像这样的极端案例

00:32:53.536 --> 00:32:55.606 A:middle
我可以定义一个 typealias

00:32:55.796 --> 00:32:57.596 A:middle
它的实际类型可以是

00:32:57.776 --> 00:32:59.606 A:middle
隐式解析整型

00:32:59.606 --> 00:33:00.956 A:middle
接下来 我就可以用这个

