WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:58.316 --> 00:20:00.666 A:middle
因为如果数列的

00:20:00.666 --> 00:20:01.836 A:middle
元素类型不为

00:20:01.836 --> 00:20:03.366 A:middle
Equatable 例如函数

00:20:03.396 --> 00:20:06.566 A:middle
你也不能让数列为 Equatable

00:20:07.956 --> 00:20:09.286 A:middle
但显然 如果数列的

00:20:09.326 --> 00:20:10.846 A:middle
元素类型为 Equatable

00:20:10.846 --> 00:20:12.726 A:middle
我就可以为数组

00:20:12.726 --> 00:20:14.516 A:middle
定义等值运算

00:20:14.516 --> 00:20:16.376 A:middle
以比较数组中的元素对

00:20:17.116 --> 00:20:18.516 A:middle
而这就是条件一致性

00:20:18.516 --> 00:20:20.116 A:middle
（conditional conformance）对标准库

00:20:20.116 --> 00:20:21.286 A:middle
发挥的作用

00:20:21.376 --> 00:20:23.076 A:middle
现在 如果数组元素

00:20:23.076 --> 00:20:24.916 A:middle
类型为 Equatable

00:20:24.916 --> 00:20:26.246 A:middle
那么数组样例也可以

00:20:26.246 --> 00:20:27.056 A:middle
实现 Equatable

00:20:27.416 --> 00:20:29.776 A:middle
Swift 4.2 中 之前展示的

00:20:29.776 --> 00:20:31.366 A:middle
例子可以运行

00:20:31.856 --> 00:20:34.776 A:middle
除了数组为 Equatable 外

00:20:34.776 --> 00:20:37.636 A:middle
标准库还定义了其他一些

00:20:37.636 --> 00:20:38.896 A:middle
条件一致性

00:20:39.436 --> 00:20:41.026 A:middle
例如 选项（options）

00:20:41.026 --> 00:20:42.726 A:middle
和字典（dictionaries）也是 Equatable

00:20:42.726 --> 00:20:44.126 A:middle
前提是它们的

00:20:44.126 --> 00:20:46.486 A:middle
元素类型为 Equatable

00:20:46.536 --> 00:20:49.576 A:middle
Hashable Encodable 和

00:20:49.576 --> 00:20:51.306 A:middle
Decodable 同理

00:20:52.516 --> 00:20:57.576 A:middle
[ 掌声 ]

00:20:58.076 --> 00:20:59.746 A:middle
这样一来 你就可以

00:20:59.746 --> 00:21:01.156 A:middle
用全新的方法

