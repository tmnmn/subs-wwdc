WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:58.786 --> 00:12:02.246 A:middle
这一组合显著减少了

00:12:02.246 --> 00:12:04.136 A:middle
我们现在努力

00:12:04.136 --> 00:12:08.666 A:middle
消除或大幅减少的冗余工作

00:12:10.036 --> 00:12:12.496 A:middle
而这样组合的问题在于 它会减慢

00:12:12.496 --> 00:12:13.296 A:middle
增量构建的速度

00:12:13.506 --> 00:12:14.716 A:middle
只要你修改了目标中的

00:12:14.716 --> 00:12:16.806 A:middle
一个文件 整个目标就要重新构建

00:12:17.496 --> 00:12:18.836 A:middle
而 Xcode 10 改进了

00:12:18.836 --> 00:12:20.406 A:middle
调试版本构建 我们认为

00:12:20.406 --> 00:12:21.936 A:middle
你们不再需要

00:12:21.986 --> 00:12:24.416 A:middle
使用这种权宜之计 我们也

00:12:24.416 --> 00:12:25.626 A:middle
发现 默认的

00:12:25.626 --> 00:12:27.316 A:middle
增量构建 表现

00:12:27.316 --> 00:12:29.356 A:middle
同这种组合相当 甚至更好

00:12:29.356 --> 00:12:30.976 A:middle
特别是现在 增量构建得到了正式支持

00:12:34.696 --> 00:12:35.826 A:middle
我们来谈谈

00:12:35.826 --> 00:12:37.006 A:middle
运行时得到的

00:12:37.006 --> 00:12:38.256 A:middle
底层优化 这也是

00:12:38.256 --> 00:12:39.356 A:middle
实现二进制兼容的

00:12:39.406 --> 00:12:40.586 A:middle
环节之一

00:12:43.436 --> 00:12:45.126 A:middle
Swift 使用自动内存

00:12:45.126 --> 00:12:47.726 A:middle
管理 并且像 Objective-C 一样

00:12:47.726 --> 00:12:49.236 A:middle
使用引用计数（reference counting）

00:12:49.386 --> 00:12:51.026 A:middle
管理对象实例

00:12:51.916 --> 00:12:53.526 A:middle
这张幻灯片上 用备注

00:12:53.526 --> 00:12:54.786 A:middle
显示出编译器在哪里

00:12:54.786 --> 00:12:56.426 A:middle
插入（insert） 保留（retain） 释放（release）

00:12:57.516 --> 00:13:02.116 A:middle
这是 Swift 4.1 中的运行方式

