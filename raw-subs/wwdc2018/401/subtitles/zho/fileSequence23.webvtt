WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.926 --> 00:23:00.256 A:middle
Swift 4.2 中确实可以

00:23:01.176 --> 00:23:02.666 A:middle
该功能也可用于

00:23:02.666 --> 00:23:03.186 A:middle
Hashable

00:23:04.676 --> 00:23:07.166 A:middle
比方说 现在就可以创建

00:23:07.356 --> 00:23:09.786 A:middle
元素为整型或字符串的集合了

00:23:11.546 --> 00:23:11.656 A:middle
好的

00:23:12.516 --> 00:23:15.676 A:middle
[ 掌声 ]

00:23:16.176 --> 00:23:18.146 A:middle
有时 你确实需要

00:23:18.146 --> 00:23:19.526 A:middle
手动实现

00:23:19.586 --> 00:23:22.766 A:middle
可等性和哈希值（Hashing）

00:23:23.436 --> 00:23:25.456 A:middle
我们来看一个例子

00:23:26.616 --> 00:23:27.866 A:middle
假如说 有一个数据类型

00:23:28.006 --> 00:23:30.796 A:middle
表示一座城市 其中

00:23:30.796 --> 00:23:32.166 A:middle
包括城市名 包括所在的

00:23:32.166 --> 00:23:34.296 A:middle
州 还包括城市的人口

00:23:34.706 --> 00:23:35.556 A:middle
在这个例子中

00:23:35.556 --> 00:23:38.006 A:middle
我只需要

00:23:38.006 --> 00:23:39.536 A:middle
比较城市名和州

00:23:39.536 --> 00:23:41.456 A:middle
以确保可等性

00:23:41.456 --> 00:23:42.826 A:middle
如果数值相等 就不需要

00:23:42.826 --> 00:23:43.926 A:middle
对比人口了

00:23:44.616 --> 00:23:46.446 A:middle
如果我让编译器

00:23:46.446 --> 00:23:48.056 A:middle
合成可等性的

00:23:48.056 --> 00:23:49.706 A:middle
实现 就会产生

00:23:49.706 --> 00:23:52.006 A:middle
冗余 因为它还比较了

00:23:52.006 --> 00:23:53.046 A:middle
人口信息

00:23:53.776 --> 00:23:55.436 A:middle
我当然可以把这部分

00:23:55.436 --> 00:23:56.976 A:middle
写成代码 或许此时

00:23:56.976 --> 00:23:57.636 A:middle
这样还可以

00:23:58.556 --> 00:23:59.796 A:middle
但 Hashable 呢

