WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:57.516 --> 00:13:02.116 A:middle
这是 Swift 4.1 中的运行方式

00:13:02.316 --> 00:13:03.276 A:middle
对象创建时

00:13:03.276 --> 00:13:04.716 A:middle
会关联一个 +1

00:13:04.716 --> 00:13:05.896 A:middle
引用计数

00:13:05.896 --> 00:13:08.176 A:middle
惯例是 如果

00:13:08.176 --> 00:13:09.596 A:middle
对象作为一个参数

00:13:09.596 --> 00:13:10.806 A:middle
传递到另一个函数中

00:13:11.286 --> 00:13:12.406 A:middle
那个函数的调用

00:13:12.466 --> 00:13:14.526 A:middle
就应该释放对象

00:13:14.986 --> 00:13:16.626 A:middle
这基本上就是让

00:13:16.626 --> 00:13:18.036 A:middle
函数调用

00:13:18.036 --> 00:13:19.406 A:middle
释放对象

00:13:20.376 --> 00:13:21.556 A:middle
这样一来 就有

00:13:21.556 --> 00:13:22.926 A:middle
机会改进性能 缩减

00:13:22.926 --> 00:13:25.156 A:middle
一些对象的生命周期

00:13:25.156 --> 00:13:26.936 A:middle
限制到最小范围

00:13:27.806 --> 00:13:29.976 A:middle
但是 如果你的代码

00:13:30.056 --> 00:13:32.076 A:middle
将对象传递到

00:13:32.076 --> 00:13:33.886 A:middle
不同 API 的话

00:13:34.276 --> 00:13:35.236 A:middle
可能会是这样

00:13:35.906 --> 00:13:37.096 A:middle
由于存在这种

00:13:37.136 --> 00:13:38.856 A:middle
调用惯例 就依然存在

00:13:38.856 --> 00:13:40.226 A:middle
这种往复操作

00:13:40.226 --> 00:13:41.316 A:middle
最初的引用计数

00:13:41.366 --> 00:13:42.466 A:middle
在最后的调用中

00:13:42.516 --> 00:13:43.066 A:middle
抵消

00:13:43.466 --> 00:13:44.666 A:middle
但中间的步骤

00:13:44.666 --> 00:13:45.776 A:middle
又应当有额外的

00:13:45.776 --> 00:13:48.246 A:middle
保留和释放过程 因为

00:13:48.246 --> 00:13:49.956 A:middle
这是惯例

00:13:50.876 --> 00:13:52.406 A:middle
这样会造成浪费 因为

00:13:52.626 --> 00:13:53.886 A:middle
对象在函数

00:13:53.886 --> 00:13:55.156 A:middle
执行期间

00:13:55.156 --> 00:13:57.106 A:middle
始终存活（alive）

00:13:57.816 --> 00:13:59.876 A:middle
所以 Swift 4.2 中 我们改变了

00:13:59.876 --> 00:14:01.396 A:middle
调用惯例 这样一来

