WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:59.296 --> 00:19:01.966 A:middle
新的 CaseIterable 协议

00:19:01.966 --> 00:19:03.346 A:middle
如果你表示遵从（conformance）

00:19:03.406 --> 00:19:04.726 A:middle
这一协议 编译器就会

00:19:04.726 --> 00:19:06.676 A:middle
将包含所有样例的属性

00:19:06.676 --> 00:19:07.096 A:middle
同步

00:19:07.096 --> 00:19:08.976 A:middle
简短而有效

00:19:09.516 --> 00:19:12.546 A:middle
[ 鼓掌 ]

00:19:13.046 --> 00:19:15.216 A:middle
下一项改进 我们

00:19:15.216 --> 00:19:16.476 A:middle
要去除另一个

00:19:16.476 --> 00:19:17.806 A:middle
鸡肋代码的根源

00:19:18.016 --> 00:19:19.216 A:middle
这种情况下

00:19:19.306 --> 00:19:20.436 A:middle
你的代码往往

00:19:20.626 --> 00:19:21.786 A:middle
不够泛型（generic）

00:19:22.726 --> 00:19:24.916 A:middle
Swift 4 中 我们为序列

00:19:24.956 --> 00:19:26.596 A:middle
引入了 contains() 方法

00:19:27.006 --> 00:19:28.506 A:middle
这就要求

00:19:28.506 --> 00:19:30.106 A:middle
序列的元素类型

00:19:30.106 --> 00:19:32.186 A:middle
为 Equatable

00:19:32.186 --> 00:19:33.666 A:middle
才能找出所需的元素

00:19:34.636 --> 00:19:36.736 A:middle
当然 我可以对

00:19:36.736 --> 00:19:37.966 A:middle
字符串组成的数组调用

00:19:38.236 --> 00:19:39.616 A:middle
因为字符串是 Equatable 类型

00:19:39.616 --> 00:19:41.516 A:middle
但如果对数组组成的数组

00:19:41.516 --> 00:19:42.346 A:middle
调用呢

00:19:43.226 --> 00:19:45.736 A:middle
如果子数组包含整型（integer）

00:19:45.736 --> 00:19:47.756 A:middle
类型就不为 Equatable

00:19:48.126 --> 00:19:49.486 A:middle
也就是说

00:19:49.486 --> 00:19:50.596 A:middle
编译时间错误

00:19:51.796 --> 00:19:53.796 A:middle
你可能会问 为什么

00:19:53.796 --> 00:19:55.106 A:middle
标准库不让

00:19:55.196 --> 00:19:56.796 A:middle
所有数列为 Equatable 呢

00:19:57.136 --> 00:19:58.316 A:middle
但那样不合逻辑

00:19:58.316 --> 00:20:00.666 A:middle
因为如果数列的

