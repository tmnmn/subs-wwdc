WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.146 --> 00:36:00.556 A:middle
那些新的累计的

00:36:00.556 --> 00:36:02.326 A:middle
数量系列样本 并且

00:36:02.326 --> 00:36:04.416 A:middle
以更有效率的方式存储数据

00:36:05.696 --> 00:36:07.216 A:middle
那么让我们开始 sample query 吧

00:36:07.246 --> 00:36:09.526 A:middle
像我刚提到的

00:36:09.526 --> 00:36:11.386 A:middle
你可以通过这种方式来

00:36:11.386 --> 00:36:13.436 A:middle
看得更深入并且真正理解

00:36:13.436 --> 00:36:15.506 A:middle
组成一个数量系列样本的

00:36:15.506 --> 00:36:17.386 A:middle
独立的 HK 数量

00:36:18.606 --> 00:36:20.096 A:middle
在代码里 当然 我们

00:36:20.096 --> 00:36:21.556 A:middle
首先想要搞清楚

00:36:21.616 --> 00:36:22.616 A:middle
我们会把这些新的数量

00:36:22.616 --> 00:36:23.876 A:middle
存储在哪里

00:36:23.936 --> 00:36:25.276 A:middle
在我的例子中 我会把它

00:36:25.276 --> 00:36:26.366 A:middle
存在一个数量的数组中

00:36:26.956 --> 00:36:30.176 A:middle
接下来我们初始化 query

00:36:30.556 --> 00:36:32.276 A:middle
我们用我们感兴趣的样本

00:36:32.276 --> 00:36:33.226 A:middle
来初始化它

00:36:33.486 --> 00:36:35.236 A:middle
我们的完成处理器

00:36:35.236 --> 00:36:36.426 A:middle
正是这部分工作

00:36:36.426 --> 00:36:36.926 A:middle
进行的地方

00:36:37.406 --> 00:36:39.526 A:middle
在我的例子中 我有一个

00:36:39.526 --> 00:36:41.026 A:middle
叫做 analyzeQuantity 的方法

00:36:41.026 --> 00:36:42.156 A:middle
会来完成我想要对数量

00:36:42.156 --> 00:36:43.756 A:middle
做的事情

00:36:43.756 --> 00:36:45.656 A:middle
就是把它添加到

00:36:45.656 --> 00:36:46.636 A:middle
刚才我声明的

00:36:46.636 --> 00:36:47.456 A:middle
数量数组中

00:36:48.356 --> 00:36:50.636 A:middle
最后 我们来执行 query

00:36:51.226 --> 00:36:52.416 A:middle
就是如此简单

00:36:53.036 --> 00:36:54.336 A:middle
你们中有人熟悉我们的

00:36:54.336 --> 00:36:55.636 A:middle
其他的一些 query

00:36:55.806 --> 00:36:57.456 A:middle
这里的表现非常相似

00:36:59.546 --> 00:37:01.376 A:middle
接下来 我们有

