WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:07:59.336 --> 00:08:01.036 A:middle
互联网服务 使用

00:08:01.036 --> 00:08:04.266 A:middle
生命周期短的 DNS 记录

00:08:04.666 --> 00:08:06.596 A:middle
他们之所以这样做

00:08:06.596 --> 00:08:08.736 A:middle
是因为如果一个数据中心出了故障

00:08:08.736 --> 00:08:10.496 A:middle
他们希望能够更新 DNS

00:08:10.496 --> 00:08:12.686 A:middle
从而迅速地把流量导向

00:08:12.686 --> 00:08:13.666 A:middle
另一个不同的数据中心

00:08:15.266 --> 00:08:16.636 A:middle
这个方法的问题在于

00:08:17.076 --> 00:08:19.166 A:middle
你在为一个

00:08:19.166 --> 00:08:21.506 A:middle
几乎从未发生过的情况牺牲性能

00:08:21.596 --> 00:08:24.186 A:middle
数据中心极少出故障

00:08:25.066 --> 00:08:27.316 A:middle
这意味着

00:08:27.316 --> 00:08:29.276 A:middle
每当一个 DNS 地址记录过期

00:08:29.276 --> 00:08:31.096 A:middle
你的客户端不得不

00:08:31.096 --> 00:08:32.736 A:middle
再用一个往返延迟

00:08:33.046 --> 00:08:35.496 A:middle
去等候来自 DNS 服务器的回应

00:08:35.496 --> 00:08:37.306 A:middle
而这个回应

00:08:37.306 --> 00:08:39.155 A:middle
和它上次获知的一模一样

00:08:39.756 --> 00:08:42.736 A:middle
所以 考虑到这点

00:08:42.736 --> 00:08:44.826 A:middle
我们做了一个

00:08:44.826 --> 00:08:45.216 A:middle
可以实现的优化

00:08:45.866 --> 00:08:47.856 A:middle
如果你传了参与这种新方式的标记

00:08:47.856 --> 00:08:50.866 A:middle
那么当你发起 DNS 请求时

00:08:50.866 --> 00:08:52.846 A:middle
如果我们的缓存中

00:08:52.846 --> 00:08:54.446 A:middle
有一个此前过期的回应

00:08:54.446 --> 00:08:56.956 A:middle
我们会把它立即给你

00:08:57.056 --> 00:08:59.286 A:middle
与此同时

00:08:59.286 --> 00:09:00.876 A:middle
进行原本就会做的

