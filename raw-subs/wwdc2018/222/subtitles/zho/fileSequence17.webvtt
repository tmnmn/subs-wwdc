WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:57.885 --> 00:17:00.020 align:middle line:-1
而使用常规的字符串是做不到的

00:17:01.555 --> 00:17:05.325 align:middle line:-2
与之相似的 字典可以表示
像是这个列表一样的模型

00:17:05.626 --> 00:17:07.627 align:middle line:-1
或是表示任意的我们根本不了解的

00:17:07.694 --> 00:17:08.962 align:middle line:-1
用户数据

00:17:10.163 --> 00:17:12.465 align:middle line:-1
不用在各个地方执行相同的验证

00:17:12.532 --> 00:17:14.902 align:middle line:-1
来保证所有我们关注的字段是有效的

00:17:14.968 --> 00:17:17.204 align:middle line:-1
而是使用我们自己的模型类型

00:17:17.271 --> 00:17:19.339 align:middle line:-1
保障总是在那里不是很好吗？

00:17:21.108 --> 00:17:22.675 align:middle line:-1
是的 在我们的例子中

00:17:22.976 --> 00:17:25.811 align:middle line:-2
我们想在所有可能的地方
使用结构化数据

00:17:25.878 --> 00:17:28.281 align:middle line:-2
我们可以将主要数据
作为构件块来使用

00:17:28.715 --> 00:17:30.384 align:middle line:-1
不过我们想处理那个数据形式

00:17:31.285 --> 00:17:32.786 align:middle line:-1
让我们来看下要如何实现

00:17:35.522 --> 00:17:37.991 align:middle line:-1
在我app的其他地方有个购买类型

00:17:38.058 --> 00:17:39.393 align:middle line:-1
就像是这样

00:17:40.561 --> 00:17:44.031 align:middle line:-2
当有顾客进行购买时
我会将该数据存储到磁盘上

00:17:44.097 --> 00:17:45.465 align:middle line:-1
然后当他们打开app时

00:17:45.532 --> 00:17:47.434 align:middle line:-1
即使他们没有连接到网络

00:17:47.501 --> 00:17:49.102 align:middle line:-1
也可浏览自己的购买历史纪录

00:17:50.103 --> 00:17:52.239 align:middle line:-1
每条购买记录会追踪

00:17:52.306 --> 00:17:53.407 align:middle line:-1
它所对应产品列表项

00:17:53.473 --> 00:17:56.610 align:middle line:-2
是何时进行的购买
以及一个收据

00:17:58.378 --> 00:18:02.182 align:middle line:-2
我可以像这样 利用NS编码
和NS键归档将其保存到磁盘上

