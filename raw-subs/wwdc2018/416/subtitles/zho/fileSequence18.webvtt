WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.696 --> 00:18:01.846 A:middle
举个例子

00:18:01.996 --> 00:18:03.786 A:middle
我有一张非常漂亮的图片

00:18:03.786 --> 00:18:04.986 A:middle
并且我想把它作为

00:18:04.986 --> 00:18:05.496 A:middle
一个 iPad App 的壁纸

00:18:06.646 --> 00:18:10.786 A:middle
它的尺寸是 2048*1536

00:18:10.786 --> 00:18:13.436 A:middle
磁盘上文件的大小是 590KB

00:18:13.966 --> 00:18:16.086 A:middle
但是它实际使用了多少内存呢

00:18:18.516 --> 00:18:19.646 A:middle
10MB

00:18:20.056 --> 00:18:21.746 A:middle
10MB 这可够大的

00:18:22.146 --> 00:18:23.746 A:middle
这是因为

00:18:23.746 --> 00:18:25.066 A:middle
把像素的宽度乘以高

00:18:25.066 --> 00:18:28.406 A:middle
即 2048 乘以 1536

00:18:28.406 --> 00:18:30.016 A:middle
然后每像素乘以 4 字节

00:18:30.016 --> 00:18:30.786 A:middle
就会达到 10MB

00:18:31.706 --> 00:18:33.956 A:middle
那么为什么它会大这么多呢

00:18:35.016 --> 00:18:36.916 A:middle
我们要谈谈图像

00:18:36.916 --> 00:18:38.076 A:middle
是如何在 iOS 上工作的

00:18:38.196 --> 00:18:39.676 A:middle
有加载 解码

00:18:39.706 --> 00:18:40.346 A:middle
和渲染三个阶段

00:18:41.306 --> 00:18:43.516 A:middle
在加载阶段

00:18:43.516 --> 00:18:45.646 A:middle
这个被压缩的 590KB 的 JPEG 文件被接收

00:18:45.646 --> 00:18:48.646 A:middle
并被加载到内存中

00:18:49.856 --> 00:18:51.996 A:middle
在解码阶段 JPEG 文件

00:18:51.996 --> 00:18:55.366 A:middle
将被转换为 GPU 可以读取的格式

00:18:55.936 --> 00:18:56.966 A:middle
图像需要被解压

00:18:56.966 --> 00:18:58.996 A:middle
这使得文件大小增至 10 mb

00:18:59.926 --> 00:19:01.446 A:middle
被解码之后

