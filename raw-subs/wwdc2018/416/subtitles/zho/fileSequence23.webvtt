WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:58.196 --> 00:23:00.036 A:middle
它使用 Streaming API

00:23:00.036 --> 00:23:03.136 A:middle
这样你只需为生成图像

00:23:03.136 --> 00:23:03.996 A:middle
使用一些脏内存

00:23:04.196 --> 00:23:05.566 A:middle
这将为你节省一个内存峰值

00:23:06.076 --> 00:23:09.126 A:middle
例如 这里有一些代码

00:23:09.196 --> 00:23:10.346 A:middle
以及我在磁盘上获得的一个文件

00:23:10.506 --> 00:23:11.996 A:middle
也可以是我下载的一个文件

00:23:12.916 --> 00:23:16.456 A:middle
我现在用 UIImage 绘制一个

00:23:16.546 --> 00:23:17.696 A:middle
更小的矩形

00:23:18.106 --> 00:23:19.796 A:middle
仍然会有一个大峰值

00:23:21.036 --> 00:23:22.626 A:middle
如果切换到 ImageIO

00:23:22.626 --> 00:23:25.236 A:middle
我仍然需要从磁盘加载文件

00:23:25.896 --> 00:23:27.846 A:middle
因为它是一个较低级的 API

00:23:27.846 --> 00:23:29.476 A:middle
我设置了一些参数

00:23:29.476 --> 00:23:30.936 A:middle
来表示我希望这个图像有多大

00:23:31.186 --> 00:23:33.126 A:middle
所以我让它用

00:23:33.126 --> 00:23:34.206 A:middle
CGImageSourceCreateThumbnailAtIndex

00:23:34.246 --> 00:23:35.346 A:middle
创建图像

00:23:35.916 --> 00:23:37.506 A:middle
现在 我可以用 UIImage 封装这个 CGImage

00:23:37.506 --> 00:23:38.956 A:middle
并准备好进行下一步了

00:23:39.096 --> 00:23:40.246 A:middle
我有一个小得多的图像

00:23:40.526 --> 00:23:43.486 A:middle
而且比之前的代码快 50%

00:23:45.146 --> 00:23:47.086 A:middle
我们要讨论的

00:23:47.086 --> 00:23:48.406 A:middle
另一件事是

00:23:48.406 --> 00:23:49.096 A:middle
如何进行后台优化

00:23:49.946 --> 00:23:53.316 A:middle
假设我在一个 App 中

00:23:53.616 --> 00:23:54.886 A:middle
有一个全屏的图像 它很美

00:23:54.886 --> 00:23:55.446 A:middle
我很喜欢

00:23:55.906 --> 00:23:57.376 A:middle
但之后 我需要

00:23:57.376 --> 00:23:58.706 A:middle
到我的主屏幕上处理通知

00:23:58.706 --> 00:24:00.376 A:middle
或者转到

