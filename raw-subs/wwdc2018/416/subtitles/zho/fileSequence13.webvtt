WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.866 --> 00:13:00.206 A:middle
这意味着 vmmap 将输出

00:13:00.206 --> 00:13:01.496 A:middle
内存页的数量

00:13:01.496 --> 00:13:02.376 A:middle
而不仅仅是原始字节

00:13:02.866 --> 00:13:06.796 A:middle
然后我将它传输到 grep

00:13:06.886 --> 00:13:08.206 A:middle
并在那搜索 ‘.dylib’

00:13:08.206 --> 00:13:09.456 A:middle
所以我在这里需要动态库

00:13:11.046 --> 00:13:12.166 A:middle
最后 我将它导入到

00:13:12.166 --> 00:13:13.536 A:middle
一个特别简单的 awk 脚本中

00:13:14.116 --> 00:13:15.816 A:middle
来合计脏列

00:13:15.816 --> 00:13:16.826 A:middle
然后最终将其输出为

00:13:16.826 --> 00:13:17.886 A:middle
脏内存页的数量

00:13:19.386 --> 00:13:20.556 A:middle
我觉得这很酷

00:13:20.556 --> 00:13:22.286 A:middle
而且我一直在使用它

00:13:22.286 --> 00:13:23.676 A:middle
它让你能够

00:13:23.676 --> 00:13:25.096 A:middle
为你和你的团队编写

00:13:25.096 --> 00:13:26.216 A:middle
非常强大的调试工作流

00:13:26.656 --> 00:13:30.466 A:middle
另一个 macOS 开发人员

00:13:30.466 --> 00:13:31.686 A:middle
可能已经熟悉的

00:13:31.686 --> 00:13:33.066 A:middle
命令行实用程序是 leaks

00:13:33.836 --> 00:13:35.306 A:middle
它在运行时跟踪堆中

00:13:35.696 --> 00:13:37.396 A:middle
没有根的对象

00:13:37.726 --> 00:13:38.586 A:middle
所以请记住

00:13:38.586 --> 00:13:39.816 A:middle
如果你在 leaks 中看到一个对象

00:13:39.816 --> 00:13:41.466 A:middle
那它占用的是你无法释放的脏内存

00:13:41.846 --> 00:13:44.866 A:middle
让我们看看 内存调试器中的内存泄漏

00:13:46.176 --> 00:13:48.176 A:middle
这里我有 3 个对象

00:13:48.176 --> 00:13:49.356 A:middle
它们相互之间都有很强的引用

00:13:49.356 --> 00:13:51.166 A:middle
创建了一个经典的 “Retain Cycle（留置环）”

00:13:51.876 --> 00:13:53.766 A:middle
让我们在 leaks 工具中

00:13:54.216 --> 00:13:56.446 A:middle
看看这个泄漏

00:13:56.646 --> 00:13:57.686 A:middle
今年 leaks 已被更新

00:13:57.686 --> 00:13:59.676 A:middle
不仅可以显示

00:13:59.676 --> 00:14:05.396 A:middle
泄漏的对象 还可显示它们所属的 Retain Cycle

