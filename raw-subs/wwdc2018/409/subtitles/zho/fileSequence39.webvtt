WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:57.871 --> 00:39:00.107 align:middle line:-1
相同变量或另一个变量

00:39:02.709 --> 00:39:04.211 align:middle line:-1
所以两者都会尝试

00:39:04.278 --> 00:39:06.780 align:middle line:-1
对这个变量进行排他性访问

00:39:07.614 --> 00:39:10.517 align:middle line:-2
这是不可能的
这就是排他性的意思

00:39:12.219 --> 00:39:15.656 align:middle line:-1
因此它们都将无法获得独家访问权

00:39:16.557 --> 00:39:19.426 align:middle line:-2
它们将不得不再次尝试
直到其中一个成功

00:39:22.029 --> 00:39:23.730 align:middle line:-1
这对性能来说并不是好东西

00:39:25.966 --> 00:39:31.171 align:middle line:-2
因此在ARM v8.1中
它是A10 CPU中的体系结构

00:39:31.371 --> 00:39:33.974 align:middle line:-2
我们有新的指令
在一步内完成所有这些操作

00:39:34.408 --> 00:39:37.010 align:middle line:-1
在某些情况下这可以极大地提高性能

00:39:38.412 --> 00:39:41.215 align:middle line:-2
因此这也是你可以
使用每个函数专门化方法或

00:39:41.448 --> 00:39:45.986 align:middle line:-1
针对整个目标而专门化代码的东西

00:39:47.120 --> 00:39:49.122 align:middle line:-2
只有当你有自己的C11
或C++ 11原子时

00:39:49.189 --> 00:39:52.125 align:middle line:-1
它才是真正有用的东西

00:39:53.093 --> 00:39:56.697 align:middle line:-2
因此一般来说
使用更高级别的库

00:39:56.763 --> 00:39:59.533 align:middle line:-2
例如像GCD或PThread
或os_unfair_lock等容易得多

