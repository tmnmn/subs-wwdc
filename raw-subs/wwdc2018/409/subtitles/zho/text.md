# What's New in LLVM

## Summary
The LLVM suite of compiler tools in Xcode 10 have new language features, improved diagnostics, and more powerful optimizations. Find out about improvements to ARC for Objective-C, keep up with the newest additions to C++, get an overview of new and improved diagnostics and static analyzer checks, and learn about how LLVM compiler technology is delivering faster build times and better runtime performance for your apps.

## Info
* Developer Tools
* WWDC 2018 - Session 409 - iOS, macOS, tvOS, watchOS
* https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/

## Text
 [（LLVM新特性 演讲409）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=17) [早上好 欢迎来到
LLVM新特性的演讲](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=27) [我是Jim Grosbach
你友好的尖尖发型的老板街坊](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=31) [今天在我们将深入了解
为大家带来的所有激动人心的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=33) [新事物的技术细节之前
我先在此给你们讲些](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=38) [关于LLVM的背景知识](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=41) [首先 LLVM不仅仅是编译器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=45) [它是Clang编译器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=50) [和我们每天都使用的C族语言的背景](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=53) [它也为静态分析器 杀毒软件
LLDB调试器提供了动力](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=56) [它也为静态分析器 杀毒软件
LLDB调试器提供了动力](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=56) [并且是GPU着色器编译器下的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=62) [所有Apple移动平台的
优化代码生成框架](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=65) [除此之外
它还为你可能时不时听说过的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=71) [一个叫做Swift的额外小项目
提供了动力](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=76) [和Swift一样
LLVM也是一个开源项目](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=81) [我们都在我们的LLVM
这个飞龙的监视下工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=86) [他通常是个很友好的家伙](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=90) [不过我得提醒你
如果你称他为龙的话](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=92) [他可能会变得有点暴躁
所以不要那样做](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=95) [作为一个开源项目
LLVM是一个合作伙伴](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=99) [我们与来自世界各地](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=104) [不同行业的合作伙
学者、研究人员和爱好者合作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=107) [还有世界各地更多的人](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=110) [这真是太棒了
我们共同努力](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=116) [创造出最伟大的工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=119) [创造出最伟大的工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=119) [来推动科技的发展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=122) [如果你对编译器有兴趣的话](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=124) [我们乐意邀请你加入我们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=129) [你可以去访问LLVM的网站
llvm.org](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=133) [或者你可以在今天晚些时候
在LLVM实验室和我们交谈](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=136) [我们的许多来自Apple的
编译器工程师都将在那里](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=141) [我肯定会非常高兴地与你讲解](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=144) [与所有编译器相关](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=147) [任何一切你想知道的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=150) [今天我们有一套很好的东西
要和你们分享](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=152) [我们有自动引用计数的更新](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=157) [这使得编译器
更容易帮助你进行内存管理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=160) [Xcode 10中有了新诊断方法
静态分析器中有了新检查方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=164) [在构建时它能够帮助
更快地捕获项目中的错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=170) [从而提高代码的质量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=174) [我们的编译器功能
无论是对于Apple平台](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=176) [还是你的app
都可以提高它们的安全性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=179) [还是你的app
都可以提高它们的安全性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=179) [以及还有新的特性
使你能够利用硬件结构上的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=182) [所有真正伟大的新东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=185) [以便能够从我们的平台](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=187) [和架构中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=189) [获得我们都想要的性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=191) [因此 我想邀请我的同事](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=194) [Alex上来谈谈ARC](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=198) [Alex](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=200) [（ARC最新情况）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=201) [谢谢Jim](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=207) [自从我们在几年前引入了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=209) [自动引用计数以来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=211) [它大大简化了
Object-C编程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=214) [一些限制使得从旧的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=218) [手动保留释放模式迁移到
ARC变得更加困难](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=221) [我很高兴地说
我们现在已经解除了这样的限制](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=225) [Xcode 10支持](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=229) [C结构中的
ARC对象指针字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=231) [（C结构中的ARC对象指针！）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=234) [让我们来看一个例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=240) [假设我们想编写一个
食品订购app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=242) [我们想要创建一个
表示菜单项的数据结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=245) [（工程师）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=249) [对于Xcode 9和更早的版本
实际上我们不可能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=250) [使用一个带有ARC对象指针字段的
C结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=254) [所以我们必须在这里使用一个C
一个Objective-C类](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=258) [而现在Xcode 10
允许我们实际创建一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=264) [具有ARC对象指针字段的C结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=268) [让我们继续写我们的食品订购app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=274) [让我们创建一个
为我们订购免费食物的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=278) [在这个函数中
让我们创建一个价格为零的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=281) [MenuItem类的变量项目](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=285) [然后 让我们把这个项目传递到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=288) [另一个实际上
为我们订购食物的函数中去](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=291) [创建项时编译器必须合成那个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=294) [保留项目中
ARC对象指针字段的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=300) [幻灯片上的代码注释演示了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=305) [编译器所合成的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=307) [此代码确保在实际使用项目之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=311) [不会提前发布项目的名称和价格](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=315) [在函数的末尾
“项目”超出了作用域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=321) [并从栈中被释放](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=325) [因此编译器必须合成](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=327) [释放条目中
ARC对象指针字段的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=330) [这可以确保在项目释放时
不会泄露它的名称和价格](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=335) [以前在使用手动保留释放模式时
可以使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=342) [Objective-C
对象指针字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=347) [但是你必须自己编写保留和释放](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=350) [使用ARC编译器会为你](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=355) [隐藏所有这些复杂性
并合成那个保留和释放字段的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=359) [隐藏所有这些复杂性
并合成那个保留和释放字段的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=359) [所以编译器实际上是你的朋友](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=363) [它对栈上的变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=365) [以及其他结构中的字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=369) [以及Objective-C类中的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=371) [实例变量
都进行了正确的管理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=374) [但是有一个地方](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=379) [我们需要做一些额外的工作
来支持使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=383) [ARC对象指针字段的结构
这个地方就是堆](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=387) [让我们回到我们的结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=390) [我们假设
你希望在堆中分配一个菜单项数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=392) [若这是Objective-C接口
我们就可以在此用NSArray](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=396) [但它不是 所以让我们使用
malloc和free](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=402) [现在这段代码实际上有两个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=406) [首先内存在分配时不是零初始化的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=409) [这意味着它们的指针是无效的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=415) [这将导致程序在运行时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=418) [这将导致程序在运行时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=418) [出现不希望的运行时行为](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=421) [第二个问题是在释放内存之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=425) [ARC对象指针字段未被清除](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=429) [这将导致你的程序运行时内存泄漏](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=432) [要解决第一个问题
可将对malloc的调用替换为对calloc的调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=439) [这将确保你的内存是零初始化的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=445) [这将消除所有那些令人不快的
意想不到的运行时问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=450) [要解决第二个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=455) [你可以在循环分配到内存之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=459) [编写一个循环以清除项目中的
所有ARC对象指针字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=462) [这将确保在释放条目时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=466) [条目中的名称和价格不会泄漏](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=469) [现在这是一个令人兴奋的新特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=476) [如果你们当中
由于缺少这样的特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=479) [如果你们当中
由于缺少这样的特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=479) [而推迟迁移到ARC中的话](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=483) [我希望Xcode 10中
对ARC对象指针字段的支持](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=486) [可以帮助你重新考虑你的选择](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=490) [我们来看看Objective-C
指针和一般的结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=494) [看看在Xcode 10中
在不同的语言模式中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=498) [在哪里以及如何使用这些结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=503) [在Xcode 10中
你可以使用具有](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=507) [Objective-C](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=511) [对象指针字段的结构
来跨越不同的语言模式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=514) [例如你可以在C、Objective-C
甚至Objective-C++中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=516) [使用相同的结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=521) [而且即使在ARC或
手动保留释放模式下编译代码时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=524) [它也会正常工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=530) [在Xcode 10中
实际上我们在调用函数之间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=534) [统一了
Objective-C++ ABI](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=539) [统一了
Objective-C++ ABI](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=539) [这些函数接收或返回具有
Objective-C++中的ARC对象指针字段的结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=544) [这是通过Xcode 10中的
ABI更改来完成的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=548) [这种ABI变化影响了
Objective-C++中的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=553) [这些函数通过值返回或接受](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=557) [具有ARC对象指针字段的结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=561) [而没有像构造函数或析构函数
那样的特殊成员函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=566) [现在如果你不确定这对你意味着什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=570) [或者你的代码是否受到
此ABI更改的影响](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=573) [请查看Xcode的发行说明](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=577) [描述了此ABI更改的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=579) [效果和影响](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=582) [（结构中的
OBJECTIVE-C对象）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=585) [对于ARC对象指针字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=588) [和C结构 我们有一个警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=590) [它们在Swift中没有支持](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=595) [因此如果你尝试使用一个具有](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=597) [Swift中
ARC对象指针字段的结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=599) [Swift中
ARC对象指针字段的结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=599) [你只会得到一个编译错误
因为找不到该结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=603) [（对于某些函数的ABI更改
通过值传递或返回结构）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=607) [（Swift不支持使用
ARC对象指针字段导入结构）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=610) [除了像支持ARC对指针字段的
新特性之外](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=613) [Xcode 10
还附带了许多新的编译器诊断](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=619) [在Xcode 10中
我们实际上有超过100个新的警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=624) [今天我想谈谈其中的两个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=628) [（Xcode 10中的新诊断）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=630) [第一个警告可能对那些混合了
Swift和Objective-C代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=632) [的人感兴趣](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=635) [因如你所知Swift代码
可以导入Objective-C](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=639) [Xcode允许你
通过生成一个使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=645) [Objective-C声明描述
Swift接口的头文件来实现这点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=650) [（SWIFT和
OBJECTIVE-C互操作性）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=654) [你可以将这个头文件导入到你自己的
Objective-C代码中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=656) [以便访问底层的Swift声明](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=660) [现在让我们更具体地讨论一下](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=664) [如何将Swift的闭包参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=666) [导入到Objective-C中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=669) [现在屏幕上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=672) [你看到了一个叫Executor的
Swift协议的例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=674) [该协议定义了一个名为
performOperation的函数成员](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=678) [它接受一个名为
handler的闭包参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=682) [现在Swift中闭包参数
在默认情况下是不转义的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=687) [这意味着在函数返回后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=691) [它们不应该被保留或调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=695) [现在当符合
Objective-C时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=698) [程序员很容易忘记这个契约是存在的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=703) [例如 正如你现在幻灯片上看到的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=708) [在Objective-C中
我们有一个调度执行器接口](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=711) [并且符合Executor协议](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=715) [因此它提供了
performOperation方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=718) [因此它提供了
performOperation方法](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=718) [该方法接受与Swift的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=721) [处理程序闭包参数对应的
处理程序块参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=723) [但仅仅通过查看
Objective-C代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=727) [我们无法知道](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=730) [处理程序参数是否可以转义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=731) [Xcode 10
现在提供了一个警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=736) [帮助我们记住这个参数
实际上不是转义的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=741) [为了修正这个警告 你可以使用
NS_NOESCAPE注释](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=747) [来注释你的块参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=751) [你还应该用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=754) [NS_NOESCAPE注释
来注释方法的实现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=755) [或方法实现中的参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=759) [NS_NOESCAPE注释只是
一个对程序员的提醒](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=764) [以确保在执行操作方法返回后](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=770) [你不存储或调用处理程序块](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=774) [因此这是为了帮助你记住](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=779) [因此这是为了帮助你记住](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=779) [Swift和Object-C代码
之间存在这样的契约](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=782) [现在第二个警告
可能对那些使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=789) [更低级别代码并关心](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=794) [结构在内存中的布局方式的人感兴趣](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=795) [让我们来看看一个结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=801) [在C语言中结构必须遵循严格的
布局和对齐规则](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=803) [在这个特殊的结构中
你可以在幻灯片上看到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=809) [编译器必须在
结构的第二个和第三个字段之间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=812) [插入一个2字节的填充](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=816) [有时你可能想要放松这些规则](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=820) [编译器提供了一个
pragma pack指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=824) [你可以用它来控制布局和结构的对齐](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=827) [（用#PRAGMA PACK
填充结构构件）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=832) [现在这个示例中我们使用
pragma pack push 1指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=834) [来删除这个固定的布局](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=839) [来删除这个固定的布局](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=839) [并确保我们的结构是紧凑的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=843) [这在序列化结构或通过网络](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=847) [传输结构时非常有用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=851) [现在pragma pack通常
与push和pop指令一起使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=854) [但是程序员很容易忘记将
pop插入到代码中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=860) [Xcode 10现在会警告那些
没有相应的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=867) [pragma pack pop
指令的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=870) [它会将你指向push的位置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=874) [（找到不平衡的
#PRAGMA PACK指令）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=877) [为了修复这个警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=879) [你应该查看push指令的位置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=881) [并将pop指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=885) [插入到代码中的相应位置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=887) [在我们的例子中我们可以在
填充结构之后直接插入pop](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=891) [一旦我们这样做了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=897) [新的布局规则将只适用于填充结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=899) [新的布局规则将只适用于填充结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=899) [因此它们不会影响程序中的
任何其他结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=903) [我提到的这两个新警告
在Xcode 10中默认启用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=911) [它们可以帮助你
编写更正确更健壮的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=917) [为了更多地讨论更正确更健壮的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=923) [我想请George上台](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=926) [他将讨论](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=929) [Xcode 10中
新的静态分析改进](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=930) [George](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=934) [（CLANG静态分析器）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=935) [谢谢 Alex](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=941) [我想向你介绍一些](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=942) [我们为Clang静态分析器
Xcode 10所做的改进](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=945) [Clang静态分析器
是一个很好的工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=950) [可以在你的程序中找到边缘案例
难以再现的漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=952) [静态分析器不仅为你查找漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=957) [还在列出漏洞的路径的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=960) [Xcode中显示其可视化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=963) [NSMutableArray中
添加了nil 可能在稍后导致崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=965) [静态分析器向你展示了
这个崩溃的路径](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=971) [这样你就可以看到
app是如何被修复的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=974) [我想告诉你们
我们所做的三项新的改进](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=978) [首先我们有了一个新的检查
用来检测伟大的中央调度反模式](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=983) [这可能会导致不良的性能
和挂起你的app](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=988) [其次我们有一项新的检查
用于检测](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=992) [动释放池中的自动释放变量的误用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=995) [这可能会导致释放后使用崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=999) [最后我们改进了
Clang静态分析器的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1002) [性能和可视](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1006) [那么让我们从一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1009) [检测伟大的中央调度反模式检查开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1012) [我们平台上的许多API都是异步的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1014) [但有时开发人员出于某种原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1019) [但有时开发人员出于某种原因](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1019) [希望以同步的方式使用它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1021) [可能是因为他们的代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1025) [已经在后台队列上运行了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1026) [或者是因为函数在必需的值可用之前](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1029) [根本无法继续运行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1031) [而那里诱人的解决方案是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1034) [使用信号量来确保同步](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1036) [这就是这个例子中的情况](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1040) [所以这里有一个SXPC对象
self.connection](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1043) [我们使用它的属性
remoteObjectProxy](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1047) [从另一个进程异步地](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1051) [获取递归任务的名称](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1055) [然后我们等待一个信号量
它是回调内部的一个信号](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1057) [这有助于确保在函数返回任务名时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1063) [任务名是可用的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1067) [因此这种方法是可行的
但它具有一定的性能含义](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1069) [因此这里的主要问题是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1074) [当你在某个异步进程上
等待使用信号量时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1075) [当你在某个异步进程上
等待使用信号量时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1075) [你可能会等待一个优先级](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1080) [比你的队列低得多的队列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1082) [这会导致优先级反转](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1085) [这会恶化性能并导致挂起](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1086) [而且以这种方式使用信号量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1090) [也会产生无用的线程
从而进一步降低性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1093) [为了帮助你解决这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1098) [现在静态分析器对这种情况提出警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1101) [帮助了解问题发生的地点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1106) [（伟大的中央调度性能反模式）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1109) [现在让我们看看如何解决这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1111) [在最好的情况下
有一个可供使用的同步API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1114) [可以替代使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1118) [因此对于SXPC连接
有了一个类似的API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1120) [即synchronousRemoteObjectProxy](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1124) [当使用它时
它消除了对信号量的需求](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1127) [运行速度要快得多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1131) [或者如果没有这样的同步API可用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1135) [你可以重构app
以使用安装的连续程序](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1139) [你可以重构app
以使用安装的连续程序](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1139) [只需在回调中调用所需的函数即可](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1143) [这个检查在默认情况下是不启用的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1149) [但是我们鼓励你在构建设置中启用它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1151) [以确保在你的app中
不会出现这样的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1154) [并尽可能快地运行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1157) [现在让我们讨论第二个检查](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1161) [用于检测](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1163) [比自动释放池的生命周期
更长的自动释放变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1165) [自动释放限定符指定
一旦控件退出自动释放池](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1170) [就必须释放该值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1175) [这里有一个例子
我们在自动释放池中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1178) [创建一个错误变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1183) [一旦控件在自动释放池之外](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1184) [个变量就会被释放 然后被销毁](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1187) [自动释放池是
Objective-C的有用特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1191) [它有助于控制app的大内存占用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1195) [并确保在必要时销毁临时内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1198) [并确保在必要时销毁临时内存](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1198) [然而它可能会导致意外的崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1203) [而且它们更令人意外](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1207) [因为你甚至不需要在app中
编写“自动释放”这个词](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1209) [就可以发生这些崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1212) [例如这里有一个验证函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1215) [它接受out参数NSError](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1219) [而out参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1222) [在Objective-C中
默认为ARC](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1223) [所以当我们把这个out参数
写在自动释放池中时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1228) [然后函数退出时
错误值就被释放了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1235) [如果调用者试图
读取这个错误变量的值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1239) [他们可能会释放后使用中崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1243) [（OUT参数和自动存储池）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1246) [（获块中的自恢复变量）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1248) [这种模式已经很难被发现
但是当你甚至不控制](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1250) [拥有自动存储池的app的部分时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1255) [这种模式会变得更糟](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1258) [这种模式会变得更糟](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1258) [这里有一个类似的函数
它也接受out参数错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1260) [然后调用
一个enumerateObjectsUsingBlock](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1266) [这是一个流行的
foundation API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1269) [它在集合的每个元素上调用一个块](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1272) [但是enumerateObjectsUsingBlock](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1276) [实际上把x称为返回的
自动释放返回池中的一个给定块](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1279) [因此这里也出现了一个类似的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1284) [当我们在块中创建一个错误值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1286) [并将其写入out参数时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1290) [当控件到达
enumerateObjectsUsingBlock时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1292) [它实际上会被释放](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1294) [然后当调用者试图阅读它时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1299) [它们也可能会释放后使用中崩溃](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1302) [在此之前
我们已经介绍了编译器警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1307) [它在块中捕获隐式自动发出的参数时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1311) [发出警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1315) [编译器警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1316) [建议显式地使这些参数自动发送](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1318) [建议显式地使这些参数自动发送](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1318) [但是我们注意到
这样的问题一直在发生](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1322) [所以在Xcode 10中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1325) [我们引入了一个功能更强大的
Clang静态分析器警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1327) [它知道哪些API](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1331) [调用了自动释放池中提供的块](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1335) [并对此类情况进行警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1338) [（Xcode 10：
检查自动释放误用）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1341) [现在让我们看看如何解决这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1343) [这里最简单的方法就是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1346) [引入一个强大的局部变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1348) [然后当你在块中时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1351) [将一个值写入内部的强变量中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1353) [将一个值写入内部的强变量中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1357) [只复制到out参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1360) [并且你知道它不在自动释放池中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1362) [因此写入自动释放变量是安全的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1365) [（改进性能和报告可视化）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1370) [最后我们还改进了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1373) [Clang静态分析器的性能
和可视化](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1377) [因此在Xcode 10中
我们改进了分析器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1379) [因此在Xcode 10中
我们改进了分析器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1379) [以更有效的方式探索你的程序](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1383) [现在它在相同的分析时间内
发现的漏洞比以前多出15%](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1385) [它不仅发现了更多的漏洞
而且它现在生成的漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1392) [报告往往更小也更容易理解](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1397) [我的意思是
有时候在Xcode 10中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1400) [你会得到](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1404) [很多步骤和箭头的例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1405) [这些例子有些难以理解](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1408) [在Xcode的新版本中的
许多示例中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1411) [我们提供了一个更小的错误路径
它更容易查看](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1415) [你可以更快地看到问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1419) [因此为了在项目中使用静态分析器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1423) [你可以使用产品 分析
甚至可以在构建期间启用分析](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1427) [以确保分析器问题不被忽略](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1433) [所以我鼓励你使用静态分析器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1437) [它是一个很好的工具
可以在用户使用之前发现你的错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1439) [它是一个很好的工具
可以在用户使用之前发现你的错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1439) [现在我的同事Ahmed
将会讨论低水平的改进](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1443) [（加强安全）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1447) [谢谢George](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1450) [如Alex和George告诉你的
我们在编译器中有很多警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1454) [和静态分析器检查](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1458) [但是你也有杀毒软件](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1461) [和所有这些工具
可以帮助你发现很多漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1463) [包括安全漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1465) [所以我相信你们都有很多测试
并且使用所有这些工具](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1468) [来发现这些测试中的所有漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1471) [但是对于一些最恶劣的安全漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1475) [如果它们以某种方式
通过了所有的测试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1478) [我们希望确保它们
不会在发布版构建中出现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1481) [因此对于那些
我们在代码生成器中有缓解的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1485) [即使在发布版本中我们也希望如此](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1489) [我是Ahmed
我做代码生成器工作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1492) [今天我将告诉大家
Xcode 10中新的缓解措施](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1494) [要了解它是如何工作的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1500) [我们就需要了解栈是如何工作的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1501) [这里我有一个简单的C函数
叫做dlog](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1504) [我用它来打印
我传入dlog错误的字符串](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1509) [在这种情况下
用字符串hello来调用它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1514) [它的工作方式是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1518) [我们需分配一些内存来跟踪这个调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1519) [我们把它分配到一个叫做栈的区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1526) [栈向空指针或地址0方向向下延伸](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1529) [因此当我们执行
dlog“hello”调用时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1535) [这会分配所谓的堆栈帧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1538) [堆栈帧包含类似返回地址的内容](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1541) [这样我们就知道
如何返回main](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1544) [但它也包含其他东西
如参数和局部变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1547) [因此例如
如果我有一个日志文件路径局部变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1551) [它就驻留在堆栈框架中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1556) [如果我尝试对这个dlog文件
函数进行另一个函数调用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1560) [那么这个函数
就会分配它自己的堆栈帧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1565) [当它完成时
它将重新分配堆栈帧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1569) [并返回给调用者](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1572) [现在我们更详细地看看这个堆栈框架](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1576) [假设我将函数改成一个本地缓冲区](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1581) [这是一个4字节的字符数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1585) [我正在尝试通过先做一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1589) [我传递到缓冲区中的字符串的
strcpy来准备调试字符串](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1592) [strcpy来准备调试字符串
H-E-L-L](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1598) [但问题是在这一点上
我们已经写了4个字节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1606) [我们已经用尽了在我们的缓冲区中
可用的所有4个字节](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1609) [所以如果我们继续
这就是Strcpy所做的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1614) [那么我们将重写返回地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1617) [这是一个很大的安全问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1621) [如果攻击者控制了
我正在复制的字符串 这并不难](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1622) [那么它可以控制返回地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1627) [如果它能控制返回地址](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1630) [那么他们就基本上控制了
程序下一步做什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1631) [所以这是很大的安全问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1634) [因此如果你有一个测试捕捉到了这个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1638) [并且运行了地址消毒器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1642) [那么你将有一个简单的方法
来解决这个问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1644) [实际上 我在这里应该做的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1648) [strncpy 它知道大小](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1650) [甚至更好 使用更高级别的API
NSString或STD字符串](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1653) [但是有时候这些漏洞
仍然可以在发布版构建中存活下来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1659) [我们通过使用
所谓的堆栈保护器来避免它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1663) [栈保护器改变了堆栈框架的布局
添加一个新的字段](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1669) [金丝雀](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1672) [这样当我们写的时候](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1675) [我们会在函数返回之前有一些代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1678) [我们会在函数返回之前有一些代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1678) [来检查金丝雀是否有效](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1682) [所以如我们继续用strcpy来写
我们首先要覆盖金丝雀](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1686) [然后在返回之前先检查金丝雀](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1691) [然后就会终止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1695) [因此我们将一个潜在的
可利用的安全漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1697) [转化为可靠的崩溃
这对攻击者是不利的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1701) [这就是所谓的堆栈保护器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1706) [（堆栈保护器）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1711) [它检测到某些类型的堆栈缓冲区溢出](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1712) [就是我们刚才看到的攻击](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1716) [在许多版本的Xcode中
它已经默认启用了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1718) [下来我要讲一个更复杂的例子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1724) [我们引入了一个新的缓解措施](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1727) [假设我取了我的函数
也是我的dlog函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1730) [我改变了缓冲区
现在它是一个可变长度的数组](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1735) [长度来自一个叫做len的参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1739) [长度来自一个叫做len的参数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1739) [假设在一个特定的调用中
len是很大的 比如15000](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1744) [所以现在堆栈帧必须至少有
15000字节长](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1750) [但是内存并不是立即可用的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1756) [所以内存被分成了几页](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1760) [而堆栈只在需要时才增长](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1762) [例如当我们试图访问
堆栈下一页中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1766) [缓冲区的10000个字节时
这仍然是不可用的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1770) [所以它在CPU中做了一个](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1775) [与操作系统对话的页面错误](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1777) [操作系统看到我们有权力增长堆栈](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1779) [并且它增长了它
我们可以继续编写](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1782) [这些都发生在引擎盖下面](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1784) [但是 如果攻击者控制了长度
它使长度变得很大](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1789) [大到足以跨越许多页](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1793) [所以现在就有了一个新问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1797) [内存不是无限的
所以如果我们继续在这个堆栈中分配](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1799) [内存不是无限的
所以如果我们继续在这个堆栈中分配](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1799) [最终我们会到达](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1804) [另一个已经分配的内存区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1805) [通常是堆](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1808) [当我们这样做的时候
我们将会与堆发生冲突](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1810) [与已使用的
任何东西发生冲突](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1813) [这通常是像
malloc和new此类东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1815) [如果我们试着看看
strcpy例子会发生什么](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1820) [然后我们试着
把字节一个一个地写下来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1824) [我们做H-E-L等等](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1830) [从CPU的角度来看](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1833) [生成的代码和操作系统](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1835) [这都没问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1837) [因为我们只是在写一个已经可用的
和已经被分配的页面](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1839) [但实际上并非如此
因为这是堆的一部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1844) [这不是本地堆栈分配数组的一部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1847) [所以当我们写东西的时候
我们实际上是在覆盖](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1851) [一些完全不相关的信息](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1853) [比如我不知道一个布尔值
用来检查我们是否应该检查密码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1856) [这是另一个重要的安全漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1860) [这是我们用一个新特性来缓解的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1866) [这个特性是通过在函数的入口](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1870) [发出些新代码来工作的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1874) [这个函数检查堆栈框架是否可以使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1876) [所以它询问操作系统堆栈的最大空间](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1881) [如果你尝试做一个大于那个的分配](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1885) [那么它实际上就会终止](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1887) [这将把一个潜在的
可利用的安全漏洞](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1891) [变成了可靠的崩溃
这对攻击者没有好处](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1895) [所以这就是堆栈检查
它检测所说的堆栈冲突](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1901) [你可能听说过它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1903) [在Xcode 10中默认启用它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1906) [（堆栈检查）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1908) [（检测“堆栈冲突”
在Xcode 10中默认启用）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1909) [接下来我想谈谈我们在
Xcode 10中添的一组新特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1913) [这就是对新扩展的支持：
设置扩展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1917) [这就是对新扩展的支持：
设置扩展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1917) [那么大家都知道
我们有很多很棒的Apple设备](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1922) [Xcode的一个伟大之处在于
只要使用少量的构建设置](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1926) [你就可以针对
这些设备中的每一个设定代码](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1930) [因此在macOS、iOS
watchOS等等的引擎盖下](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1935) [我们对每个都进行了调整
这样它就可以使用特定硬件上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1939) [所有可用的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1944) [因此无论我们在哪里运行
它都能保证它的最大的性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1946) [因此如果你的app
具有极高的性能要求](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1951) [这也是你可能要做的事情](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1955) [因此我们有三个功能可以讨论](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1959) [它们可以用在iMac Pro
和iPhone 8 Plus和X上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1962) [让我们从iMac Pro开始](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1967) [iMac Pro
有Intel Xeon的CPU](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1971) [它有一组名为
AVX-512的新特性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1975) [AVX-512是一组
带有矢量寄存器的新指令](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1982) [这些是X86-64的好](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1988) [在X86-64中 我们只能假设
我们有128位矢量可用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=1993) [这在任何Mac电脑上都是可以保证的
这是 Intel提供的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2000) [现在任何新的Mac电脑
都有了更多的功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2005) [但是iMac Pro是第一个有
512位寄存器的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2008) [在Xcode Clang中
启用了自动矢量化器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2015) [这很好
因为它意味着](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2020) [我们可以在向量中有更多的元素](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2023) [这样可以大大提高吞吐量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2026) [AVX-512还有其他好处](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2031) [例如我们不仅有更大的向量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2033) [我们还有更多的向量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2037) [所以在X86-64上我们只有16
现在我们有32](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2039) [所以在X86-64上我们只有16
现在我们有32](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2039) [所以是大量的数据需要处理](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2043) [即使由于某种原因自动向量器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2047) [无法使用这些向量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2049) [那么我们仍然有更多的技能寄存器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2053) [甚至对于那些只会浮动或加倍的代码
也是如此](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2056) [在AVX-512中有很多性能优势](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2060) [以让我们看看我们如何](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2064) [利用我的计算
量大、昂贵的函数来开发它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2067) [所以我要做的第一件事就是
保留现有的功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2071) [因为这将是我在所有Mac上
运行的可以依靠的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2076) [接下来我可以尝试专门化我的函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2081) [一种方法是使用目标属性](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2084) [这告诉编译器
可以假设](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2089) [这个函数有AVX-512
它只运行在iMac Pro上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2091) [因此如果你使用simd.h 例如
simd_float4 128位向量类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2097) [因此如果你使用simd.h 例如
simd_float4 128位向量类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2097) [现在我们可以使用相同的代码
在AVX-512 版本上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2102) [获得更好的性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2105) [如果你使用更大的向量类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2109) [比如 simd浮点数16](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2111) [那么现在你的性能要比
AVX-512版本好得多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2113) [AVX-512版本中
512位矢量实际是负的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2117) [如果你一直伸入到到X86本质](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2122) [那么现在你可以开始使用新的
AVX-512方差](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2124) [和M512类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2128) [因此如果你想专攻更大的代码单元](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2132) [那么不仅是单个函数
还有文件、目标、库](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2135) [然后你可以使用附加向量扩展构建](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2140) [设置的新的AVX-512值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2143) [（在XCODE中
启用AVX-512）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2146) [所以当你这样做的时候
有一些事情要记住](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2149) [如果你熟悉AVX-1和AVX-2
这些都是非常相似的问题](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2151) [（AVX-512考虑）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2156) [所以你只能从
AVX-512函数传递或](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2158) [所以你只能从
AVX-512函数传递或](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2158) [向AVX-512函数传递大的向量
比如256位和更大的位](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2163) [因此如果ABI与
一般的和特殊的方差是不一样的话](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2165) [你就不能把它们传递给它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2169) [此外这些向量很大](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2174) [而且它们足够大
以至于它们的自然对齐度太大](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2177) [无法像malloc
这样的东西来保证](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2180) [因此在将这些分配到
堆栈以外的任何地方时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2183) [都必须考虑到这一点](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2186) [所以总的来说
所有这些都是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2190) [我们在操作系统中已经历过的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2192) [例如你可以使用加速框架](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2196) [就容易多了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2199) [因为我们已经专门为每一个微架构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2201) [提供了所有的功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2204) [这就是AVX-512](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2208) [iPhone 8、8 Plus
和X都有新功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2211) [那么第一个功能是
ARM v8.1原子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2219) [那么第一个功能是
ARM v8.1原子](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2219) [这得益于iPhone X
的一个伟大的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2224) [这是A11 Bionic芯片](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2230) [因此与A10相比
A11 Bionic芯片有很棒的新功能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2236) [它支持六个CPU
六个核心同时运行](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2243) [这在iOS系统中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2248) [是第一个而且由于你有更多的内核](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2252) [所以你可能同时拥有更多的线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2254) [使用更多的线程](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2257) [你可能需要更多的同步
来使这些线程协作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2258) [这是用原子实现的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2262) [A11 Bionic还引入了
一个新的原子指令系列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2265) [更好地优化了新的额外的核心](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2269) [让我们来看看它是如何工作的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2277) [原子的工作方式
是通过一个小的代码序列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2280) [假设我有一个线程
它试图访问主存储器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2285) [所以它在那里有一个原子共享变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2290) [它只是想要增加它](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2293) [（原子）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2295) [因此在引擎盖下
代码生成器将发出一个小代码序列](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2297) [该代码首先对高速缓存
行进行独占访问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2302) [这是完全包含](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2305) [该原子变量的一个小的内存区域](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2307) [现在我们拥有独占访问权
可以从变量加载](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2313) [并且可以在临时加载值上进行增量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2317) [并将结果存储起来](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2320) [我们知道这是安全的
因为我们有独占访问权](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2324) [所以在计算临时结果时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2327) [没有其他线程可以更改值](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2330) [但是现在假设有另一个线程
也要访问同一缓存行中的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2333) [相同变量或另一个变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2337) [相同变量或另一个变量](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2337) [所以两者都会尝试](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2342) [对这个变量进行排他性访问](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2344) [这是不可能的
这就是排他性的意思](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2347) [因此它们都将无法获得独家访问权](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2352) [它们将不得不再次尝试
直到其中一个成功](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2356) [这对性能来说并不是好东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2362) [因此在ARM v8.1中
它是A10 CPU中的体系结构](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2365) [我们有新的指令
在一步内完成所有这些操作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2371) [在某些情况下这可以极大地提高性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2374) [因此这也是你可以
使用每个函数专门化方法或](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2378) [针对整个目标而专门化代码的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2381) [只有当你有自己的C11
或C++ 11原子时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2387) [它才是真正有用的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2389) [因此一般来说
使用更高级别的库](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2393) [例如像GCD或PThread
或os_unfair_lock等容易得多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2396) [这些已经对
ARM v8.1进行了调整](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2400) [但它们也与操作系统合作](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2403) [以获得更好的性能](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2405) [A11 CPU的另一个特性是
16位浮点数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2411) [大家都很熟悉两种标准的浮点类型](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2416) [所以我们有两者64位](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2420) [和浮点32位](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2423) [所以在A11中我们也有
16位浮点数16](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2426) [它的范围和精度都要小得多
所以它在很多情况下都不那么有用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2430) [但在某些情况下 比如机器学习](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2438) [或当你试图通过Metal
与GPU交谈时](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2439) [这是很棒的
因为它更小 计算更快](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2441) [如果把它们放到向量中
这就更对了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2445) [在此你可以把它们更多的放在
同一个ARM向量中](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2447) [因此这也是你可以专门化代码的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2453) [一般来说需要记住的是](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2456) [这些特性并不是随处可见的](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2460) [因此当你想使用它们时
必须始终确保它们](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2463) [在运行的设备上是动态可用的
并且可以使用](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2466) [sysctlbyname](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2468) [来实现](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2470) [（检测指令集扩展）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2472) [因此总的来说
我们已经在](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2474) [系统框架中完成了所有工作
靠这些就更容易了](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2476) [这是三个新的指令集扩展](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2481) [在iMac Pro
AVX-512上](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2484) [在iPhone X、8和8 Plus上
我们有原子和16位浮点数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2486) [（新指令集扩展）](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2490) [这就是Xcode中
所有新特性的一部分](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2493) [所以从C结构的ARC对象指针
到改进的静态分析器](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2497) [Xcode 10中
有很多很棒的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2501) [还有一些我们甚至没有讨论过的东西](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2505) [比如超过100个新的警告](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2507) [支持C++ 17标准库函数](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2509) [如果你想了解更多](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2515) [我们将很快有视频和幻灯片
在网站上提供](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2517) [我们将很快有视频和幻灯片
在网站上提供](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2517) [如果你出席了本场会议
今天下午和我们一起去实验室吧](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2521) [谢谢大家](https://developer.apple.com/videos/wwdc2018/videos/play/wwdc2018/409/?time=2524)