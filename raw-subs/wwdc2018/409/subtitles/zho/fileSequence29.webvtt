WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.106 --> 00:29:01.508 align:middle line:-1
长度来自一个叫做len的参数

00:29:04.044 --> 00:29:09.716 align:middle line:-2
假设在一个特定的调用中
len是很大的 比如15000

00:29:10.984 --> 00:29:14.054 align:middle line:-2
所以现在堆栈帧必须至少有
15000字节长

00:29:16.924 --> 00:29:19.693 align:middle line:-1
但是内存并不是立即可用的

00:29:20.127 --> 00:29:22.062 align:middle line:-1
所以内存被分成了几页

00:29:22.663 --> 00:29:25.732 align:middle line:-1
而堆栈只在需要时才增长

00:29:26.633 --> 00:29:30.804 align:middle line:-2
例如当我们试图访问
堆栈下一页中

00:29:30.871 --> 00:29:35.075 align:middle line:-2
缓冲区的10000个字节时
这仍然是不可用的

00:29:35.509 --> 00:29:37.211 align:middle line:-1
所以它在CPU中做了一个

00:29:37.277 --> 00:29:38.879 align:middle line:-1
与操作系统对话的页面错误

00:29:39.012 --> 00:29:41.915 align:middle line:-1
操作系统看到我们有权力增长堆栈

00:29:42.049 --> 00:29:44.084 align:middle line:-2
并且它增长了它
我们可以继续编写

00:29:44.918 --> 00:29:46.486 align:middle line:-1
这些都发生在引擎盖下面

00:29:49.056 --> 00:29:53.560 align:middle line:-2
但是 如果攻击者控制了长度
它使长度变得很大

00:29:53.994 --> 00:29:56.230 align:middle line:-1
大到足以跨越许多页

00:29:57.865 --> 00:29:59.199 align:middle line:-1
所以现在就有了一个新问题

00:29:59.867 --> 00:30:04.438 align:middle line:-2
内存不是无限的
所以如果我们继续在这个堆栈中分配

