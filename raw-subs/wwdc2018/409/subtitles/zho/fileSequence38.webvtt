WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:38:00.681 --> 00:38:05.085 align:middle line:-2
原子的工作方式
是通过一个小的代码序列

00:38:05.853 --> 00:38:09.489 align:middle line:-2
假设我有一个线程
它试图访问主存储器

00:38:10.424 --> 00:38:13.093 align:middle line:-1
所以它在那里有一个原子共享变量

00:38:13.694 --> 00:38:15.362 align:middle line:-1
它只是想要增加它

00:38:15.429 --> 00:38:17.431 align:middle line:-1
（原子）

00:38:17.497 --> 00:38:21.134 align:middle line:-2
因此在引擎盖下
代码生成器将发出一个小代码序列

00:38:22.002 --> 00:38:25.405 align:middle line:-2
该代码首先对高速缓存
行进行独占访问

00:38:25.939 --> 00:38:27.774 align:middle line:-1
这是完全包含

00:38:27.941 --> 00:38:30.844 align:middle line:-1
该原子变量的一个小的内存区域

00:38:33.747 --> 00:38:36.783 align:middle line:-2
现在我们拥有独占访问权
可以从变量加载

00:38:37.351 --> 00:38:40.254 align:middle line:-1
并且可以在临时加载值上进行增量

00:38:40.754 --> 00:38:42.456 align:middle line:-1
并将结果存储起来

00:38:44.825 --> 00:38:47.427 align:middle line:-2
我们知道这是安全的
因为我们有独占访问权

00:38:47.694 --> 00:38:49.930 align:middle line:-1
所以在计算临时结果时

00:38:50.030 --> 00:38:52.366 align:middle line:-1
没有其他线程可以更改值

00:38:53.934 --> 00:38:57.804 align:middle line:-2
但是现在假设有另一个线程
也要访问同一缓存行中的

00:38:57.871 --> 00:39:00.107 align:middle line:-1
相同变量或另一个变量

